
diff --git a/contracts/zkTrueUp/account/AccountFacet.sol b/contracts/zkTrueUp/account/AccountFacet.sol
index 647e0ed..5db2c6e 100644
--- a/contracts/zkTrueUp/account/AccountFacet.sol
+++ b/contracts/zkTrueUp/account/AccountFacet.sol
@@ -1,169 +1,267 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
 import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 import {ReentrancyGuard} from "@solidstate/contracts/security/reentrancy_guard/ReentrancyGuard.sol";
-import {AccountStorage} from "./AccountStorage.sol";
+import {AccountStorage, WITHDRAW_TYPEHASH} from "./AccountStorage.sol";
+import {AddressStorage} from "../address/AddressStorage.sol";
 import {RollupStorage} from "../rollup/RollupStorage.sol";
-import {TokenStorage} from "../token/TokenStorage.sol";
+import {TokenStorage, AssetConfig} from "../token/TokenStorage.sol";
+import {EvacuationStorage} from "../evacuation/EvacuationStorage.sol";
 import {IAccountFacet} from "./IAccountFacet.sol";
 import {TokenLib} from "../token/TokenLib.sol";
 import {RollupLib} from "../rollup/RollupLib.sol";
 import {AccountLib} from "./AccountLib.sol";
-import {TsbLib} from "../tsb/TsbLib.sol";
-import {AssetConfig} from "../token/TokenStorage.sol";
-import {ITsbToken} from "../interfaces/ITsbToken.sol";
+import {AddressLib} from "../address/AddressLib.sol";
+import {EvacuationLib} from "../evacuation/EvacuationLib.sol";
 import {Config} from "../libraries/Config.sol";
 import {Utils} from "../libraries/Utils.sol";
 import {BabyJubJub, Point} from "../libraries/BabyJubJub.sol";
+import {DELEGATE_WITHDRAW_MASK} from "../libraries/Delegate.sol";
 
 /**
  * @title Term Structure Account Facet Contract
  * @author Term Structure Labs
  * @notice The AccountFacet is a contract to manages accounts in Term Structure Protocol,
  *         including many I.O. operations such as register, deposit, withdraw, forceWithdraw, etc.
  */
 contract AccountFacet is IAccountFacet, ReentrancyGuard {
-    using AccountLib for AccountStorage.Layout;
+    using AccountLib for *;
+    using AddressLib for AddressStorage.Layout;
     using RollupLib for RollupStorage.Layout;
     using TokenLib for TokenStorage.Layout;
+    using EvacuationLib for EvacuationStorage.Layout;
 
     /* ============ External Functions ============ */
 
     /**
      * @inheritdoc IAccountFacet
      * @dev The account is registered by depositing Ether or whitelisted ERC20 to ZkTrueUp
      */
     function register(uint256 tsPubKeyX, uint256 tsPubKeyY, IERC20 token, uint128 amount) external payable {
-        RollupStorage.Layout storage rsl = RollupStorage.layout();
-        rsl.requireActive();
+        EvacuationStorage.Layout storage esl = EvacuationStorage.layout();
+        esl.requireActive();
 
         TokenStorage.Layout storage tsl = TokenStorage.layout();
         tsl.requireBaseToken(token);
 
+        RollupStorage.Layout storage rsl = RollupStorage.layout();
         uint32 accountId = _register(rsl, msg.sender, tsPubKeyX, tsPubKeyY);
         _deposit(rsl, tsl, msg.sender, msg.sender, accountId, token, amount);
     }
 
     /**
      * @inheritdoc IAccountFacet
      * @dev Only registered accounts can deposit
      */
-    function deposit(address to, IERC20 token, uint128 amount) external payable {
-        RollupStorage.Layout storage rsl = RollupStorage.layout();
-        rsl.requireActive();
+    function deposit(address accountAddr, IERC20 token, uint128 amount) external payable {
+        EvacuationStorage.Layout storage esl = EvacuationStorage.layout();
+        esl.requireActive();
 
         AccountStorage.Layout storage asl = AccountStorage.layout();
-        uint32 accountId = asl.getValidAccount(to);
+        uint32 accountId = asl.getValidAccount(accountAddr);
 
+        RollupStorage.Layout storage rsl = RollupStorage.layout();
         TokenStorage.Layout storage tsl = TokenStorage.layout();
-        _deposit(rsl, tsl, msg.sender, to, accountId, token, amount);
+        _deposit(rsl, tsl, msg.sender, accountAddr, accountId, token, amount);
     }
 
     /**
      * @inheritdoc IAccountFacet
      */
-    function withdraw(IERC20 token, uint256 amount) external virtual nonReentrant {
+    function withdraw(address accountAddr, IERC20 token, uint256 amount) external nonReentrant {
         AccountStorage.Layout storage asl = AccountStorage.layout();
-        uint32 accountId = asl.getValidAccount(msg.sender);
+        asl.requireValidCaller(msg.sender, accountAddr, DELEGATE_WITHDRAW_MASK);
 
-        TokenStorage.Layout storage tsl = TokenStorage.layout();
-        (uint16 tokenId, AssetConfig memory assetConfig) = tsl.getValidToken(token);
+        uint32 accountId = asl.getValidAccount(accountAddr);
+        _withdraw(msg.sender, accountAddr, accountId, token, amount);
+    }
 
-        RollupStorage.Layout storage rsl = RollupStorage.layout();
-        AccountLib.updateWithdrawalRecord(rsl, msg.sender, accountId, token, tokenId, amount);
+    //! mainnet-audit
+    /**
+     * @inheritdoc IAccountFacet
+     */
+    function withdrawWithPermit(
+        address accountAddr,
+        IERC20 token,
+        uint256 amount,
+        uint256 deadline,
+        uint8 v,
+        bytes32 r,
+        bytes32 s
+    ) external nonReentrant {
+        AccountStorage.Layout storage asl = AccountStorage.layout();
+        uint32 accountId = asl.getValidAccount(accountAddr);
 
-        Utils.tokenTransfer(token, payable(msg.sender), amount, assetConfig.isTsbToken);
+        bytes32 structHash = _calcWithdrawStructHash(token, amount, asl.getPermitNonce(accountAddr), deadline);
+        asl.validatePermitAndIncreaseNonce(accountAddr, structHash, deadline, v, r, s);
+
+        _withdraw(msg.sender, accountAddr, accountId, token, amount);
     }
 
     /**
      * @inheritdoc IAccountFacet
      */
     function forceWithdraw(IERC20 token) external {
-        RollupStorage.Layout storage rsl = RollupStorage.layout();
-        rsl.requireActive();
+        EvacuationStorage.Layout storage esl = EvacuationStorage.layout();
+        esl.requireActive();
 
         AccountStorage.Layout storage asl = AccountStorage.layout();
         uint32 accountId = asl.getValidAccount(msg.sender);
 
         TokenStorage.Layout storage tsl = TokenStorage.layout();
         (uint16 tokenId, ) = tsl.getValidToken(token);
 
-        AccountLib.addForceWithdrawReq(rsl, msg.sender, accountId, token, tokenId);
+        AccountLib.addForceWithdrawReq(RollupStorage.layout(), msg.sender, accountId, token, tokenId);
+    }
+
+    /**
+     * @inheritdoc IAccountFacet
+     * @dev Refer to each action mask in the library for different delegated actions (path: ../libraries/Delegate.sol)
+     * @dev (i.e. use `DELEGATE_WITHDRAW_MASK` to delegate the withdraw action)
+     */
+    function setDelegatee(address delegatee, uint256 delegatedActions) external {
+        AccountStorage.Layout storage asl = AccountStorage.layout();
+        asl.delegatedActions[msg.sender][delegatee] = delegatedActions;
+        emit SetDelegatee(msg.sender, delegatee, delegatedActions);
     }
 
     /* ============ External View Functions ============ */
 
     /**
      * @inheritdoc IAccountFacet
      */
     function getAccountAddr(uint32 accountId) external view returns (address) {
         return AccountStorage.layout().getAccountAddr(accountId);
     }
 
     /**
      * @inheritdoc IAccountFacet
      */
     function getAccountId(address accountAddr) external view returns (uint32) {
         return AccountStorage.layout().getAccountId(accountAddr);
     }
 
     /**
      * @inheritdoc IAccountFacet
      */
     function getAccountNum() external view returns (uint32) {
         return AccountStorage.layout().getAccountNum();
     }
 
+    /**
+     * @inheritdoc IAccountFacet
+     */
+    function getPermitNonce(address accountAddr) external view returns (uint256) {
+        return AccountStorage.layout().getPermitNonce(accountAddr);
+    }
+
+    /**
+     * @inheritdoc IAccountFacet
+     * @dev Refer to each action mask in the library for different delegated actions (path: ../libraries/Delegate.sol)
+     * @dev (i.e. use `DELEGATE_WITHDRAW_MASK` to check if the withdraw action is delegated)
+     */
+    function getIsDelegated(address delegator, address delegatee, uint256 actionMask) external view returns (bool) {
+        return AccountStorage.layout().getIsDelegated(delegator, delegatee, actionMask);
+    }
+
+    /**
+     * @inheritdoc IAccountFacet
+     */
+    function getDelegatedActions(address delegator, address delegatee) external view returns (uint256) {
+        return AccountStorage.layout().getDelegatedActions(delegator, delegatee);
+    }
+
     /* ============ Internal Functions ============ */
 
     /// @notice Internal register function
     /// @param rsl The rollup storage layout
-    /// @param sender The address of sender
+    /// @param caller The address of caller
     /// @param tsPubKeyX The x coordinate of the public key of the token sender
     /// @param tsPubKeyY The y coordinate of the public key of the token sender
     /// @return accountId The registered L2 account Id
     function _register(
         RollupStorage.Layout storage rsl,
-        address sender,
+        address caller,
         uint256 tsPubKeyX,
         uint256 tsPubKeyY
     ) internal returns (uint32) {
         if (!BabyJubJub.isOnCurve(Point({x: tsPubKeyX, y: tsPubKeyY}))) revert InvalidTsPublicKey(tsPubKeyX, tsPubKeyY);
 
         AccountStorage.Layout storage asl = AccountStorage.layout();
         uint32 accountId = asl.getAccountNum();
         if (accountId >= Config.MAX_AMOUNT_OF_REGISTERED_ACCOUNT) revert AccountNumExceedLimit(accountId);
-        if (asl.getAccountId(msg.sender) != 0) revert AccountIsRegistered(msg.sender);
+        if (asl.getAccountId(caller) != 0) revert AccountIsRegistered(caller);
 
-        asl.accountIds[sender] = accountId;
-        asl.accountAddresses[accountId] = sender;
+        asl.accountIds[caller] = accountId;
+        asl.accountAddresses[accountId] = caller;
         asl.accountNum += 1;
-        AccountLib.addRegisterReq(rsl, sender, accountId, tsPubKeyX, tsPubKeyY);
+
+        AccountLib.addRegisterReq(rsl, caller, accountId, tsPubKeyX, tsPubKeyY);
+
         return accountId;
     }
 
     /// @notice Internal deposit function for register and deposit
     /// @param rsl The rollup storage layout
     /// @param tsl The token storage layout
-    /// @param depositor The address that deposit the L1 token
-    /// @param to The address credtied with the deposit
+    /// @param caller The address of caller
+    /// @param accountAddr The user account address in layer1
     /// @param accountId user account id in layer2
     /// @param token The token to be deposited
     /// @param amount The amount of the token
     function _deposit(
         RollupStorage.Layout storage rsl,
         TokenStorage.Layout storage tsl,
-        address depositor,
-        address to,
+        address caller,
+        address accountAddr,
         uint32 accountId,
         IERC20 token,
         uint128 amount
     ) internal {
         (uint16 tokenId, AssetConfig memory assetConfig) = tsl.getValidToken(token);
         TokenLib.validDepositAmt(amount, assetConfig.minDepositAmt);
 
-        Utils.tokenTransferFrom(token, depositor, amount, msg.value, assetConfig.isTsbToken);
-        AccountLib.addDepositReq(rsl, to, accountId, token, tokenId, assetConfig.decimals, amount);
+        Utils.tokenTransferFrom(token, caller, amount, msg.value, assetConfig.isTsbToken);
+        AccountLib.addDepositReq(rsl, caller, accountAddr, accountId, token, tokenId, assetConfig.decimals, amount);
+    }
+
+    /// @notice Internal withdraw function
+    /// @param caller The address of caller
+    /// @param accountAddr The user account address in layer1
+    /// @param accountId user account id in layer2
+    /// @param token The token to be withdrawn
+    /// @param amount The amount of the token
+    function _withdraw(
+        address caller,
+        address accountAddr,
+        uint32 accountId,
+        IERC20 token,
+        uint256 amount
+    ) internal virtual {
+        TokenStorage.Layout storage tsl = TokenStorage.layout();
+        (uint16 tokenId, AssetConfig memory assetConfig) = tsl.getValidToken(token);
+
+        RollupStorage.Layout storage rsl = RollupStorage.layout();
+        AccountLib.updateWithdrawalRecord(rsl, caller, accountAddr, accountId, token, tokenId, amount);
+
+        Utils.tokenTransfer(token, payable(accountAddr), amount, assetConfig.isTsbToken);
+    }
+
+    /* ============ Internal Pure Functions to Calculate Struct Hash ============ */
+
+    //! mainnet-audit
+    /// @notice Calculate the hash of the struct for the withdrawal permit
+    /// @param token The token to be withdrawn
+    /// @param amount The amount of the token to be withdrawn
+    /// @param nonce The nonce of the account
+    /// @param deadline The deadline of the permit
+    function _calcWithdrawStructHash(
+        IERC20 token,
+        uint256 amount,
+        uint256 nonce,
+        uint256 deadline
+    ) internal pure returns (bytes32) {
+        return keccak256(abi.encode(WITHDRAW_TYPEHASH, token, amount, nonce, deadline));
     }
 }
diff --git a/contracts/zkTrueUp/account/AccountLib.sol b/contracts/zkTrueUp/account/AccountLib.sol
index 90317c5..d090227 100644
--- a/contracts/zkTrueUp/account/AccountLib.sol
+++ b/contracts/zkTrueUp/account/AccountLib.sol
@@ -1,191 +1,290 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
 import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 import {AddressLib} from "../address/AddressLib.sol";
 import {RollupLib} from "../rollup/RollupLib.sol";
 import {AccountStorage} from "./AccountStorage.sol";
 import {AddressStorage} from "../address/AddressStorage.sol";
 import {RollupStorage} from "../rollup/RollupStorage.sol";
 import {Operations} from "../libraries/Operations.sol";
 import {Utils} from "../libraries/Utils.sol";
+import {Signature} from "../libraries/Signature.sol";
+import {Delegate} from "../libraries/Delegate.sol";
 
 /**
  * @title Term Structure Account Library
  * @author Term Structure Labs
  */
 library AccountLib {
     using AccountLib for AccountStorage.Layout;
     using AddressLib for AddressStorage.Layout;
     using RollupLib for RollupStorage.Layout;
     using Utils for *;
 
     /// @notice Error for get account which is not registered
     error AccountIsNotRegistered(address accountAddr);
+    /// @notice Error for invalid caller
+    error InvalidCaller(address caller, address accountAddr);
 
     /// @notice Emit when there is a new account registered
     /// @param accountAddr The user account address in layer1
     /// @param accountId The user account id in the L2 system
     /// @param tsPubX The x coordinate of the public key of the account
     /// @param tsPubY The y coordinate of the public key of the account
     /// @param tsAddr The address of the account in the L2 system
     event Registration(
         address indexed accountAddr,
         uint32 indexed accountId,
         uint256 tsPubX,
         uint256 tsPubY,
         bytes20 tsAddr
     );
 
     /// @notice Emit when there is a new deposit
+    /// @param caller The address of the caller
     /// @param accountAddr The user account address in layer1
     /// @param accountId The user account id in the L2 system
     /// @param token The deposited token
     /// @param tokenId The token id of the deposit token
     /// @param amount The deposit amount
-    event Deposit(address indexed accountAddr, uint32 indexed accountId, IERC20 token, uint16 tokenId, uint128 amount);
+    event Deposit(
+        address indexed caller,
+        address indexed accountAddr,
+        uint32 indexed accountId,
+        IERC20 token,
+        uint16 tokenId,
+        uint128 amount
+    );
 
     /// @notice Emit when there is a new force withdraw
     /// @param accountAddr The user account address in layer1
     /// @param accountId The user account id in the L2 system
     /// @param token The force withdraw token
     /// @param tokenId Layer2 id of force withdraw token
     event ForceWithdrawal(address indexed accountAddr, uint32 indexed accountId, IERC20 token, uint16 tokenId);
 
     /// @notice Emit when there is a new withdraw
+    /// @param caller The address of the caller
     /// @param accountAddr The user account address in layer1
     /// @param accountId The user account id in the L2 system
     /// @param token The withdraw token
     /// @param tokenId Layer2 id of withdraw token
     /// @param amount The withdraw amount
     event Withdrawal(
+        address indexed caller,
         address indexed accountAddr,
         uint32 indexed accountId,
         IERC20 token,
         uint16 tokenId,
         uint256 amount
     );
 
     /// @notice Internal function to add register request
     /// @param rsl The rollup storage layout
-    /// @param sender The address of the account on Layer1
+    /// @param accountAddr The address of the account in Layer1
     /// @param accountId The user account id in Layer2
     /// @param tsPubKeyX The x coordinate of the public key of the account
     /// @param tsPubKeyY The y coordinate of the public key of the account
     function addRegisterReq(
         RollupStorage.Layout storage rsl,
-        address sender,
+        address accountAddr,
         uint32 accountId,
         uint256 tsPubKeyX,
         uint256 tsPubKeyY
     ) internal {
         AddressStorage.Layout storage asl = AddressStorage.layout();
         bytes20 tsAddr = bytes20(uint160(asl.getPoseidonUnit2().poseidon([tsPubKeyX, tsPubKeyY])));
         Operations.Register memory op = Operations.Register({accountId: accountId, tsAddr: tsAddr});
         bytes memory pubData = Operations.encodeRegisterPubData(op);
-        rsl.addL1Request(sender, Operations.OpType.REGISTER, pubData);
-        emit Registration(sender, accountId, tsPubKeyX, tsPubKeyY, tsAddr);
+        rsl.addL1Request(accountAddr, Operations.OpType.REGISTER, pubData);
+        emit Registration(accountAddr, accountId, tsPubKeyX, tsPubKeyY, tsAddr);
     }
 
     /// @notice Internal function to add deposit request
     /// @param rsl The rollup storage layout
-    /// @param to The address of the account on Layer1
+    /// @param caller The address of the caller
+    /// @param accountAddr The address of the account in Layer1
     /// @param accountId The user account id in Layer2
     /// @param token The token to be deposited
     /// @param tokenId The token id of the deposit token
     /// @param decimals The decimals of the deposit token
     /// @param amount The deposit amount
     function addDepositReq(
         RollupStorage.Layout storage rsl,
-        address to,
+        address caller,
+        address accountAddr,
         uint32 accountId,
         IERC20 token,
         uint16 tokenId,
         uint8 decimals,
         uint128 amount
     ) internal {
         uint128 l2Amt = amount.toL2Amt(decimals);
         Operations.Deposit memory op = Operations.Deposit({accountId: accountId, tokenId: tokenId, amount: l2Amt});
         bytes memory pubData = Operations.encodeDepositPubData(op);
-        rsl.addL1Request(to, Operations.OpType.DEPOSIT, pubData);
-        emit Deposit(to, accountId, token, tokenId, amount);
+        rsl.addL1Request(accountAddr, Operations.OpType.DEPOSIT, pubData);
+        emit Deposit(caller, accountAddr, accountId, token, tokenId, amount);
     }
 
     /// @notice Internal function to add force withdraw request
     /// @param rsl The rollup storage layout
-    /// @param sender The address of the account on Layer1
+    /// @param accountAddr The address of the account in Layer1
     /// @param accountId The user account id in Layer2
     /// @param token The token to be withdrawn
     /// @param tokenId The token id of the force withdraw token
     function addForceWithdrawReq(
         RollupStorage.Layout storage rsl,
-        address sender,
+        address accountAddr,
         uint32 accountId,
         IERC20 token,
         uint16 tokenId
     ) internal {
         Operations.ForceWithdraw memory op = Operations.ForceWithdraw({
             accountId: accountId,
             tokenId: tokenId,
             // user will not specify the amount
             // since forceWithdraw will refund all the available balance of the account
             amount: uint128(0)
         });
         bytes memory pubData = Operations.encodeForceWithdrawPubData(op);
-        rsl.addL1Request(sender, Operations.OpType.FORCE_WITHDRAW, pubData);
-        emit ForceWithdrawal(sender, accountId, token, tokenId);
+        rsl.addL1Request(accountAddr, Operations.OpType.FORCE_WITHDRAW, pubData);
+        emit ForceWithdrawal(accountAddr, accountId, token, tokenId);
     }
 
     /// @notice Internal function to update withdraw record
     /// @param rsl The rollup storage layout
-    /// @param addr The address of the account on Layer1
+    /// @param caller The address of the caller
+    /// @param accountAddr The address of the account in Layer1
     /// @param accountId The user account id in Layer2
     /// @param token The token to be withdrawn
     /// @param tokenId The token id of the withdraw token
     /// @param amount The withdraw amount
     function updateWithdrawalRecord(
         RollupStorage.Layout storage rsl,
-        address addr,
+        address caller,
+        address accountAddr,
         uint32 accountId,
         IERC20 token,
         uint16 tokenId,
         uint256 amount
     ) internal {
-        rsl.removePendingBalance(addr, tokenId, amount);
-        emit Withdrawal(addr, accountId, token, tokenId, amount);
+        rsl.removePendingBalance(accountAddr, tokenId, amount);
+        emit Withdrawal(caller, accountAddr, accountId, token, tokenId, amount);
+    }
+
+    /// @notice Internal function to validate permit signature and increase nonce
+    /// @param s The account storage layout
+    /// @param expectedSigner The expected signer of the permit signature
+    /// @param structHash The hash of the struct
+    /// @param deadline The deadline of the signature
+    /// @param permitV The v of the permit signature
+    /// @param permitR The r of the permit signature
+    /// @param permitS The s of the permit signature
+    function validatePermitAndIncreaseNonce(
+        AccountStorage.Layout storage s,
+        address expectedSigner,
+        bytes32 structHash,
+        uint256 deadline,
+        uint8 permitV,
+        bytes32 permitR,
+        bytes32 permitS
+    ) internal {
+        Signature.verifyDeadline(deadline);
+        Signature.verifySignature(expectedSigner, structHash, permitV, permitR, permitS);
+
+        s.increaseNonce(expectedSigner);
+    }
+
+    /// @notice Internal function to increase the nonce of the address
+    /// @param s The account storage layout
+    /// @param addr The address to be increased nonce
+    function increaseNonce(AccountStorage.Layout storage s, address addr) internal {
+        s.nonces[addr]++;
     }
 
     /// @notice Internal function to get the valid account id
     /// @dev Valid account is the account that is registered on Layer2
     /// @param s The account storage layout
     /// @param l1AccountAddr The address of the account on Layer1
     /// @return accountId The user account id in Layer2
     function getValidAccount(AccountStorage.Layout storage s, address l1AccountAddr) internal view returns (uint32) {
         uint32 accountId = s.getAccountId(l1AccountAddr);
         if (accountId == 0) revert AccountIsNotRegistered(l1AccountAddr);
         return accountId;
     }
 
     /// @notice Internal function to get the address by account id
     /// @param s The account storage layout
     /// @param accountId user account id in layer2
     /// @return accountAddr user account address in layer1
     function getAccountAddr(AccountStorage.Layout storage s, uint32 accountId) internal view returns (address) {
         return s.accountAddresses[accountId];
     }
 
     /// @notice Internal function to get the account id by address
     /// @param s The account storage layout
     /// @param accountAddr user account address in layer1
     /// @return accountId user account id in layer2
     function getAccountId(AccountStorage.Layout storage s, address accountAddr) internal view returns (uint32) {
         return s.accountIds[accountAddr];
     }
 
     /// @notice Internal function to get the total number of accounts
     /// @param s The account storage layout
     /// @return accountNum The total number of accounts
     function getAccountNum(AccountStorage.Layout storage s) internal view returns (uint32) {
         return s.accountNum;
     }
+
+    /// @notice Internal function to get the permit nonce of the address
+    /// @param s The account storage layout
+    /// @param addr The address to get permit nonce
+    function getPermitNonce(AccountStorage.Layout storage s, address addr) internal view returns (uint256) {
+        return s.nonces[addr];
+    }
+
+    /// @notice Internal function to get the isDelegated status of the account
+    /// @param s The account storage layout
+    /// @param delegator The address of the delegator
+    /// @param delegatee The address of the delegatee
+    /// @param actionMask The mask of the action to check
+    /// @return isDelegated The isDelegated status of the account
+    function getIsDelegated(
+        AccountStorage.Layout storage s,
+        address delegator,
+        address delegatee,
+        uint256 actionMask
+    ) internal view returns (bool) {
+        return Delegate.isDelegated(s.delegatedActions[delegator][delegatee], actionMask);
+    }
+
+    /// @notice Internal function to get the delegated actions of the account
+    /// @param s The account storage layout
+    /// @param delegator The address of the delegator
+    /// @param delegatee The address of the delegatee
+    /// @return delegatedActions The delegated actions of the account
+    function getDelegatedActions(
+        AccountStorage.Layout storage s,
+        address delegator,
+        address delegatee
+    ) internal view returns (uint256) {
+        return s.delegatedActions[delegator][delegatee];
+    }
+
+    /// @notice Internal function to check if the caller is the account address the delegated caller
+    /// @param s The account storage layout
+    /// @param caller The caller to be checked
+    /// @param accountAddr The account address
+    /// @param actionMask The mask of the action to check
+    function requireValidCaller(
+        AccountStorage.Layout storage s,
+        address caller,
+        address accountAddr,
+        uint256 actionMask
+    ) internal view {
+        if (caller == accountAddr) return;
+        if (s.getIsDelegated(accountAddr, caller, actionMask)) return;
+        revert InvalidCaller(caller, accountAddr);
+    }
 }
diff --git a/contracts/zkTrueUp/account/AccountStorage.sol b/contracts/zkTrueUp/account/AccountStorage.sol
index 727a13e..c6cf85b 100644
--- a/contracts/zkTrueUp/account/AccountStorage.sol
+++ b/contracts/zkTrueUp/account/AccountStorage.sol
@@ -1,28 +1,39 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
+/* ============ The type hash of sign typed data v4 for permit functions ============ */
+
+// withdraw function type hash
+bytes32 constant WITHDRAW_TYPEHASH = keccak256("Withdraw(address token,uint256 amount,uint256 nonce,uint256 deadline)");
+
 /**
  * @title Term Structure Account Storage
  * @author Term Structure Labs
  */
 library AccountStorage {
     bytes32 internal constant STORAGE_SLOT = bytes32(uint256(keccak256("zkTrueUp.contracts.storage.Account")) - 1);
 
     struct Layout {
         /// @notice Total number of registered accounts
         uint32 accountNum;
         /// @notice Mapping of L1 Address => L2 Account Id
         mapping(address => uint32) accountIds;
         /// @notice Mapping of L2 Account Id => L1 Address
         mapping(uint32 => address) accountAddresses;
+        /// @notice LoanOwner => delegatee => isDelegated
+        /// @dev User can delegate the right to operate the account to another address
+        /// @dev Each delegated action has a unique bit in the delegatedActions mask
+        mapping(address => mapping(address => uint256)) delegatedActions;
+        /// @notice Mapping address to nonces for permit functions
+        mapping(address => uint256) nonces;
     }
 
     function layout() internal pure returns (Layout storage s) {
         bytes32 slot = STORAGE_SLOT;
 
         // solhint-disable-next-line no-inline-assembly
         assembly {
             s.slot := slot
         }
     }
 }
diff --git a/contracts/zkTrueUp/account/IAccountFacet.sol b/contracts/zkTrueUp/account/IAccountFacet.sol
index 5a14404..3acd678 100644
--- a/contracts/zkTrueUp/account/IAccountFacet.sol
+++ b/contracts/zkTrueUp/account/IAccountFacet.sol
@@ -1,55 +1,105 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
 import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 
 /**
  * @title Term Structure Account Facet Interface
  * @author Term Structure Labs
  */
 interface IAccountFacet {
     /// @notice Error for register account which is already registered
     error AccountIsRegistered(address sender);
     /// @notice Error for register account when exceed account number limit
     error AccountNumExceedLimit(uint32 registeredAccountId);
     /// @notice Error for register account when the public key is invalid
     error InvalidTsPublicKey(uint256 tsPubKeyX, uint256 tsPubKeyY);
 
+    /// @notice Emit when the delegatee is set
+    event SetDelegatee(address indexed delegator, address indexed delegatee, uint256 delegatedActions);
+
     /// @notice Register account by deposit Ether or ERC20 to ZkTrueUp
     /// @param tsPubKeyX The X coordinate of the public key of the L2 account
     /// @param tsPubKeyY The Y coordinate of the public key of the L2 account
     /// @param token The token to be deposited
     /// @param amount The amount of the token to be deposited
     function register(uint256 tsPubKeyX, uint256 tsPubKeyY, IERC20 token, uint128 amount) external payable;
 
     /// @notice Deposit Ether or ERC20 to ZkTrueUp
     /// @param to The address of the L2 account to be deposited
     /// @param token The token to be deposited
     /// @param amount The amount of the token to be deposited
     function deposit(address to, IERC20 token, uint128 amount) external payable;
 
     /// @notice Withdraw Ether or ERC20 from ZkTrueUp
+    /// @param accountAddr The address of the L2 account to be withdrawn
+    /// @param token The token to be withdrawn
+    /// @param amount The amount of the token to be withdrawn
+    function withdraw(address accountAddr, IERC20 token, uint256 amount) external;
+
+    /// @notice Withdraw Ether or ERC20 from ZkTrueUp with permit
+    /// @param accountAddr The address of the L2 account to be withdrawn
     /// @param token The token to be withdrawn
     /// @param amount The amount of the token to be withdrawn
-    function withdraw(IERC20 token, uint256 amount) external;
+    /// @param deadline The deadline of the permit
+    /// @param v v The recovery id of the signature
+    /// @param r The r of the permit signature
+    /// @param s The s of the permit signature
+    function withdrawWithPermit(
+        address accountAddr,
+        IERC20 token,
+        uint256 amount,
+        uint256 deadline,
+        uint8 v,
+        bytes32 r,
+        bytes32 s
+    ) external;
 
     /// @notice Force withdraw Ether or ERC20 from ZkTrueUp
     /// @notice When the L2 system is down or user's asset is censored, user can do forceWithdraw to withdraw asset from ZkTrueUp
     /// @notice If the forceWithdraw request is not processed before the expirationBlock, user can do activateEvacuation to activate the evacuation
     /// @param token The token to be withdrawn
     function forceWithdraw(IERC20 token) external;
 
+    /// @notice Set the delegatee of the account
+    /// @dev Refer to each action mask in the library for different delegated actions (path: ../libraries/Delegate.sol)
+    /// @dev (i.e. use `DELEGATE_WITHDRAW_MASK` to delegate the withdraw action)
+    /// @param delegatee The address of the delegatee
+    /// @param delegatedActions The delegated actions, each action has a unique bit in the delegatedActions
+    function setDelegatee(address delegatee, uint256 delegatedActions) external;
+
     /// @notice Get the account L1 address by account L2 id
     /// @param accountId The account L2 id
     /// @return accountAddr The account L1 address
     function getAccountAddr(uint32 accountId) external view returns (address accountAddr);
 
     /// @notice Get the account id by account L1 address
     /// @param accountAddr The account L1 address
     /// @return accountId The account L2 id
     function getAccountId(address accountAddr) external view returns (uint32 accountId);
 
     /// @notice Get the number of registered accounts
     /// @return accountNum The number of registered accounts
     function getAccountNum() external view returns (uint32 accountNum);
+
+    /// @notice Return the permit nonce of the account
+    /// @dev The nonce is used to prevent signature replay attack
+    /// @param accountAddr The address of the account
+    /// @return nonce The permit nonce of the account
+    function getPermitNonce(address accountAddr) external view returns (uint256);
+
+    /// @notice Return the isDelegated status of the account
+    /// @dev Refer to each action mask in the library for different delegated actions (path: ../libraries/Delegate.sol)
+    /// @dev (i.e. use `DELEGATE_WITHDRAW_MASK` to check if the withdraw action is delegated)
+    /// @param delegator The address of the delegator
+    /// @param delegatee The address of the delegatee
+    /// @param actionMask The mask of the action to check
+    /// @return isDelegated The isDelegated status of the account
+    function getIsDelegated(address delegator, address delegatee, uint256 actionMask) external view returns (bool);
+
+    /// @notice Return the delegated actions of the account
+    /// @param delegator The address of the delegator
+    /// @param delegatee The address of the delegatee
+    /// @return delegatedActions The delegated actions of the account
+    function getDelegatedActions(address delegator, address delegatee) external view returns (uint256);
 }
diff --git a/contracts/zkTrueUp/evacuation/EvacuationFacet.sol b/contracts/zkTrueUp/evacuation/EvacuationFacet.sol
new file mode 100644
index 0000000..6f87958
--- /dev/null
+++ b/contracts/zkTrueUp/evacuation/EvacuationFacet.sol
@@ -0,0 +1,257 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.17;
+
+import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
+import {ReentrancyGuard} from "@solidstate/contracts/security/reentrancy_guard/ReentrancyGuard.sol";
+import {IEvacuationFacet} from "./IEvacuationFacet.sol";
+import {AccountStorage} from "../account/AccountStorage.sol";
+import {EvacuationStorage} from "./EvacuationStorage.sol";
+import {AddressStorage} from "../address/AddressStorage.sol";
+import {TokenStorage, AssetConfig} from "../token/TokenStorage.sol";
+import {RollupStorage, StoredBlock, CommitBlock, Proof, Request} from "../rollup/RollupStorage.sol";
+import {RollupLib} from "../rollup/RollupLib.sol";
+import {AccountLib} from "../account/AccountLib.sol";
+import {EvacuationLib} from "./EvacuationLib.sol";
+import {AddressLib} from "../address/AddressLib.sol";
+import {TokenLib} from "../token/TokenLib.sol";
+import {Operations} from "../libraries/Operations.sol";
+import {Config} from "../libraries/Config.sol";
+import {Utils} from "../libraries/Utils.sol";
+
+/**
+ * @title Term Structure Evacuation Facet Contract
+ * @author Term Structure Labs
+ * @notice The EvacuationFacet contract is used to handle the evacuation-related functions
+ */
+contract EvacuationFacet is IEvacuationFacet, ReentrancyGuard {
+    using EvacuationLib for EvacuationStorage.Layout;
+    using AddressLib for AddressStorage.Layout;
+    using AccountLib for AccountStorage.Layout;
+    using TokenLib for TokenStorage.Layout;
+    using Operations for bytes;
+    using RollupLib for *;
+    using Utils for *;
+
+    /* ============ External Functions ============ */
+
+    /**
+     * @inheritdoc IEvacuationFacet
+     * @notice The evacuation mode will be activated when the current block timestamp
+     *      is greater than the expiration block timestamp of the last executed L1 request
+     * @notice When the evacuation mode is activated, the block state will be rolled back to the last executed block
+     *      and the request state will be rolled back to the last executed request
+     * @notice The remaining non-executed L1 requests will be consumed by the consumeL1RequestInEvacuMode function
+     *      with their public data, after consume all non-executed request, user can start to evacuate their funds
+     */
+    function activateEvacuation() external {
+        EvacuationStorage.Layout storage esl = EvacuationStorage.layout();
+        esl.requireActive();
+
+        RollupStorage.Layout storage rsl = RollupStorage.layout();
+        uint64 executedL1RequestNum = rsl.getExecutedL1RequestNum();
+        uint64 lastExecutedL1RequestId = executedL1RequestNum - 1;
+        uint32 expirationTime = rsl.getL1Request(lastExecutedL1RequestId).expirationTime;
+        // solhint-disable-next-line not-rely-on-time
+        if (block.timestamp > expirationTime && expirationTime != 0) {
+            // Roll back state
+            uint32 executedBlockNum = rsl.getExecutedBlockNum();
+            rsl.committedBlockNum = executedBlockNum;
+            rsl.verifiedBlockNum = executedBlockNum;
+            rsl.committedL1RequestNum = executedL1RequestNum;
+
+            esl.evacuMode = true;
+            emit EvacuModeActivation();
+        } else {
+            // solhint-disable-next-line not-rely-on-time
+            revert TimeStampIsNotExpired(block.timestamp, expirationTime);
+        }
+    }
+
+    /**
+     * @inheritdoc IEvacuationFacet
+     * @notice The function only can be called in evacuation mode
+     * @notice Consume the non-executed L1 requests with their public data
+     */
+    function consumeL1RequestInEvacuMode(bytes[] calldata consumedTxPubData) external {
+        EvacuationStorage.Layout storage esl = EvacuationStorage.layout();
+        esl.requireEvacuMode();
+
+        RollupStorage.Layout storage rsl = RollupStorage.layout();
+        uint64 totalL1RequestNum = rsl.getTotalL1RequestNum();
+        uint64 lastL1RequestId = totalL1RequestNum - 1;
+        // The last L1 request cannot be evacuation
+        // because the evacuate action can only be called after consumed all L1 non-executed request
+        if (rsl.getL1Request(lastL1RequestId).opType == Operations.OpType.EVACUATION)
+            revert LastL1RequestIsEvacuation(totalL1RequestNum);
+
+        uint64 executedL1RequestNum = rsl.getExecutedL1RequestNum();
+        if (executedL1RequestNum + consumedTxPubData.length > totalL1RequestNum)
+            revert ConsumedRequestNumExceedTotalNum(consumedTxPubData.length);
+
+        bytes memory pubData;
+        for (uint32 i; i < consumedTxPubData.length; ++i) {
+            pubData = consumedTxPubData[i];
+            Request memory request = rsl.getL1Request(executedL1RequestNum);
+            bytes32 hashedPubData = keccak256(pubData);
+            if (request.hashedPubData != hashedPubData) revert InvalidConsumedPubData(executedL1RequestNum, pubData);
+
+            Operations.OpType opType = Operations.OpType(uint8(pubData[0]));
+            if (opType > type(Operations.OpType).max) revert InvalidOpType(opType);
+
+            if (opType == Operations.OpType.DEPOSIT) {
+                // refund the deposit amount to the pending balance for withdraw
+                Operations.Deposit memory depositReq = pubData.readDepositPubData();
+                rsl.addPendingBalance(depositReq.accountId, depositReq.tokenId, depositReq.amount);
+            } else if (opType == Operations.OpType.REGISTER) {
+                // de-register only remove the accountAddr mapping to accountId,
+                // which use to check in AccountLib.getValidAccount and let user can register again
+                // and still can add pending balance to this register account
+                // when consume the deposit request in the next request
+                Operations.Register memory registerReq = pubData.readRegisterPubData();
+                AccountStorage.Layout storage asl = AccountStorage.layout();
+                address registerAddr = asl.accountAddresses[registerReq.accountId];
+                delete asl.accountIds[registerAddr];
+                emit AccountDeregistered(registerAddr, registerReq.accountId);
+            }
+
+            ++executedL1RequestNum;
+            emit L1RequestConsumed(executedL1RequestNum, opType, pubData);
+        }
+        rsl.committedL1RequestNum = executedL1RequestNum;
+        rsl.executedL1RequestNum = executedL1RequestNum;
+    }
+
+    /**
+     * @inheritdoc IEvacuationFacet
+     * @notice The function only can be called in evacuation mode and after consume all non-executed L1 requests
+     * @notice The newBlock is a pseudo block, it only for create the block commitment and not commit to the state
+     * @notice The evacuate fuction will not commit a new state root to make all the users evacuate their funds from the same state
+     */
+    function evacuate(
+        StoredBlock calldata lastExecutedBlock,
+        CommitBlock calldata newBlock,
+        Proof calldata proof
+    ) external nonReentrant {
+        EvacuationStorage.Layout storage esl = EvacuationStorage.layout();
+        esl.requireEvacuMode();
+
+        RollupStorage.Layout storage rsl = RollupStorage.layout();
+        rsl.requireConsumedAllNonExecutedReq();
+
+        rsl.requireBlockHashIsEq(rsl.getExecutedBlockNum(), lastExecutedBlock);
+        newBlock.blockNumber.requireValidBlockNum(lastExecutedBlock.blockNumber);
+        newBlock.timestamp.requireValidBlockTimestamp(lastExecutedBlock.timestamp);
+
+        bytes calldata publicData = newBlock.publicData;
+        // evacuation public data length is 2 chunks
+        if (publicData.length != Config.BYTES_OF_TWO_CHUNKS) revert InvalidEvacuatePubDataLength(publicData.length);
+
+        bytes32 commitment = RollupLib.calcBlockCommitment(
+            lastExecutedBlock,
+            newBlock,
+            Config.EVACUATION_COMMITMENT_OFFSET
+        );
+
+        RollupLib.verifyOneBlock(commitment, proof, AddressStorage.layout().getEvacuVerifier());
+
+        Operations.Evacuation memory evacuation = Operations.readEvacuationPubdata(publicData);
+        _evacuate(esl, rsl, evacuation);
+    }
+
+    /**
+     * @inheritdoc IEvacuationFacet
+     * @notice The function is to refund the pending balance for the account which is deregistered in `consumeL1RequestInEvacuMode`
+     * @notice The function is only refund for the deregistered account, the normal account should use the `withdraw` function to withdraw their funds
+     * @notice De-register only remove the accountAddr mapping to accountId, and keep the accountId mapping to accountAddr for refund
+               so if the `asl.getAccountId(asl.getAccountAddr(accountId)) == accountId` means the account is not the deregistered account
+     */
+    function refundDeregisteredAddr(IERC20 token, uint256 amount, uint32 accountId) external nonReentrant {
+        AccountStorage.Layout storage asl = AccountStorage.layout();
+        address accountAddr = asl.getAccountAddr(accountId);
+        // check the account is deregistered (accountAddr mapping to accountId is deleted)
+        if (asl.getAccountId(accountAddr) == accountId) revert NotDeregisteredAddr(accountAddr, accountId);
+        if (accountAddr != msg.sender) revert AccountAddrIsNotCaller(accountAddr, msg.sender);
+
+        TokenStorage.Layout storage tsl = TokenStorage.layout();
+        (uint16 tokenId, AssetConfig memory assetConfig) = tsl.getValidToken(token);
+
+        RollupStorage.Layout storage rsl = RollupStorage.layout();
+        AccountLib.updateWithdrawalRecord(rsl, msg.sender, accountAddr, accountId, token, tokenId, amount);
+
+        Utils.tokenTransfer(token, payable(accountAddr), amount, assetConfig.isTsbToken);
+    }
+
+    /* ============ External View Functions ============ */
+
+    /**
+     * @inheritdoc IEvacuationFacet
+     */
+    function isEvacuMode() external view returns (bool) {
+        return EvacuationStorage.layout().isEvacuMode();
+    }
+
+    /**
+     * @inheritdoc IEvacuationFacet
+     */
+    function isEvacuted(address addr, uint16 tokenId) external view returns (bool) {
+        uint32 accountId = AccountStorage.layout().getAccountId(addr);
+        return EvacuationStorage.layout().isEvacuated(accountId, tokenId);
+    }
+
+    /* ============ Internal Functions ============ */
+
+    /// @notice Internal function to check whether the chunk id delta is valid when commit evacuation block
+    /// @dev The evacuation block only includes the evacuation request or noop,
+    ///      so the first chunk id delta should be 0 and the remaining chunk id delta should be evacuation chunk size
+    /// @param chunkIdDeltas The chunk id delta array
+    function _requireValidEvacuBlockChunkIdDelta(uint16[] calldata chunkIdDeltas) internal pure {
+        uint256 chunkIdDeltaLength = chunkIdDeltas.length;
+
+        // If there are chunk ID deltas and the first one is not 0, revert
+        if (chunkIdDeltaLength != 0 && chunkIdDeltas[0] != 0) revert InvalidChunkIdDelta(chunkIdDeltas);
+
+        // check every chunk id delta (not include the first one) ) is equal to evacuation chunk size
+        uint256 andDeltas = Config.EVACUATION_CHUNK_SIZE;
+        uint256 orDeltas = Config.EVACUATION_CHUNK_SIZE;
+        for (uint256 i = 1; i < chunkIdDeltaLength; ++i) {
+            uint16 chunkIdDelta = chunkIdDeltas[i];
+            andDeltas &= chunkIdDelta;
+            orDeltas |= chunkIdDelta;
+        }
+
+        // If there is inconsistency in delta values, revert
+        // This will occur if at least one chunk ID delta is not equal to the size of an evacuation chunk
+        if (andDeltas != orDeltas) revert InvalidChunkIdDelta(chunkIdDeltas);
+    }
+
+    /// @notice Internal function to evacuate token to L1
+    /// @param esl The evacuation storage layout
+    /// @param rsl The rollup storage layout
+    /// @param evacuation The evacuation request
+    function _evacuate(
+        EvacuationStorage.Layout storage esl,
+        RollupStorage.Layout storage rsl,
+        Operations.Evacuation memory evacuation
+    ) internal {
+        uint32 accountId = evacuation.accountId;
+        uint16 tokenId = evacuation.tokenId;
+        if (esl.isEvacuated(accountId, tokenId)) revert Evacuated(accountId, tokenId);
+
+        address receiver = AccountStorage.layout().getAccountAddr(accountId);
+        Utils.notZeroAddr(receiver);
+
+        AssetConfig memory assetConfig = TokenStorage.layout().getAssetConfig(tokenId);
+        IERC20 token = assetConfig.token;
+        Utils.notZeroAddr(address(token));
+
+        esl.evacuated[accountId][tokenId] = true;
+
+        bytes memory pubData = Operations.encodeEvacuationPubData(evacuation);
+        rsl.addL1Request(receiver, Operations.OpType.EVACUATION, pubData);
+
+        uint256 l1Amt = evacuation.amount.toL1Amt(assetConfig.decimals);
+        Utils.tokenTransfer(token, payable(receiver), l1Amt, assetConfig.isTsbToken);
+
+        emit Evacuation(receiver, accountId, token, tokenId, l1Amt);
+    }
+}
diff --git a/contracts/zkTrueUp/evacuation/EvacuationLib.sol b/contracts/zkTrueUp/evacuation/EvacuationLib.sol
new file mode 100644
index 0000000..367cfc3
--- /dev/null
+++ b/contracts/zkTrueUp/evacuation/EvacuationLib.sol
@@ -0,0 +1,49 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.17;
+
+import {EvacuationStorage} from "./EvacuationStorage.sol";
+
+/**
+ * @title Term Structure Evacuation Library
+ * @author Term Structure Labs
+ */
+library EvacuationLib {
+    using EvacuationLib for EvacuationStorage.Layout;
+
+    /// @notice Error for trying to do transactions when evacuation mode is activated
+    error EvacuModeActivated();
+    /// @notice Error for the system is not in evacuation mode
+    error NotEvacuMode();
+
+    /// @notice Internal function to check if the contract is not in the evacuMode
+    /// @param s The evacuation storage
+    function requireActive(EvacuationStorage.Layout storage s) internal view {
+        if (s.isEvacuMode()) revert EvacuModeActivated();
+    }
+
+    /// @notice Internal function to check if the contract is in the evacuMode
+    /// @param s The evacuation storage
+    function requireEvacuMode(EvacuationStorage.Layout storage s) internal view {
+        if (!s.isEvacuMode()) revert NotEvacuMode();
+    }
+
+    /// @notice Internal function to get evacuation mode status
+    /// @param s The evacuation storage
+    /// @return evacuMode The evacuation mode status
+    function isEvacuMode(EvacuationStorage.Layout storage s) internal view returns (bool) {
+        return s.evacuMode;
+    }
+
+    /// @notice Internal function to get whether the specified accountId and tokenId is evacuated
+    /// @param s The evacuation storage
+    /// @param accountId The account id
+    /// @param tokenId The token id
+    /// @return isEvacuated Whether the specified accountId and tokenId is evacuated
+    function isEvacuated(
+        EvacuationStorage.Layout storage s,
+        uint32 accountId,
+        uint16 tokenId
+    ) internal view returns (bool) {
+        return s.evacuated[accountId][tokenId];
+    }
+}
diff --git a/contracts/zkTrueUp/evacuation/EvacuationStorage.sol b/contracts/zkTrueUp/evacuation/EvacuationStorage.sol
new file mode 100644
index 0000000..f75317a
--- /dev/null
+++ b/contracts/zkTrueUp/evacuation/EvacuationStorage.sol
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.17;
+
+/**
+ * @title Term Structure Evacuation Storage
+ * @author Term Structure Labs
+ */
+library EvacuationStorage {
+    bytes32 internal constant STORAGE_SLOT = bytes32(uint256(keccak256("zkTrueUp.contracts.storage.Evacuation")) - 1);
+
+    struct Layout {
+        /// @notice Mode of evacuation (true: evacuation mode, false: normal mode)
+        bool evacuMode;
+        /// @notice Mapping of L2 Account Id => L2 Token Id => isEvacuated
+        mapping(uint32 => mapping(uint16 => bool)) evacuated;
+    }
+
+    function layout() internal pure returns (Layout storage s) {
+        bytes32 slot = STORAGE_SLOT;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            s.slot := slot
+        }
+    }
+}
diff --git a/contracts/zkTrueUp/evacuation/IEvacuationFacet.sol b/contracts/zkTrueUp/evacuation/IEvacuationFacet.sol
new file mode 100644
index 0000000..e1be643
--- /dev/null
+++ b/contracts/zkTrueUp/evacuation/IEvacuationFacet.sol
@@ -0,0 +1,98 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.17;
+
+import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
+import {Operations} from "../libraries/Operations.sol";
+import {StoredBlock, CommitBlock, Proof} from "../rollup/RollupStorage.sol";
+
+/**
+ * @title Term Structure Evacuation Facet Interface
+ * @author Term Structure Labs
+ */
+interface IEvacuationFacet {
+    /// @notice Error for activate evacuation mode, but the timestamp is not expired
+    error TimeStampIsNotExpired(uint256 curTimestamp, uint256 expirationTime);
+    /// @notice Error for consume L1 request but the request is evacuation (already consumed all L1 requests)
+    error LastL1RequestIsEvacuation(uint64 totalL1RequestNum);
+    /// @notice Error for consumed request number exceed total request number
+    error ConsumedRequestNumExceedTotalNum(uint256 consumedRequestNum);
+    /// @notice Error for invalid consumed public data mismatch the data in the request queue
+    error InvalidConsumedPubData(uint64 l1RequestNum, bytes pubData);
+    /// @notice Error for invalid op type
+    error InvalidOpType(Operations.OpType opType);
+    /// @notice Error for invalid evacuate public data length
+    error InvalidEvacuatePubDataLength(uint256 pubDataLength);
+    /// @notice Error for refund deregistered address but the account is not deregistered
+    error NotDeregisteredAddr(address accountAddr, uint32 accountId);
+    /// @notice Error for account address is not the msg.sender
+    error AccountAddrIsNotCaller(address accountAddr, address sender);
+    /// @notice Error for invalid chunk id delta when commit evacublock in evacuation mode
+    error InvalidChunkIdDelta(uint16[] chunkIdDeltas);
+    /// @notice Error for the specified accountId and tokenId is already evacuated
+    error Evacuated(uint32 accountId, uint16 tokenId);
+
+    /// @notice Emit when there is an evacuation
+    /// @param accountAddr The address of the account
+    /// @param accountId The id of the account
+    /// @param token The token to be evacuated
+    /// @param tokenId The id of the token
+    /// @param amount The amount of the token
+    event Evacuation(
+        address accountAddr,
+        uint32 indexed accountId,
+        IERC20 token,
+        uint16 indexed tokenId,
+        uint256 amount
+    );
+
+    /// @notice Emitted when evacuation mode is activated
+    event EvacuModeActivation();
+
+    /// @notice Emit when there is a new L1 request consumed
+    /// @dev Consumed number is the number of the executed L1 request - 1
+    /// @param executedL1RequestNum The number of the executed L1 request
+    /// @param opType The type of the L1 request
+    /// @param pubData The public data of the L1 request
+    event L1RequestConsumed(uint64 executedL1RequestNum, Operations.OpType opType, bytes pubData);
+
+    /// @notice Emit when an account is de-registered
+    /// @notice De-registered only remove the accountAddr -> accountId mapping,
+    ///         but not remove the accountId -> accountAddr mapping,
+    ///         this is for user can still refund their asset by `refundDeregisteredAddr`
+    /// @param accountAddr The address of the account
+    /// @param accountId The id of the account
+    event AccountDeregistered(address accountAddr, uint32 indexed accountId);
+
+    /// @notice When L2 system is down, anyone can call this function to activate the evacuation mode
+    function activateEvacuation() external;
+
+    /// @notice Consume the L1 non-executed requests in the evacuation mode
+    /// @param consumedTxPubData The public data of the non-executed L1 requests which in the request queue
+    function consumeL1RequestInEvacuMode(bytes[] calldata consumedTxPubData) external;
+
+    /// @notice Evacuate the funds of a specified user and token in the evacuMode
+    /// @param lastExecutedBlock The last executed block
+    /// @param newBlock A pseudo block to create block commitment for verification but not to be commited
+    /// @param proof The proof of the newBlock
+    function evacuate(
+        StoredBlock memory lastExecutedBlock,
+        CommitBlock calldata newBlock,
+        Proof calldata proof
+    ) external;
+
+    /// @notice Refund the deregistered address
+    /// @param token The token to be refunded
+    /// @param amount The amount of the token to be refunded
+    /// @param accountId The account id to be refunded
+    function refundDeregisteredAddr(IERC20 token, uint256 amount, uint32 accountId) external;
+
+    /// @notice Return the evacuation mode is activated or not
+    /// @return evacuMode The evacuation mode status
+    function isEvacuMode() external view returns (bool evacuMode);
+
+    /// @notice Return the specified address and token is evacuated or not
+    /// @param addr The address to be checked
+    /// @param tokenId The id of the token
+    /// @return isEvacuted Return true is the token is evacuated, else return false
+    function isEvacuted(address addr, uint16 tokenId) external view returns (bool);
+}
diff --git a/contracts/zkTrueUp/extensions/sDai/IPot.sol b/contracts/zkTrueUp/extensions/sDai/IPot.sol
new file mode 100644
index 0000000..4e9465d
--- /dev/null
+++ b/contracts/zkTrueUp/extensions/sDai/IPot.sol
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.17;
+
+/**
+ * @title The `partial` interface of the MakerDAO Pot contract
+ * @author Term Structure Labs
+ * @notice This interface is used to get the chi rate accumulator for sDai price feed
+ */
+interface IPot {
+    function chi() external view returns (uint256);
+
+    function rho() external view returns (uint256);
+
+    function drip() external returns (uint256);
+
+    function join(uint256) external;
+
+    function exit(uint256) external;
+}
diff --git a/contracts/zkTrueUp/extensions/sDai/SDaiPriceFeed.sol b/contracts/zkTrueUp/extensions/sDai/SDaiPriceFeed.sol
new file mode 100644
index 0000000..98e2618
--- /dev/null
+++ b/contracts/zkTrueUp/extensions/sDai/SDaiPriceFeed.sol
@@ -0,0 +1,86 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.17;
+
+import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
+import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
+import {IPot} from "./IPot.sol";
+
+/**
+ * @title The customized sDai price feed contract mutated from Chainlink AggregatorV3Interface
+ * @author Term Structure Labs
+ * @notice Use the customized price feed contract to normalized price feed interface for Term Structure Protocol
+ */
+contract SDaiPriceFeed is AggregatorV3Interface {
+    using SafeCast for uint256;
+    // The stETH price feed contract from Chainlink
+    AggregatorV3Interface internal immutable _daiPriceFeed;
+
+    // The MakerDAO Pot contract
+    // (see https://docs.makerdao.com/smart-contract-modules/rates-module/pot-detailed-documentation)
+    IPot internal immutable _pot;
+    int256 internal constant CHI_DECIMALS = 1e27; // chi (rate accumulator) decimals
+
+    // error to call `getRoundData` function
+    error GetRoundDataNotSupported();
+
+    /// @notice SDaiPriceFeed constructor
+    /// @param pot The MakerDAO Pot contract
+    /// @param daiPriceFeed The Dai price feed contract from Chainlink
+    constructor(IPot pot, AggregatorV3Interface daiPriceFeed) {
+        _pot = pot;
+        _daiPriceFeed = daiPriceFeed;
+    }
+
+    /**
+     * @notice Revert this function because cannot get the chi (rate accumulator) at a specific round
+     */
+    function getRoundData(
+        uint80 /* _roundId */
+    )
+        external
+        pure
+        returns (
+            uint80 /* roundId */,
+            int256 /* answer */,
+            uint256 /* startedAt */,
+            uint256 /* updatedAt */,
+            uint80 /* answeredInRound */
+        )
+    {
+        // error to call this function because cannot get the chi (rate accumulator) at a specific round
+        revert GetRoundDataNotSupported();
+    }
+
+    /**
+     * @notice Get the latest round data from chainlink and calculate the sDai price by multiplying chi (rate accumulator)
+     * @return roundId The round ID
+     * @return answer The calculated sDai price
+     * @return startedAt Timestamp of when the round started
+     * @return updatedAt Timestamp of when the round was updated
+     * @return answeredInRound The round ID of the round in which the answer was computed
+     */
+    function latestRoundData()
+        external
+        view
+        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)
+    {
+        // sDai price = dai price * chi (rate accumulator) / CHI_DECIMALS
+        (roundId, answer, startedAt, updatedAt, answeredInRound) = _daiPriceFeed.latestRoundData();
+        answer = (answer * _pot.chi().toInt256()) / CHI_DECIMALS;
+        return (roundId, answer, startedAt, updatedAt, answeredInRound);
+    }
+
+    /** ========== Return original chainlink data ========== */
+
+    function decimals() external view returns (uint8) {
+        return _daiPriceFeed.decimals();
+    }
+
+    function description() external view returns (string memory) {
+        return _daiPriceFeed.description();
+    }
+
+    function version() external view returns (uint256) {
+        return _daiPriceFeed.version();
+    }
+}
diff --git a/contracts/zkTrueUp/extensions/wstETH/IWstETH.sol b/contracts/zkTrueUp/extensions/wstETH/IWstETH.sol
new file mode 100644
index 0000000..ee64b38
--- /dev/null
+++ b/contracts/zkTrueUp/extensions/wstETH/IWstETH.sol
@@ -0,0 +1,37 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.17;
+
+import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
+import {IERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol";
+
+/**
+ * @title The interface of the Lido WstETH contract
+ * @author Term Structure Labs
+ * @notice This interface is used to get stETH per wstETH conversion rate for wstETH price feed
+ */
+interface IWstETH is IERC20Permit {
+    function stETH() external view returns (IStETH);
+
+    function wrap(uint256 _stETHAmount) external returns (uint256);
+
+    function unwrap(uint256 _wstETHAmount) external returns (uint256);
+
+    function getWstETHByStETH(uint256 _stETHAmount) external view returns (uint256);
+
+    function getStETHByWstETH(uint256 _wstETHAmount) external view returns (uint256);
+
+    function stEthPerToken() external view returns (uint256);
+
+    function tokensPerStEth() external view returns (uint256);
+}
+
+/**
+ * @title The interface of the Lido stETH contract
+ */
+interface IStETH is IERC20 {
+    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);
+
+    function getSharesByPooledEth(uint256 _pooledEthAmount) external view returns (uint256);
+
+    function submit(address _referral) external payable returns (uint256);
+}
diff --git a/contracts/zkTrueUp/extensions/wstETH/WstETHPriceFeed.sol b/contracts/zkTrueUp/extensions/wstETH/WstETHPriceFeed.sol
new file mode 100644
index 0000000..1db4cb4
--- /dev/null
+++ b/contracts/zkTrueUp/extensions/wstETH/WstETHPriceFeed.sol
@@ -0,0 +1,86 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.17;
+
+import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
+import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
+import {IWstETH} from "./IWstETH.sol";
+
+/**
+ * @title The customized wstETH price feed contract mutated from Chainlink AggregatorV3Interface
+ * @author Term Structure Labs
+ * @notice Use the customized price feed contract to normalized price feed interface for Term Structure Protocol
+ */
+contract WstETHPriceFeed is AggregatorV3Interface {
+    using SafeCast for uint256;
+    // The stETH price feed contract from Chainlink
+    AggregatorV3Interface internal immutable _stETHPriceFeed;
+
+    // The Lido WstETH contract
+    // (see https://docs.lido.fi/contracts/wsteth/)
+    IWstETH internal immutable _wstETH;
+    int256 internal constant STETH_PER_WSTETH_DECIMALS = 1e18;
+
+    // error to call `getRoundData` function
+    error GetRoundDataNotSupported();
+
+    /// @notice WstETHPriceFeed constructor
+    /// @param wstETH The Lido WstETH contract
+    /// @param stETHPriceFeed The stETH price feed contract from Chainlink
+    constructor(IWstETH wstETH, AggregatorV3Interface stETHPriceFeed) {
+        _wstETH = wstETH;
+        _stETHPriceFeed = stETHPriceFeed;
+    }
+
+    /**
+     * @notice Revert this function because cannot get the chi (rate accumulator) at a specific round
+     */
+    function getRoundData(
+        uint80 /* _roundId */
+    )
+        external
+        pure
+        returns (
+            uint80 /* roundId */,
+            int256 /* answer */,
+            uint256 /* startedAt */,
+            uint256 /* updatedAt */,
+            uint80 /* answeredInRound */
+        )
+    {
+        // error to call this function because cannot get the stETH/wstETH ratio at a specific round
+        revert GetRoundDataNotSupported();
+    }
+
+    /**
+     * @notice Get the latest round data from chainlink and calculate the wstETH price by multiplying stETH/wstETH ratio
+     * @return roundId The round ID
+     * @return answer The calculated wstETH price
+     * @return startedAt Timestamp of when the round started
+     * @return updatedAt Timestamp of when the round was updated
+     * @return answeredInRound The round ID of the round in which the answer was computed
+     */
+    function latestRoundData()
+        external
+        view
+        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)
+    {
+        // wstETH price = stETH price * stETHPerWstETH / STETH_PER_WSTETH_DECIMALS
+        (roundId, answer, startedAt, updatedAt, answeredInRound) = _stETHPriceFeed.latestRoundData();
+        answer = (answer * _wstETH.stEthPerToken().toInt256()) / STETH_PER_WSTETH_DECIMALS;
+        return (roundId, answer, startedAt, updatedAt, answeredInRound);
+    }
+
+    /** ========== Return original chainlink data ========== */
+
+    function decimals() external view returns (uint8) {
+        return _stETHPriceFeed.decimals();
+    }
+
+    function description() external view returns (string memory) {
+        return _stETHPriceFeed.description();
+    }
+
+    function version() external view returns (uint256) {
+        return _stETHPriceFeed.version();
+    }
+}
diff --git a/contracts/zkTrueUp/flashLoan/FlashLoanFacet.sol b/contracts/zkTrueUp/flashLoan/FlashLoanFacet.sol
index f7dd90a..683ac81 100644
--- a/contracts/zkTrueUp/flashLoan/FlashLoanFacet.sol
+++ b/contracts/zkTrueUp/flashLoan/FlashLoanFacet.sol
@@ -1,79 +1,80 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
 import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
 import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
 import {AccessControlInternal} from "@solidstate/contracts/access/access_control/AccessControlInternal.sol";
+import {ReentrancyGuard} from "@solidstate/contracts/security/reentrancy_guard/ReentrancyGuard.sol";
 import {FlashLoanStorage} from "./FlashLoanStorage.sol";
 import {ProtocolParamsStorage} from "../protocolParams/ProtocolParamsStorage.sol";
 import {TokenStorage} from "../token/TokenStorage.sol";
 import {FlashLoanLib} from "./FlashLoanLib.sol";
 import {IFlashLoanFacet} from "./IFlashLoanFacet.sol";
 import {IFlashLoanReceiver} from "../interfaces/IFlashLoanReceiver.sol";
 import {ProtocolParamsLib} from "../protocolParams/ProtocolParamsLib.sol";
 import {TokenLib} from "../token/TokenLib.sol";
 import {Config} from "../libraries/Config.sol";
 
 /**
  * @title Term Structure Flash Loan Facet Contract
  * @author Term Structure Labs
  * @notice The flashLoan facet is used to flash loan tokens from Term Structure Protocol
  */
-contract FlashLoanFacet is AccessControlInternal, IFlashLoanFacet {
+contract FlashLoanFacet is IFlashLoanFacet, AccessControlInternal, ReentrancyGuard {
     using Math for uint256;
     using SafeERC20 for IERC20;
     using FlashLoanLib for FlashLoanStorage.Layout;
     using ProtocolParamsLib for ProtocolParamsStorage.Layout;
     using TokenLib for TokenStorage.Layout;
 
     /**
      * @inheritdoc IFlashLoanFacet
      * @notice The flash loan function is used to borrow tokens from ZkTrueUp
      * @notice The borrower must repay the borrowed tokens and the premium to ZkTrueUp
      * @notice The flash loan function is borrow WETH instead of ETH
      */
     function flashLoan(
         address payable receiver,
         IERC20[] memory assets,
         uint256[] memory amounts,
         bytes memory data
-    ) external {
+    ) external nonReentrant {
         if (assets.length != amounts.length) revert InputLengthMismatch(assets.length, amounts.length);
         uint16 flashLoanPremium = FlashLoanStorage.layout().getFlashLoanPremium();
         uint256[] memory premiums = new uint256[](assets.length);
         for (uint256 i; i < assets.length; i++) {
             TokenStorage.layout().getValidToken(assets[i]);
             premiums[i] = amounts[i].mulDiv(flashLoanPremium, Config.FLASH_LOAN_PREMIUM_BASE);
             assets[i].safeTransfer(receiver, amounts[i]);
         }
 
         try IFlashLoanReceiver(receiver).executeOperation(msg.sender, assets, amounts, premiums, data) {
             address payable treasuryAddr = ProtocolParamsStorage.layout().getTreasuryAddr();
             for (uint256 i; i < assets.length; i++) {
                 assets[i].safeTransferFrom(receiver, address(this), amounts[i] + premiums[i]);
                 assets[i].safeTransfer(treasuryAddr, premiums[i]);
                 emit FlashLoan(msg.sender, receiver, assets[i], amounts[i], premiums[i]);
             }
         } catch Error(string memory err) {
             revert ExecuteOperationFailedLogString(err);
         } catch (bytes memory err) {
             revert ExecuteOperationFailedLogBytes(err);
         }
     }
 
     /**
      * @inheritdoc IFlashLoanFacet
      */
     function setFlashLoanPremium(uint16 flashLoanPremium) external onlyRole(Config.ADMIN_ROLE) {
         FlashLoanStorage.layout().flashLoanPremium = flashLoanPremium;
         emit SetFlashLoanPremium(flashLoanPremium);
     }
 
     /**
      * @inheritdoc IFlashLoanFacet
      */
     function getFlashLoanPremium() external view returns (uint16) {
         return FlashLoanStorage.layout().getFlashLoanPremium();
     }
 }
diff --git a/contracts/zkTrueUp/initializer/ZkTrueUpInit.sol b/contracts/zkTrueUp/initializer/ZkTrueUpInit.sol
index 6870323..97e5419 100644
--- a/contracts/zkTrueUp/initializer/ZkTrueUpInit.sol
+++ b/contracts/zkTrueUp/initializer/ZkTrueUpInit.sol
@@ -1,134 +1,158 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
 import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 import {Initializable} from "@solidstate/contracts/security/initializable/Initializable.sol";
 import {AccessControlInternal} from "@solidstate/contracts/access/access_control/AccessControlInternal.sol";
 import {Ownable} from "@solidstate/contracts/access/ownable/Ownable.sol";
 import {AccountStorage} from "../account/AccountStorage.sol";
 import {AddressStorage} from "../address/AddressStorage.sol";
 import {FlashLoanStorage} from "../flashLoan/FlashLoanStorage.sol";
 import {ProtocolParamsStorage, FundWeight} from "../protocolParams/ProtocolParamsStorage.sol";
 import {LoanStorage, LiquidationFactor} from "../loan/LoanStorage.sol";
 import {RollupStorage, StoredBlock} from "../rollup/RollupStorage.sol";
 import {TokenStorage, AssetConfig} from "../token/TokenStorage.sol";
 import {IWETH} from "../interfaces/IWETH.sol";
 import {IPoseidonUnit2} from "../interfaces/IPoseidonUnit2.sol";
 import {IVerifier} from "../interfaces/IVerifier.sol";
 import {IPool} from "../interfaces/aaveV3/IPool.sol";
 import {Config} from "../libraries/Config.sol";
 import {InitialConfig} from "../libraries/InitialConfig.sol";
+import {Utils} from "../libraries/Utils.sol";
 
 /**
  * @title Zk-TureUp Initializer Contract
  * @author Term Structure Labs
  * @notice This contract is used to initialize the Term Structure Protocol
  */
 contract ZkTrueUpInit is Ownable, Initializable, AccessControlInternal {
+    using Utils for *;
+
     /**
      * @notice Initialize function for the Term Structure Protocol
      * @dev This function is called only once when the protocol is deployed
      * @param data The encoded data for the initializer
      */
     function init(bytes calldata data) external initializer {
         (
             address wETHAddr,
             address poseidonUnit2Addr,
             address verifierAddr,
             address evacuVerifierAddr,
             address adminAddr,
             address operatorAddr,
             address payable treasuryAddr,
             address payable insuranceAddr,
             address payable vaultAddr,
             bytes32 genesisStateRoot,
             AssetConfig memory ethConfig
         ) = abi.decode(
                 data,
                 (address, address, address, address, address, address, address, address, address, bytes32, AssetConfig)
             );
 
+        // check address of initial parameters are not zero address
+        wETHAddr.notZeroAddr();
+        poseidonUnit2Addr.notZeroAddr();
+        verifierAddr.notZeroAddr();
+        evacuVerifierAddr.notZeroAddr();
+        adminAddr.notZeroAddr();
+        operatorAddr.notZeroAddr();
+        treasuryAddr.notZeroAddr();
+        insuranceAddr.notZeroAddr();
+        vaultAddr.notZeroAddr();
+
         // set roles
         _setRoleAdmin(Config.ADMIN_ROLE, Config.ADMIN_ROLE);
+        _setRoleAdmin(Config.OPERATOR_ROLE, Config.ADMIN_ROLE);
+        _setRoleAdmin(Config.COMMITTER_ROLE, Config.ADMIN_ROLE);
+        _setRoleAdmin(Config.VERIFIER_ROLE, Config.ADMIN_ROLE);
+        _setRoleAdmin(Config.EXECUTER_ROLE, Config.ADMIN_ROLE);
         _grantRole(Config.ADMIN_ROLE, adminAddr);
         _grantRole(Config.OPERATOR_ROLE, operatorAddr);
         _grantRole(Config.COMMITTER_ROLE, operatorAddr);
         _grantRole(Config.VERIFIER_ROLE, operatorAddr);
         _grantRole(Config.EXECUTER_ROLE, operatorAddr);
         transferOwnership(adminAddr);
 
         // init account facet
         AccountStorage.Layout storage asl = AccountStorage.layout();
         asl.accountNum = Config.NUM_RESERVED_ACCOUNTS;
 
         // init address facet
         AddressStorage.Layout storage addrsl = AddressStorage.layout();
         addrsl.wETH = IWETH(wETHAddr);
         addrsl.poseidonUnit2 = IPoseidonUnit2(poseidonUnit2Addr);
         addrsl.verifier = IVerifier(verifierAddr);
         addrsl.evacuVerifier = IVerifier(evacuVerifierAddr);
+
+        Config.AAVE_V3_POOL_ADDRESS.notZeroAddr();
         addrsl.aaveV3Pool = IPool(Config.AAVE_V3_POOL_ADDRESS);
 
         // init flashLoan facet
         FlashLoanStorage.Layout storage flsl = FlashLoanStorage.layout();
         flsl.flashLoanPremium = InitialConfig.INIT_FLASH_LOAN_PREMIUM;
 
         // init protocolParams facet
         ProtocolParamsStorage.Layout storage ppsl = ProtocolParamsStorage.layout();
         ppsl.treasuryAddr = treasuryAddr;
         ppsl.insuranceAddr = insuranceAddr;
         ppsl.vaultAddr = vaultAddr;
         FundWeight memory fundWeight = FundWeight({
             treasury: InitialConfig.INIT_TREASURY_WEIGHT,
             insurance: InitialConfig.INIT_INSURANCE_WEIGHT,
             vault: InitialConfig.INIT_VAULT_WEIGHT
         });
         ppsl.fundWeight = fundWeight;
 
         // init loan facet
         LoanStorage.Layout storage lsl = LoanStorage.layout();
         lsl.halfLiquidationThreshold = InitialConfig.INIT_HALF_LIQUIDATION_THRESHOLD;
+        lsl.borrowFeeRate = InitialConfig.INIT_BORROW_FEE_RATE;
+        lsl.rollOverFee = InitialConfig.INIT_ROLL_OVER_FEE;
 
         LiquidationFactor memory initLiquidationFactor = LiquidationFactor({
-            ltvThreshold: InitialConfig.INIT_LTV_THRESHOLD,
+            liquidationLtvThreshold: InitialConfig.INIT_LIQUIDATION_LTV_THRESHOLD,
+            borrowOrderLtvThreshold: InitialConfig.INIT_BORROW_ORDER_LTV_THRESHOLD,
             liquidatorIncentive: InitialConfig.INIT_LIQUIDATOR_INCENTIVE,
             protocolPenalty: InitialConfig.INIT_PROTOCOL_PENALTY
         });
         lsl.liquidationFactor = initLiquidationFactor;
 
         LiquidationFactor memory initStableCoinPairLiquidationFactor = LiquidationFactor({
-            ltvThreshold: InitialConfig.INIT_STABLECOIN_PAIR_LTV_THRESHOLD,
+            liquidationLtvThreshold: InitialConfig.INIT_STABLECOIN_PAIR_LIQUIDATION_LTV_THRESHOLD,
+            borrowOrderLtvThreshold: InitialConfig.INIT_STABLECOIN_PAIR_BORROW_ORDER_LTV_THRESHOLD,
             liquidatorIncentive: InitialConfig.INIT_STABLECOIN_PAIR_LIQUIDATOR_INCENTIVE,
             protocolPenalty: InitialConfig.INIT_STABLECOIN_PAIR_PROTOCOL_PENALTY
         });
         lsl.stableCoinPairLiquidationFactor = initStableCoinPairLiquidationFactor;
 
         // init rollup facet
         RollupStorage.Layout storage rsl = RollupStorage.layout();
         StoredBlock memory genesisBlock = StoredBlock({
             blockNumber: 0,
             l1RequestNum: 0,
             pendingRollupTxHash: Config.EMPTY_STRING_KECCAK,
             commitment: bytes32(0),
             stateRoot: genesisStateRoot,
             timestamp: 0
         });
         rsl.storedBlockHashes[0] = keccak256(abi.encode(genesisBlock));
 
         // init token facet
         TokenStorage.Layout storage tsl = TokenStorage.layout();
         // The first token Id is start from 1 in init
         uint16 newTokenId = tsl.tokenNum + 1;
         tsl.tokenNum = newTokenId;
         IERC20 defaultEthToken = IERC20(Config.ETH_ADDRESS);
         tsl.tokenIds[defaultEthToken] = newTokenId;
         tsl.assetConfigs[newTokenId] = AssetConfig({
             isStableCoin: ethConfig.isStableCoin,
             isTsbToken: ethConfig.isTsbToken,
             decimals: ethConfig.decimals,
             minDepositAmt: ethConfig.minDepositAmt,
             token: defaultEthToken,
             priceFeed: ethConfig.priceFeed
         });
     }
 }
diff --git a/contracts/zkTrueUp/libraries/Bytes.sol b/contracts/zkTrueUp/libraries/Bytes.sol
index 629b08c..3d7da38 100644
--- a/contracts/zkTrueUp/libraries/Bytes.sol
+++ b/contracts/zkTrueUp/libraries/Bytes.sol
@@ -1,145 +1,198 @@
 // SPDX-License-Identifier: MIT
 // solhint-disable no-inline-assembly
 pragma solidity ^0.8.17;
 
 import {Config} from "./Config.sol";
 
 /**
  * @title Bytes Library
  * @author Term Structure Labs
  * @notice Library for bytes operations
  * @dev Original source code refer from https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol#L228
  */
 library Bytes {
     /// @notice Error for invalid slice length
     error OverPublicDataLength(uint256 pubDataLength, uint256 start, uint256 expectedDataLength);
+    /// @notice Error for invalid bytes length
+    error InvalidBytesLength(uint256 bytesLen, uint256 offset);
 
     /// @notice slice public data to get the length of the one chunk (12 bytes)
     /// @param pubData The public data of the rollup
     /// @param start The start index of the one chunk length
     /// @return data The data of the one chunk length
     function sliceOneChunkBytes(bytes memory pubData, uint256 start) internal pure returns (bytes memory) {
         uint256 bytesLength = Config.BYTES_OF_CHUNK; // 12 bytes
         _validSliceLength(pubData.length, start, bytesLength);
         bytes memory data = new bytes(bytesLength);
         assembly {
             let slice_curr := add(data, 0x20)
             let array_curr := add(pubData, add(start, 0x20))
             // mstore 1 times for 12 bytes
             mstore(slice_curr, mload(array_curr))
         }
         return data;
     }
 
     /// @notice slice public data to get the length of the two chunks (24 bytes)
     /// @param pubData The public data of the rollup
     /// @param start The start index of the two chunks length
     /// @return data The data of the two chunks length
     function sliceTwoChunksBytes(bytes memory pubData, uint256 start) internal pure returns (bytes memory) {
         uint256 bytesLength = Config.BYTES_OF_TWO_CHUNKS; // 24 bytes
         _validSliceLength(pubData.length, start, bytesLength);
         bytes memory data = new bytes(bytesLength);
         assembly {
             let slice_curr := add(data, 0x20)
             let array_curr := add(pubData, add(start, 0x20))
             // mstore 1 times for 24 bytes
             mstore(slice_curr, mload(array_curr))
         }
         return data;
     }
 
     /// @notice slice public data to get the length of the three chunks (36 bytes)
     /// @param pubData The public data of the rollup
     /// @param start The start index of the three chunks length
     /// @return data The data of the three chunks length
     function sliceThreeChunksBytes(bytes memory pubData, uint256 start) internal pure returns (bytes memory) {
         uint256 bytesLength = Config.BYTES_OF_THREE_CHUNKS; // 36 bytes
         _validSliceLength(pubData.length, start, bytesLength);
         bytes memory data = new bytes(bytesLength);
         assembly {
             let slice_curr := add(data, 0x20)
             let array_curr := add(pubData, add(start, 0x20))
             // mstore 2 times for 36 bytes
             mstore(slice_curr, mload(array_curr))
             mstore(add(slice_curr, 0x20), mload(add(array_curr, 0x20)))
         }
         return data;
     }
 
     /// @notice slice public data to get the length of the four chunks (48 bytes)
     /// @param pubData The public data of the rollup
     /// @param start The start index of the four chunks length
     /// @return data The data of the four chunks length
     function sliceFourChunksBytes(bytes memory pubData, uint256 start) internal pure returns (bytes memory) {
         uint256 bytesLength = Config.BYTES_OF_FOUR_CHUNKS; // 48 bytes
         _validSliceLength(pubData.length, start, bytesLength);
         bytes memory data = new bytes(bytesLength);
         assembly {
             let slice_curr := add(data, 0x20)
             let array_curr := add(pubData, add(start, 0x20))
             // mstore 2 times for 48 bytes
             mstore(slice_curr, mload(array_curr))
             mstore(add(slice_curr, 0x20), mload(add(array_curr, 0x20)))
         }
         return data;
     }
 
+    /// @notice slice public data to get the length of the five chunks (60 bytes)
+    /// @param pubData The public data of the rollup
+    /// @param start The start index of the five chunks length
+    /// @return data The data of the five chunks length
+    function sliceFiveChunksBytes(bytes memory pubData, uint256 start) internal pure returns (bytes memory) {
+        uint256 bytesLength = Config.BYTES_OF_FIVE_CHUNKS; // 60 bytes
+        _validSliceLength(pubData.length, start, bytesLength);
+        bytes memory data = new bytes(bytesLength);
+        assembly {
+            let slice_curr := add(data, 0x20)
+            let array_curr := add(pubData, add(start, 0x20))
+            // mstore 3 times for 60 bytes
+            mstore(slice_curr, mload(array_curr))
+            mstore(add(slice_curr, 0x20), mload(add(array_curr, 0x20)))
+        }
+        return data;
+    }
+
+    /// @notice slice public data to get the length of the six chunks (72 bytes)
+    /// @param pubData The public data of the rollup
+    /// @param start The start index of the six chunks length
+    /// @return data The data of the six chunks length
+    function sliceSixChunksBytes(bytes memory pubData, uint256 start) internal pure returns (bytes memory) {
+        uint256 bytesLength = Config.BYTES_OF_SIX_CHUNKS; // 72 bytes
+        _validSliceLength(pubData.length, start, bytesLength);
+        bytes memory data = new bytes(bytesLength);
+        assembly {
+            let slice_curr := add(data, 0x20)
+            let array_curr := add(pubData, add(start, 0x20))
+            // mstore 3 times for 72 bytes
+            mstore(slice_curr, mload(array_curr))
+            mstore(add(slice_curr, 0x20), mload(add(array_curr, 0x20)))
+            mstore(add(slice_curr, 0x40), mload(add(array_curr, 0x40)))
+        }
+        return data;
+    }
+
     /// @notice Internal function to check the slice length
     /// @param pubDataLength The length of the public data
     /// @param start The start index of the slice
     /// @param sliceLength The length of the slice
     function _validSliceLength(uint256 pubDataLength, uint256 start, uint256 sliceLength) private pure {
         if (pubDataLength < (start + sliceLength)) revert OverPublicDataLength(pubDataLength, start, sliceLength);
     }
 
     function readUInt32(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint32 r) {
         newOffset = _offset + 4;
         r = bytesToUInt32(_data, _offset);
     }
 
     function bytesToUInt32(bytes memory _bytes, uint256 _start) internal pure returns (uint32 r) {
         uint256 offset = _start + 0x4;
-        require(_bytes.length >= offset, "V");
+        if (_bytes.length < offset) revert InvalidBytesLength(_bytes.length, offset);
         assembly {
             r := mload(add(_bytes, offset))
         }
     }
 
+    function readBytes12(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, bytes12 r) {
+        newOffset = _offset + 12;
+        r = bytesToBytes12(_data, _offset);
+    }
+
+    function bytesToBytes12(bytes memory self, uint256 _start) internal pure returns (bytes12 r) {
+        uint256 offset = _start + 12;
+        if (self.length < offset) revert InvalidBytesLength(self.length, offset);
+        assembly {
+            r := mload(add(add(self, 0x20), _start))
+        }
+    }
+
     function readBytes20(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, bytes20 r) {
         newOffset = _offset + 20;
         r = bytesToBytes20(_data, _offset);
     }
 
     function bytesToBytes20(bytes memory self, uint256 _start) internal pure returns (bytes20 r) {
-        require(self.length >= (_start + 20), "S");
+        uint256 offset = _start + 20;
+        if (self.length < offset) revert InvalidBytesLength(self.length, offset);
         assembly {
             r := mload(add(add(self, 0x20), _start))
         }
     }
 
     function readUInt16(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint16 r) {
         newOffset = _offset + 2;
         r = bytesToUInt16(_data, _offset);
     }
 
     function bytesToUInt16(bytes memory _bytes, uint256 _start) internal pure returns (uint16 r) {
         uint256 offset = _start + 0x2;
-        require(_bytes.length >= offset, "T");
+        if (_bytes.length < offset) revert InvalidBytesLength(_bytes.length, offset);
         assembly {
             r := mload(add(_bytes, offset))
         }
     }
 
     function bytesToUInt128(bytes memory _bytes, uint256 _start) internal pure returns (uint128 r) {
         uint256 offset = _start + 0x10;
-        require(_bytes.length >= offset, "W");
+        if (_bytes.length < offset) revert InvalidBytesLength(_bytes.length, offset);
         assembly {
             r := mload(add(_bytes, offset))
         }
     }
 
     function readUInt128(bytes memory _data, uint256 _offset) internal pure returns (uint256 newOffset, uint128 r) {
         newOffset = _offset + 16;
         r = bytesToUInt128(_data, _offset);
     }
 }
diff --git a/contracts/zkTrueUp/libraries/Config.sol b/contracts/zkTrueUp/libraries/Config.sol
index 733224a..805af16 100644
--- a/contracts/zkTrueUp/libraries/Config.sol
+++ b/contracts/zkTrueUp/libraries/Config.sol
@@ -1,115 +1,129 @@
 // SPDX-License-Identifier: MIT
-// solhint-disable-next-line
 pragma solidity ^0.8.17;
 
 /**
  * @title Config Library
  * @author Term Structure Labs
  * @notice Library for constants and configuration parameters
  */
 library Config {
     /// @notice The default address of ETH
     address internal constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;
 
     /// @notice The base of fund distribution weight of the protocol
     uint16 internal constant FUND_WEIGHT_BASE = 10000;
 
     /// @notice The health factor threshold
     /// @dev Constant value 1, and the decimals is 3
     /// @dev If health factor < HEALTH_FACTOR_THRESHOLD, the loan is liquidable
     uint16 internal constant HEALTH_FACTOR_THRESHOLD = 1000;
 
     /// @notice The base of LTV ratio
     uint16 internal constant LTV_BASE = 1000;
 
     /// @notice The max LTV ratio
     uint16 internal constant MAX_LTV_RATIO = 1000; // 100%
 
     /// @notice The base of flashloan premium
     uint16 internal constant FLASH_LOAN_PREMIUM_BASE = 10000;
 
     /// @notice The max amount of registered tokens
     uint32 internal constant MAX_AMOUNT_OF_REGISTERED_TOKENS = type(uint16).max;
 
     /// @notice The max amount of registered tokens
     uint32 internal constant MAX_AMOUNT_OF_REGISTERED_ACCOUNT = type(uint32).max;
 
     /// @notice Expriation period for L1 request
     uint256 internal constant EXPIRATION_PERIOD = 14 days;
 
     /// @notice Number of reserved accounts (reserved accountId 0 as default accountId)
     uint8 internal constant NUM_RESERVED_ACCOUNTS = 1;
 
     /// @notice Hash of empty string
     bytes32 internal constant EMPTY_STRING_KECCAK = keccak256("");
 
     /// @notice The Bits number of 1 byte
     uint8 internal constant BITS_OF_BYTE = 8;
 
     /// @notice The last index of 1 byte
     uint8 internal constant LAST_INDEX_OF_BYTE = BITS_OF_BYTE - 1;
 
     /// @notice The bytes lengths to represent operation type
     uint8 internal constant BYTES_OF_OP_TYPE = 1;
 
     /// @notice The bytes lengths of a chunk
     uint8 internal constant BYTES_OF_CHUNK = 12;
 
     /// @notice The bytes lengths of two chunks
     uint8 internal constant BYTES_OF_TWO_CHUNKS = 2 * BYTES_OF_CHUNK;
 
     /// @notice The bytes lengths of three chunks
     uint8 internal constant BYTES_OF_THREE_CHUNKS = 3 * BYTES_OF_CHUNK;
 
     /// @notice The bytes lengths of four chunks
     uint8 internal constant BYTES_OF_FOUR_CHUNKS = 4 * BYTES_OF_CHUNK;
 
+    /// @notice The bytes lengths of five chunks
+    uint8 internal constant BYTES_OF_FIVE_CHUNKS = 5 * BYTES_OF_CHUNK;
+
+    /// @notice The bytes lengths of six chunks
+    uint8 internal constant BYTES_OF_SIX_CHUNKS = 6 * BYTES_OF_CHUNK;
+
     /// @notice The bits lengths of a chunk
     uint8 internal constant BITS_OF_CHUNK = BYTES_OF_CHUNK * BITS_OF_BYTE;
 
     /// @notice The chunk size of a evacuation request
     uint256 internal constant EVACUATION_CHUNK_SIZE = 2;
 
     /// @notice The evacuation commitment offset
     /// @dev 0x80 = 0b10000000 in binary, the first bit (critical chunk flag) is 1
     bytes internal constant EVACUATION_COMMITMENT_OFFSET = hex"80";
 
     /// @notice The max tolerance between the L2 block timestamp and the L1 block timestamp
-    ///         i.e. the block created on L2 must be commit to L1 within 1 day
-    uint256 internal constant COMMIT_BLOCK_TIMESTAMP_MAX_TOLERANCE = 1 days;
+    ///         i.e. the block created on L2 must be commit to L1 within 3 day
+    uint256 internal constant COMMIT_BLOCK_TIMESTAMP_MAX_TOLERANCE = 3 days;
 
     /// @notice The max deviation between the L2 block timestamp and the L1 block timestamp
     ///         i.e. the L2 block timestamp cannot greater than the L1 block timestamp + 15 minutes
     uint256 internal constant COMMIT_BLOCK_TIMESTAMP_MAX_DEVIATION = 15 minutes;
 
     /// @notice The field modulus of bn254
     uint256 internal constant SCALAR_FIELD_SIZE =
         21888242871839275222246405745257275088548364400416034343698204186575808495617;
 
     /// @notice The decimals of L2 system
     uint8 internal constant SYSTEM_DECIMALS = 8;
 
+    /// @notice The base of L2 system unit
+    uint256 internal constant SYSTEM_UNIT_BASE = 10 ** SYSTEM_DECIMALS;
+
     /// @notice Role for admin
     bytes32 internal constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
 
     /// @notice Role for operator
     bytes32 internal constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");
 
     /// @notice Role for committer
     bytes32 internal constant COMMITTER_ROLE = keccak256("COMMITTER_ROLE");
 
     /// @notice Role for verifier
     bytes32 internal constant VERIFIER_ROLE = keccak256("VERIFIER_ROLE");
 
     /// @notice Role for executor
     bytes32 internal constant EXECUTER_ROLE = keccak256("EXECUTER_ROLE");
 
     /// @notice Aave V3 pool address
     address internal constant AAVE_V3_POOL_ADDRESS = 0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;
 
     /// @notice Aave V3 referral code
     uint16 internal constant AAVE_V3_REFERRAL_CODE = 0;
 
     /// @notice Aave V3 interest rate mode
     uint256 internal constant AAVE_V3_INTEREST_RATE_MODE = 2;
+
+    /// @notice The last roll borrow order time can place to maturity time
+    uint256 internal constant LAST_ROLL_ORDER_TIME_TO_MATURITY = 1 days;
+
+    /// @notice The seconds of one year
+    uint256 internal constant SECONDS_OF_ONE_YEAR = 365 days;
 }
diff --git a/contracts/zkTrueUp/libraries/Delegate.sol b/contracts/zkTrueUp/libraries/Delegate.sol
new file mode 100644
index 0000000..5f83a69
--- /dev/null
+++ b/contracts/zkTrueUp/libraries/Delegate.sol
@@ -0,0 +1,21 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.17;
+
+//! mainnet-audit
+// delegated actions mask
+uint256 constant DELEGATE_WITHDRAW_MASK = 1 << 255;
+uint256 constant DELEGATE_REMOVE_COLLATERAL_MASK = 1 << 254;
+uint256 constant DELEGATE_REPAY_MASK = 1 << 253;
+uint256 constant DELEGATE_ROLL_TO_AAVE_MASK = 1 << 252;
+uint256 constant DELEGATE_ROLL_BORROW_MASK = 1 << 251;
+uint256 constant DELEGATE_FORCE_CANCEL_ROLL_BORROW_MASK = 1 << 250;
+uint256 constant DELEGATE_REDEEM_MASK = 1 << 249;
+
+library Delegate {
+    /// @notice Check if the action is delegated
+    /// @param delegatedActions The delegated actions
+    /// @param actionMask The mask of the action to check
+    function isDelegated(uint256 delegatedActions, uint256 actionMask) internal pure returns (bool) {
+        return (delegatedActions & actionMask) != 0;
+    }
+}
diff --git a/contracts/zkTrueUp/libraries/InitialConfig.sol b/contracts/zkTrueUp/libraries/InitialConfig.sol
index 1dce26a..e1645f4 100644
--- a/contracts/zkTrueUp/libraries/InitialConfig.sol
+++ b/contracts/zkTrueUp/libraries/InitialConfig.sol
@@ -1,44 +1,55 @@
 // SPDX-License-Identifier: MIT
-// solhint-disable-next-line
 pragma solidity ^0.8.17;
 
 /**
  * @title Initial Config Library
  * @author Term Structure Labs
  * @notice Initial configurations of the protocol
  */
 library InitialConfig {
     /// @notice The initial weight of the treasury
     uint16 internal constant INIT_TREASURY_WEIGHT = 0.5e4; // 50%
 
     /// @notice The initial weight of the insurance fund
     uint16 internal constant INIT_INSURANCE_WEIGHT = 0.1e4; // 10%
 
     /// @notice The initial weight of the vault
     uint16 internal constant INIT_VAULT_WEIGHT = 0.4e4; // 40%
 
     /// @notice Initial half liquidation threshold
     /// @dev If the collateral value is larger than half liquidation threshold, the liquidator can only liquidate half of the loan
     uint16 internal constant INIT_HALF_LIQUIDATION_THRESHOLD = 10000; // 10000 USD
 
-    /// @notice Initial threshold of LTV ratio
-    uint16 internal constant INIT_LTV_THRESHOLD = 0.8e3; // 80%
+    /// @notice Initial threshold of liquidation LTV ratio, if the ratio is higher than the threshold, the loan will be liquidated
+    uint16 internal constant INIT_LIQUIDATION_LTV_THRESHOLD = 0.8e3; // 80%
 
-    /// @notice Initial threshold of stablecoin pair LTV ratio
-    uint16 internal constant INIT_STABLECOIN_PAIR_LTV_THRESHOLD = 0.925e3; // 92.5%
+    /// @notice Initial threshold of borrow order LTV ratio, 5% buffer between liquidated LTV threshold and borrow order LTV threshold
+    uint16 internal constant INIT_BORROW_ORDER_LTV_THRESHOLD = 0.75e3; // 75%
+
+    /// @notice Initial threshold of stablecoin pair liquidation LTV ratio, if the ratio is higher than the threshold, the loan will be liquidated
+    uint16 internal constant INIT_STABLECOIN_PAIR_LIQUIDATION_LTV_THRESHOLD = 0.925e3; // 92.5%
+
+    /// @notice Initial threshold of stablecoin pair borrow order LTV ratio, 2.5% buffer between liquidated LTV threshold and borrow order LTV threshold
+    uint16 internal constant INIT_STABLECOIN_PAIR_BORROW_ORDER_LTV_THRESHOLD = 0.9e3; // 90%
 
     /// @notice Initial liquidator incentive
     uint16 internal constant INIT_LIQUIDATOR_INCENTIVE = 0.05e3; // 5%
 
     /// @notice Initial stablecoin pair liquidator incentive
     uint16 internal constant INIT_STABLECOIN_PAIR_LIQUIDATOR_INCENTIVE = 0.03e3; // 3%
 
     /// @notice Initial protocol penalty
     uint16 internal constant INIT_PROTOCOL_PENALTY = 0.05e3; // 5%
 
     /// @notice Initial stablecoin pair protocol penalty
     uint16 internal constant INIT_STABLECOIN_PAIR_PROTOCOL_PENALTY = 0.015e3; // 1.5%
 
     /// @notice Initial flashloan premium
     uint16 internal constant INIT_FLASH_LOAN_PREMIUM = 0.0003e4; // 0.03%
+
+    /// @notice Initial borrow fee rate of interest rate for borrower
+    uint32 internal constant INIT_BORROW_FEE_RATE = 0.1e8; // 10% of interest rate
+
+    /// @notice Initial roll over fee
+    uint256 internal constant INIT_ROLL_OVER_FEE = 0.01 ether;
 }
diff --git a/contracts/zkTrueUp/libraries/Operations.sol b/contracts/zkTrueUp/libraries/Operations.sol
index 81f6cd1..4da51eb 100644
--- a/contracts/zkTrueUp/libraries/Operations.sol
+++ b/contracts/zkTrueUp/libraries/Operations.sol
@@ -1,202 +1,340 @@
 // SPDX-License-Identifier: MIT
-// solhint-disable-next-line
 pragma solidity ^0.8.17;
 
+import {ITsbToken} from "../interfaces/ITsbToken.sol";
 import {Config} from "./Config.sol";
 import {Bytes} from "./Bytes.sol";
 
 /**
  * @title Operations Library
  * @author Term Structure Labs
  * @notice Library for define the operation type and the operation data structure,
  *         used in the rollup circuit
  */
 library Operations {
     /// @notice circuit operation type
     enum OpType {
-        NOOP,
-        REGISTER,
-        DEPOSIT,
-        FORCE_WITHDRAW,
-        TRANSFER,
-        WITHDRAW,
-        AUCTION_LEND,
-        AUCTION_BORROW,
-        AUCTION_START,
-        AUCTION_MATCH,
-        AUCTION_END,
-        SECOND_LIMIT_ORDER,
-        SECOND_LIMIT_START,
-        SECOND_LIMIT_EXCHANGE,
-        SECOND_LIMIT_END,
-        SECOND_MARKET_ORDER,
-        SECOND_MARKET_EXCHANGE,
-        SECOND_MARKET_END,
-        ADMIN_CANCEL_ORDER,
-        USER_CANCEL_ORDER,
-        INCREASE_EPOCH,
-        CREATE_TSB_TOKEN,
-        REDEEM,
-        WITHDRAW_FEE,
-        EVACUATION,
-        SET_ADMIN_TS_ADDR
+        NOOP, // 0
+        REGISTER, // 1
+        DEPOSIT, // 2
+        FORCE_WITHDRAW, // 3
+        TRANSFER, // 4
+        WITHDRAW, // 5
+        AUCTION_LEND, // 6
+        AUCTION_BORROW, // 7
+        AUCTION_START, // 8
+        AUCTION_MATCH, // 9
+        AUCTION_END, // 10
+        SECOND_LIMIT_ORDER, // 11
+        SECOND_LIMIT_START, // 12
+        SECOND_LIMIT_EXCHANGE, // 13
+        SECOND_LIMIT_END, // 14
+        SECOND_MARKET_ORDER, // 15
+        SECOND_MARKET_EXCHANGE, // 16
+        SECOND_MARKET_END, // 17
+        ADMIN_CANCEL_ORDER, // 18
+        USER_CANCEL_ORDER, // 19
+        INCREASE_EPOCH, // 20
+        CREATE_TSB_TOKEN, // 21
+        REDEEM, // 22
+        WITHDRAW_FEE, // 23
+        EVACUATION, // 24
+        SET_ADMIN_TS_ADDR, // 25
+        ROLL_BORROW_ORDER, // 26
+        ROLL_OVER_START, // 27
+        ROLL_OVER_MATCH, // 28
+        ROLL_OVER_END, // 29
+        USER_CANCEL_ROLL_BORROW, // 30
+        ADMIN_CANCEL_ROLL_BORROW, // 31
+        FORCE_CANCEL_ROLL_BORROW // 32
     }
 
     /// @notice Public data struct definition
     struct Register {
         uint32 accountId;
         bytes20 tsAddr;
     }
 
     struct Deposit {
         uint32 accountId;
         uint16 tokenId;
         uint128 amount;
     }
 
     struct Withdraw {
         uint32 accountId;
         uint16 tokenId;
         uint128 amount;
         uint16 feeTokenId;
         uint128 feeAmt;
     }
 
     struct ForceWithdraw {
         uint32 accountId;
         uint16 tokenId;
         uint128 amount;
     }
 
     struct AuctionEnd {
         uint32 accountId;
-        uint16 tsbTokenId;
         uint16 collateralTokenId;
         uint128 collateralAmt;
+        uint16 debtTokenId;
         uint128 debtAmt;
+        uint32 matchedTime;
+        uint32 maturityTime;
     }
 
     struct CreateTsbToken {
         uint32 maturityTime;
         uint16 baseTokenId;
         uint16 tsbTokenId;
     }
 
     struct WithdrawFee {
         uint16 tokenId;
         uint128 amount;
     }
 
     struct Evacuation {
         uint32 accountId;
         uint16 tokenId;
         uint128 amount;
     }
 
+    struct RollBorrow {
+        uint32 accountId;
+        uint16 collateralTokenId;
+        uint128 maxCollateralAmt;
+        uint32 feeRate; // base is 1e8
+        uint16 borrowTokenId;
+        uint128 maxBorrowAmt;
+        uint32 oldMaturityTime;
+        uint32 newMaturityTime;
+        uint32 expiredTime;
+        uint32 maxPrincipalAndInterestRate; // base is 1e8 (maxPIR)
+    }
+
+    struct RollOverEnd {
+        uint32 accountId;
+        uint16 collateralTokenId;
+        uint128 collateralAmt;
+        uint16 debtTokenId;
+        uint32 oldMaturityTime;
+        uint32 newMaturityTime;
+        uint128 debtAmt;
+        uint32 matchedTime;
+        uint128 borrowAmt;
+    }
+
+    struct CancelRollBorrow {
+        uint32 accountId;
+        uint16 debtTokenId;
+        uint16 collateralTokenId;
+        uint32 maturityTime;
+    }
+
     /* ============ Encode public data function ============ */
 
-    function encodeRegisterPubData(Register memory register) internal pure returns (bytes memory buf) {
+    function encodeRegisterPubData(Register memory register) internal pure returns (bytes memory) {
         return abi.encodePacked(uint8(OpType.REGISTER), register.accountId, register.tsAddr);
     }
 
-    function encodeDepositPubData(Deposit memory deposit) internal pure returns (bytes memory buf) {
+    function encodeDepositPubData(Deposit memory deposit) internal pure returns (bytes memory) {
         return abi.encodePacked(uint8(OpType.DEPOSIT), deposit.accountId, deposit.tokenId, deposit.amount);
     }
 
-    function encodeForceWithdrawPubData(ForceWithdraw memory forceWithdraw) internal pure returns (bytes memory buf) {
+    function encodeForceWithdrawPubData(ForceWithdraw memory forceWithdraw) internal pure returns (bytes memory) {
         return
             abi.encodePacked(uint8(OpType.FORCE_WITHDRAW), forceWithdraw.accountId, forceWithdraw.tokenId, uint128(0));
     }
 
-    function encodeEvacuationPubData(Evacuation memory evacuation) internal pure returns (bytes memory buf) {
+    function encodeEvacuationPubData(Evacuation memory evacuation) internal pure returns (bytes memory) {
         return abi.encodePacked(uint8(OpType.EVACUATION), evacuation.accountId, evacuation.tokenId, evacuation.amount);
     }
 
+    function encodeRollBorrowPubData(RollBorrow memory rollBorrow) internal pure returns (bytes memory) {
+        return
+            abi.encodePacked(
+                uint8(OpType.ROLL_BORROW_ORDER),
+                rollBorrow.accountId,
+                rollBorrow.collateralTokenId,
+                rollBorrow.maxCollateralAmt,
+                rollBorrow.feeRate,
+                rollBorrow.borrowTokenId,
+                rollBorrow.maxBorrowAmt,
+                rollBorrow.oldMaturityTime,
+                rollBorrow.newMaturityTime,
+                rollBorrow.expiredTime,
+                rollBorrow.maxPrincipalAndInterestRate
+            );
+    }
+
+    function encodeForceCancelRollBorrowPubData(
+        CancelRollBorrow memory forceCancelRollBorrow
+    ) internal pure returns (bytes memory) {
+        return
+            abi.encodePacked(
+                uint8(OpType.FORCE_CANCEL_ROLL_BORROW),
+                forceCancelRollBorrow.accountId,
+                forceCancelRollBorrow.debtTokenId,
+                forceCancelRollBorrow.collateralTokenId,
+                forceCancelRollBorrow.maturityTime
+            );
+    }
+
     /* ============ Check hashed public data function ============ */
 
-    function isRegisterHashedPubDataMatched(
-        Register memory op,
-        bytes32 hashedPubData
-    ) internal pure returns (bool isExisted) {
+    function isRegisterHashedPubDataMatched(Register memory op, bytes32 hashedPubData) internal pure returns (bool) {
         return keccak256(encodeRegisterPubData(op)) == hashedPubData;
     }
 
-    function isDepositHashedPubDataMatched(
-        Deposit memory op,
-        bytes32 hashedPubData
-    ) internal pure returns (bool isExisted) {
+    function isDepositHashedPubDataMatched(Deposit memory op, bytes32 hashedPubData) internal pure returns (bool) {
         return keccak256(encodeDepositPubData(op)) == hashedPubData;
     }
 
     function isForceWithdrawHashedPubDataMatched(
         ForceWithdraw memory op,
         bytes32 hashedPubData
-    ) internal pure returns (bool isExisted) {
+    ) internal pure returns (bool) {
         return keccak256(encodeForceWithdrawPubData(op)) == hashedPubData;
     }
 
     function isEvacuationHashedPubDataMatched(
         Evacuation memory op,
         bytes32 hashedPubData
-    ) internal pure returns (bool isExisted) {
+    ) internal pure returns (bool) {
         return keccak256(encodeEvacuationPubData(op)) == hashedPubData;
     }
 
+    function isRollBorrowHashedPubDataMatched(
+        RollBorrow memory op,
+        bytes32 hashedPubData
+    ) internal pure returns (bool) {
+        return keccak256(encodeRollBorrowPubData(op)) == hashedPubData;
+    }
+
+    function isForceCancelRollBorrowHashedPubDataMatched(
+        CancelRollBorrow memory op,
+        bytes32 hashedPubData
+    ) internal pure returns (bool) {
+        return keccak256(encodeForceCancelRollBorrowPubData(op)) == hashedPubData;
+    }
+
     /* ============ Read public data function ============ */
 
-    function readRegisterPubData(bytes memory data) internal pure returns (Register memory register) {
+    function readRegisterPubData(bytes memory data) internal pure returns (Register memory) {
         uint256 offset = Config.BYTES_OF_OP_TYPE;
+        Register memory register;
         (offset, register.accountId) = Bytes.readUInt32(data, offset);
         (, register.tsAddr) = Bytes.readBytes20(data, offset);
+        return register;
     }
 
-    function readDepositPubData(bytes memory data) internal pure returns (Deposit memory deposit) {
+    function readDepositPubData(bytes memory data) internal pure returns (Deposit memory) {
         uint256 offset = Config.BYTES_OF_OP_TYPE;
+        Deposit memory deposit;
         (offset, deposit.accountId) = Bytes.readUInt32(data, offset);
         (offset, deposit.tokenId) = Bytes.readUInt16(data, offset);
         (, deposit.amount) = Bytes.readUInt128(data, offset);
+        return deposit;
     }
 
-    function readWithdrawPubData(bytes memory data) internal pure returns (Withdraw memory withdraw) {
+    function readWithdrawPubData(bytes memory data) internal pure returns (Withdraw memory) {
         uint256 offset = Config.BYTES_OF_OP_TYPE;
+        Withdraw memory withdraw;
         (offset, withdraw.accountId) = Bytes.readUInt32(data, offset);
         (offset, withdraw.tokenId) = Bytes.readUInt16(data, offset);
         (, withdraw.amount) = Bytes.readUInt128(data, offset);
+        return withdraw;
     }
 
-    function readForceWithdrawPubData(bytes memory data) internal pure returns (ForceWithdraw memory forceWithdraw) {
+    function readForceWithdrawPubData(bytes memory data) internal pure returns (ForceWithdraw memory) {
         uint256 offset = Config.BYTES_OF_OP_TYPE;
+        ForceWithdraw memory forceWithdraw;
         (offset, forceWithdraw.accountId) = Bytes.readUInt32(data, offset);
         (offset, forceWithdraw.tokenId) = Bytes.readUInt16(data, offset);
         (, forceWithdraw.amount) = Bytes.readUInt128(data, offset);
+        return forceWithdraw;
     }
 
-    function readAuctionEndPubData(bytes memory data) internal pure returns (AuctionEnd memory auctionEnd) {
+    function readAuctionEndPubData(bytes memory data) internal pure returns (AuctionEnd memory) {
         uint256 offset = Config.BYTES_OF_OP_TYPE;
+        AuctionEnd memory auctionEnd;
         (offset, auctionEnd.accountId) = Bytes.readUInt32(data, offset);
         (offset, auctionEnd.collateralTokenId) = Bytes.readUInt16(data, offset);
         (offset, auctionEnd.collateralAmt) = Bytes.readUInt128(data, offset);
-        (offset, auctionEnd.tsbTokenId) = Bytes.readUInt16(data, offset);
-        (, auctionEnd.debtAmt) = Bytes.readUInt128(data, offset);
+        (offset, auctionEnd.debtTokenId) = Bytes.readUInt16(data, offset);
+        (offset, auctionEnd.debtAmt) = Bytes.readUInt128(data, offset);
+        (offset, auctionEnd.matchedTime) = Bytes.readUInt32(data, offset);
+        (, auctionEnd.maturityTime) = Bytes.readUInt32(data, offset);
+        return auctionEnd;
     }
 
-    function readCreateTsbTokenPubData(bytes memory data) internal pure returns (CreateTsbToken memory createTsbToken) {
+    function readCreateTsbTokenPubData(bytes memory data) internal pure returns (CreateTsbToken memory) {
         uint256 offset = Config.BYTES_OF_OP_TYPE;
+        CreateTsbToken memory createTsbToken;
         (offset, createTsbToken.maturityTime) = Bytes.readUInt32(data, offset);
         (offset, createTsbToken.baseTokenId) = Bytes.readUInt16(data, offset);
         (, createTsbToken.tsbTokenId) = Bytes.readUInt16(data, offset);
+        return createTsbToken;
     }
 
-    function readWithdrawFeePubdata(bytes memory data) internal pure returns (WithdrawFee memory withdrawFee) {
+    function readWithdrawFeePubdata(bytes memory data) internal pure returns (WithdrawFee memory) {
         uint256 offset = Config.BYTES_OF_OP_TYPE;
+        WithdrawFee memory withdrawFee;
         (offset, withdrawFee.tokenId) = Bytes.readUInt16(data, offset);
         (, withdrawFee.amount) = Bytes.readUInt128(data, offset);
+        return withdrawFee;
     }
 
-    function readEvacuationPubdata(bytes memory data) internal pure returns (Evacuation memory evacuation) {
+    function readEvacuationPubdata(bytes memory data) internal pure returns (Evacuation memory) {
         uint256 offset = Config.BYTES_OF_OP_TYPE;
+        Evacuation memory evacuation;
         (offset, evacuation.accountId) = Bytes.readUInt32(data, offset);
         (offset, evacuation.tokenId) = Bytes.readUInt16(data, offset);
         (, evacuation.amount) = Bytes.readUInt128(data, offset);
+        return evacuation;
+    }
+
+    function readRollBorrowPubdata(bytes memory data) internal pure returns (RollBorrow memory) {
+        uint256 offset = Config.BYTES_OF_OP_TYPE;
+        RollBorrow memory rollBorrow;
+        (offset, rollBorrow.accountId) = Bytes.readUInt32(data, offset);
+        (offset, rollBorrow.collateralTokenId) = Bytes.readUInt16(data, offset);
+        (offset, rollBorrow.maxCollateralAmt) = Bytes.readUInt128(data, offset);
+        (offset, rollBorrow.feeRate) = Bytes.readUInt32(data, offset);
+        (offset, rollBorrow.borrowTokenId) = Bytes.readUInt16(data, offset);
+        (offset, rollBorrow.maxBorrowAmt) = Bytes.readUInt128(data, offset);
+        (offset, rollBorrow.oldMaturityTime) = Bytes.readUInt32(data, offset);
+        (offset, rollBorrow.newMaturityTime) = Bytes.readUInt32(data, offset);
+        (offset, rollBorrow.expiredTime) = Bytes.readUInt32(data, offset);
+        (, rollBorrow.maxPrincipalAndInterestRate) = Bytes.readUInt32(data, offset);
+        return rollBorrow;
+    }
+
+    function readRollOverEndPubdata(bytes memory data) internal pure returns (RollOverEnd memory) {
+        uint256 offset = Config.BYTES_OF_OP_TYPE;
+        RollOverEnd memory rollOverEnd;
+        (offset, rollOverEnd.accountId) = Bytes.readUInt32(data, offset);
+        (offset, rollOverEnd.collateralTokenId) = Bytes.readUInt16(data, offset);
+        (offset, rollOverEnd.collateralAmt) = Bytes.readUInt128(data, offset);
+        (offset, rollOverEnd.debtTokenId) = Bytes.readUInt16(data, offset);
+        (offset, rollOverEnd.oldMaturityTime) = Bytes.readUInt32(data, offset);
+        (offset, rollOverEnd.newMaturityTime) = Bytes.readUInt32(data, offset);
+        (offset, rollOverEnd.debtAmt) = Bytes.readUInt128(data, offset);
+        (offset, rollOverEnd.matchedTime) = Bytes.readUInt32(data, offset);
+        (, rollOverEnd.borrowAmt) = Bytes.readUInt128(data, offset);
+        return rollOverEnd;
+    }
+
+    function readCancelRollBorrowPubdata(bytes memory data) internal pure returns (CancelRollBorrow memory) {
+        uint256 offset = Config.BYTES_OF_OP_TYPE;
+        CancelRollBorrow memory cancelRollBorrow;
+        (offset, cancelRollBorrow.accountId) = Bytes.readUInt32(data, offset);
+        (offset, cancelRollBorrow.debtTokenId) = Bytes.readUInt16(data, offset);
+        (offset, cancelRollBorrow.collateralTokenId) = Bytes.readUInt16(data, offset);
+        (, cancelRollBorrow.maturityTime) = Bytes.readUInt32(data, offset);
+        return cancelRollBorrow;
     }
 }
diff --git a/contracts/zkTrueUp/libraries/Signature.sol b/contracts/zkTrueUp/libraries/Signature.sol
new file mode 100644
index 0000000..308b654
--- /dev/null
+++ b/contracts/zkTrueUp/libraries/Signature.sol
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.17;
+
+import {ECDSA} from "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";
+
+//! mainnet-audit
+/**
+ * @title Signature related library
+ * @author Term Structure Labs
+ * @notice The mutated EIP712 library for diamond proxy standard
+ *         Part of source code is referenced from
+ *         https://github.com/solidstate-network/solidstate-solidity/blob/master/contracts/cryptography/EIP712.sol &
+ *         https://github.com/OpenZeppelin/openzeppelin-contracts/tree/master/contracts/utils/cryptography
+ */
+library Signature {
+    error InvalidSignature(address signer, address expectedSigner);
+
+    error SignatureExpired(uint256 deadline, uint256 currentTime);
+
+    bytes32 internal constant EIP712_TYPE_HASH =
+        keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
+
+    bytes32 internal constant EIP712_NAME_HASH = keccak256(bytes("ZkTrueUp"));
+
+    bytes32 internal constant EIP712_VERSION_HASH = keccak256(bytes("1"));
+
+    function verifyDeadline(uint256 deadline) internal view {
+        if (deadline < block.timestamp) revert SignatureExpired(deadline, block.timestamp);
+    }
+
+    function verifySignature(address expectedSigner, bytes32 structHash, uint8 v, bytes32 r, bytes32 s) internal view {
+        bytes32 digest = hashTypedDataV4(structHash);
+        address signer = ECDSA.recover(digest, v, r, s);
+        if (signer != expectedSigner) revert InvalidSignature(signer, expectedSigner);
+    }
+
+    function hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {
+        return toTypedDataHash(calcDomainSeparator(), structHash);
+    }
+
+    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            let ptr := mload(0x40)
+            mstore(ptr, hex"19_01")
+            mstore(add(ptr, 0x02), domainSeparator)
+            mstore(add(ptr, 0x22), structHash)
+            digest := keccak256(ptr, 0x42)
+        }
+    }
+
+    function calcDomainSeparator() internal view returns (bytes32 domainSeparator) {
+        bytes32 typeHash = EIP712_TYPE_HASH;
+        bytes32 nameHash = EIP712_NAME_HASH;
+        bytes32 versionHash = EIP712_VERSION_HASH;
+
+        // solhint-disable-next-line no-inline-assembly
+        assembly {
+            // load free memory pointer
+            let pointer := mload(0x40)
+
+            mstore(pointer, typeHash)
+            mstore(add(pointer, 32), nameHash)
+            mstore(add(pointer, 64), versionHash)
+            mstore(add(pointer, 96), chainid())
+            mstore(add(pointer, 128), address())
+
+            domainSeparator := keccak256(pointer, 160)
+
+            // equivalent solidity code:
+            // keccak256(
+            //   abi.encode(
+            //     typeHash,
+            //     nameHash,
+            //     versionHash,
+            //     block.chainid,
+            //     address(this)
+            //   )
+            // );
+        }
+    }
+}
diff --git a/contracts/zkTrueUp/libraries/Utils.sol b/contracts/zkTrueUp/libraries/Utils.sol
index a57f2b4..6e55f23 100644
--- a/contracts/zkTrueUp/libraries/Utils.sol
+++ b/contracts/zkTrueUp/libraries/Utils.sol
@@ -1,128 +1,135 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
 import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
 import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
 import {AggregatorV3Interface} from "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol";
 import {SafeCast} from "@solidstate/contracts/utils/SafeCast.sol";
 import {AddressStorage} from "../address/AddressStorage.sol";
 import {AddressLib} from "../address/AddressLib.sol";
 import {TsbLib} from "../tsb/TsbLib.sol";
 import {ITsbToken} from "../interfaces/ITsbToken.sol";
 import {Config} from "../libraries/Config.sol";
 
 /**
  * @title Utils Library
  * @author Term Structure Labs
  * @notice Utility functions for zkTrueUp
  */
 library Utils {
     using Math for *;
     using SafeERC20 for IERC20;
     using AddressLib for AddressStorage.Layout;
 
     /// @notice Error for get zero address
     error InvalidZeroAddr(address addr);
     /// @notice Error for transfer
     error TransferFailed(address receiver, uint256 amount, bytes data);
     /// @notice Error for invalid msg.value
     error InvalidMsgValue(uint256 msgValue);
     /// @notice Error for get invalid price
     error InvalidPrice(int256 price);
     /// @notice Error for transferFrom amount inconsistent when transferFrom non-standard ERC20
     error AmountInconsistent(uint256 amount, uint256 transferredAmt);
 
     /// @notice Internal token transfer function to handle the case of Tsb Token or Base Token
     ///         if the token is Tsb Token, then mint Tsb Token to receiver, otherwise transfer the token to receiver
     /// @param token The token to be transferred
     /// @param to The address of receiver
     /// @param amount The amount of the token
     /// @param isTsbToken The flag to indicate whether the token is Tsb Token
     function tokenTransfer(IERC20 token, address payable to, uint256 amount, bool isTsbToken) internal {
         isTsbToken ? TsbLib.mintTsbToken(ITsbToken(address(token)), to, amount) : transfer(token, to, amount);
     }
 
     /// @notice Internal token transferFrom function to handle the case of Tsb Token or Base Token
     ///         if the token is Tsb Token, then burn Tsb Token from sender, otherwise transferFrom the token from sender
     /// @param token The token to be transferred
     /// @param from The address of sender
     /// @param amount The amount of the token
     /// @param msgValue The msg.value
     /// @param isTsbToken The flag to indicate whether the token is Tsb Token
     function tokenTransferFrom(IERC20 token, address from, uint256 amount, uint256 msgValue, bool isTsbToken) internal {
         isTsbToken
             ? TsbLib.burnTsbToken(ITsbToken(address(token)), from, amount)
             : transferFrom(token, from, amount, msgValue);
     }
 
     /// @notice Internal transfer function
     /// @dev Mutated transfer function to handle the case of ETH and ERC20
     /// @param token The token to be transferred
     /// @param receiver The address of receiver
     /// @param amount The amount of the token
     function transfer(IERC20 token, address payable receiver, uint256 amount) internal {
         if (address(token) == Config.ETH_ADDRESS) {
             AddressStorage.layout().getWETH().withdraw(amount);
-            (bool success, bytes memory data) = receiver.call{value: amount}("");
-            if (!success) revert TransferFailed(receiver, amount, data);
+            transferNativeToken(receiver, amount);
         } else {
             token.safeTransfer(receiver, amount);
         }
     }
 
     /// @notice Internal transferFrom function
     /// @dev Mutated transferFrom function to handle the case of ETH and ERC20 to zkTrueUp contract
     /// @param token The token to be transferred
     /// @param sender The address of sender
     /// @param amount The amount of the token
     /// @param msgValue The msg.value
     function transferFrom(IERC20 token, address sender, uint256 amount, uint256 msgValue) internal {
         if (address(token) == Config.ETH_ADDRESS) {
             if (msgValue != amount) revert InvalidMsgValue(msgValue);
             AddressStorage.layout().getWETH().deposit{value: amount}();
         } else {
             if (msgValue != 0) revert InvalidMsgValue(msgValue);
             uint256 balanceBefore = token.balanceOf(address(this));
             token.safeTransferFrom(sender, address(this), amount);
             uint256 balanceAfter = token.balanceOf(address(this));
             uint256 transferredAmt = balanceAfter - balanceBefore;
             if (amount != transferredAmt) revert AmountInconsistent(amount, transferredAmt);
         }
     }
 
+    /// @notice Internal transfer native token function
+    /// @param receiver The address of receiver
+    /// @param amount The amount of the token
+    function transferNativeToken(address payable receiver, uint256 amount) internal {
+        (bool success, bytes memory data) = receiver.call{value: amount}("");
+        if (!success) revert TransferFailed(receiver, amount, data);
+    }
+
     /// @notice Internal function to get the price from price feed contract
     /// @dev The price is normalized to 18 decimals
     /// @param priceFeed The address of the price feed
     /// @return normalizedPirce The price with 18 decimals
     function getPrice(AggregatorV3Interface priceFeed) internal view returns (uint256) {
         notZeroAddr(address(priceFeed));
         uint8 decimals = priceFeed.decimals();
         (, int256 price, , , ) = priceFeed.latestRoundData();
         if (price <= 0) revert InvalidPrice(price);
 
         return uint256(price) * 10 ** (18 - decimals);
     }
 
     /// @notice Internal function to check the address is not zero address
     /// @param addr The address to be checked
     function notZeroAddr(address addr) internal pure {
         if (addr == address(0)) revert InvalidZeroAddr(addr);
     }
 
     /// @notice Internal function to convert L2 amount to L1 amount
     /// @param l2Amt The amount in L2
     /// @param decimals The decimals of the token
     /// @return The amount in L1
     function toL1Amt(uint128 l2Amt, uint8 decimals) internal pure returns (uint256) {
-        return l2Amt.mulDiv(10 ** decimals, 10 ** Config.SYSTEM_DECIMALS);
+        return l2Amt.mulDiv(10 ** decimals, Config.SYSTEM_UNIT_BASE);
     }
 
     /// @notice Internal function to convert L1 amount to L2 amount
     /// @param l1Amt The amount in L1
     /// @param decimals The decimals of the token
     /// @return The amount in L2
     function toL2Amt(uint256 l1Amt, uint8 decimals) internal pure returns (uint128) {
-        return SafeCast.toUint128(l1Amt.mulDiv(10 ** Config.SYSTEM_DECIMALS, 10 ** decimals));
+        return SafeCast.toUint128(l1Amt.mulDiv(Config.SYSTEM_UNIT_BASE, 10 ** decimals));
     }
 }
diff --git a/contracts/zkTrueUp/loan/ILoanFacet.sol b/contracts/zkTrueUp/loan/ILoanFacet.sol
index ee4bc15..60daef0 100644
--- a/contracts/zkTrueUp/loan/ILoanFacet.sol
+++ b/contracts/zkTrueUp/loan/ILoanFacet.sol
@@ -1,231 +1,385 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
 import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
-import {LiquidationFactor, Loan} from "./LoanStorage.sol";
+import {LiquidationFactor, Loan, RollBorrowOrder} from "./LoanStorage.sol";
+import {Operations} from "../libraries/Operations.sol";
 
 /**
  * @title Term Structure Loan Facet Interface
  * @author Term Structure Labs
  */
 interface ILoanFacet {
+    /// @notice Error for invalid tsb token address
+    error InvalidTsbTokenAddr(address tsbTokenAddr);
+    /// @notice Error for invalid expiration time
+    error InvalidExpiredTime(uint32 expiredTime);
     /// @notice Error for setting invalid liquidation factor
     error InvalidLiquidationFactor(LiquidationFactor liquidationFactor);
     /// @notice Error for liquidate the loan which is safe
     error LoanIsSafe(uint256 healthFactor, uint32 maturityTime);
     /// @notice Error for liquidate the loan with invalid repay amount
     error RepayAmtExceedsMaxRepayAmt(uint128 repayAmt, uint128 maxRepayAmt);
     /// @notice Error for supply to Aave with string reason
     error SupplyToAaveFailedLogString(IERC20 collateralToken, uint128 collateralAmt, string reason);
     /// @notice Error for supply to Aave with bytes reason
     error SupplyToAaveFailedLogBytes(IERC20 collateralToken, uint128 collateralAmt, bytes reason);
     /// @notice Error for borrow from Aave with string reason
     error BorrowFromAaveFailedLogString(
         IERC20 collateralToken,
         uint128 collateralAmt,
         IERC20 debtToken,
         uint128 debtAmt,
         string reason
     );
     /// @notice Error for borrow from Aave with bytes reason
     error BorrowFromAaveFailedLogBytes(
         IERC20 collateralToken,
         uint128 collateralAmt,
         IERC20 debtToken,
         uint128 debtAmt,
         bytes reason
     );
     /// @notice Error for use roll when it is not activated
     error RollIsNotActivated();
+    /// @notice Error for roll borrow a locked loan
+    error LoanIsLocked(bytes12 loanId);
+    /// @notice Error for roll borrow with invalid roll borrow fee
+    error InvalidRollBorrowFee(uint256 rollBorrowFee);
+    /// @notice Error for roll borrow with invalid maturity time
+    error InvalidMaturityTime(uint32 maturityTime);
+    /// @notice Error for cancel roll borrow order with unlocked loan
+    error LoanIsNotLocked(bytes12 loanId);
 
     /// @notice Emitted when borrower add collateral
     /// @param loanId The id of the loan
-    /// @param sender The address of the sender
+    /// @param caller The address of the `msg.sender`
+    /// @param loanOwner The address of the loan owner
     /// @param collateralToken The collateral token to add
     /// @param addedCollateralAmt The amount of the added collateral
     event CollateralAdded(
         bytes12 indexed loanId,
-        address indexed sender,
+        address caller,
+        address loanOwner,
         IERC20 collateralToken,
         uint128 addedCollateralAmt
     );
 
     /// @notice Emitted when borrower remove collateral
     /// @param loanId The id of the loan
-    /// @param sender The address of the sender
+    /// @param caller The address of the `msg.sender`
+    /// @param loanOwner The address of the loan owner
     /// @param collateralToken The collateral token to remove
     /// @param removedCollateralAmt The amount of the removed collateral
     event CollateralRemoved(
         bytes12 indexed loanId,
-        address indexed sender,
+        address caller,
+        address loanOwner,
         IERC20 collateralToken,
         uint128 removedCollateralAmt
     );
 
     /// @notice Emitted when the borrower repay the loan
     /// @param loanId The id of the loan
-    /// @param sender The address of the sender
+    /// @param caller The address of the `msg.sender`
+    /// @param loanOwner The address of the loan owner
     /// @param collateralToken The collateral token to be taken
     /// @param debtToken The debt token to be repaid
     /// @param removedCollateralAmt The amount of the removed collateral
     /// @param removedDebtAmt The amount of the removed debt
     /// @param repayAndDeposit Whether to deposit the collateral after repay the loan
     event Repayment(
         bytes12 indexed loanId,
-        address indexed sender,
+        address caller,
+        address loanOwner,
         IERC20 collateralToken,
         IERC20 debtToken,
         uint128 removedCollateralAmt,
         uint128 removedDebtAmt,
         bool repayAndDeposit
     );
 
     /// @notice Emitted when the loan is rolled to Aave
     /// @param loanId The id of the loan
-    /// @param sender The address of the sender
+    /// @param caller The address of the `msg.sender`
+    /// @param loanOwner The address of the loan owner
     /// @param supplyToken The token to be supplied to Aave
     /// @param borrowToken The token to be borrowed from Aave
     /// @param collateralAmt The amount of the collateral
     /// @param debtAmt The amount of the debt
     event RollToAave(
         bytes12 indexed loanId,
-        address indexed sender,
+        address caller,
+        address loanOwner,
         IERC20 supplyToken,
         IERC20 borrowToken,
         uint128 collateralAmt,
         uint128 debtAmt
     );
 
+    /// @notice Emitted when the borrower place a roll borrow order
+    /// @param loanId The id of the loan
+    /// @param caller The address of the `msg.sender`
+    /// @param loanOwner The address of the loan owner
+    /// @param rollBorrowReq The roll borrow request
+    event RollBorrowOrderPlaced(
+        bytes12 indexed loanId,
+        address caller,
+        address loanOwner,
+        Operations.RollBorrow rollBorrowReq
+    );
+
+    /// @notice Emitted when the borrower force cancel a roll borrow order on L1
+    /// @param loanId The id of the loan
+    /// @param caller The address of the `msg.sender`
+    /// @param loanOwner The address of the loan owner
+    event RollBorrowOrderForceCancelPlaced(bytes12 indexed loanId, address caller, address loanOwner);
+
     /// @notice Emitted when the loan is liquidated
     /// @param loanId The id of the loan
     /// @param liquidator The address of the liquidator
     /// @param collateralToken The collateral token to be taken
     /// @param liquidatorReward The reward of the liquidator
     /// @param protocolPenalty The penalty of the protocol
     event Liquidation(
         bytes12 indexed loanId,
         address indexed liquidator,
         IERC20 collateralToken,
         uint128 liquidatorReward,
         uint128 protocolPenalty
     );
 
     /// @notice Emitted when the half liquidation threshold is set
     /// @param halfLiquidationThreshold The half liquidation threshold
     event SetHalfLiquidationThreshold(uint16 indexed halfLiquidationThreshold);
 
     /// @notice Emitted when the liquidation factor is set
     /// @param liquidationFactor The liquidation factor
     /// @param isStableCoinPair Whether the liquidation factor is for stablecoin pair
     event SetLiquidationFactor(LiquidationFactor indexed liquidationFactor, bool indexed isStableCoinPair);
 
     /// @notice Emitted when the roll activation is set
     /// @param isActivatedRoll Whether the roll activation is set
     event SetActivatedRoller(bool isActivatedRoll);
 
+    /// @notice Emitted when the borrow fee rate is set
+    /// @param borrowFeeRate The borrow fee rate
+    event SetBorrowFeeRate(uint32 indexed borrowFeeRate);
+
+    /// @notice Emitted when the roll over fee is set
+    /// @param rollOverFee The roll over fee
+    event SetRollOverFee(uint256 indexed rollOverFee);
+
     /// @notice Add collateral to the loan
     /// @param loanId The id of the loan
     /// @param amount The amount of the collateral
     function addCollateral(bytes12 loanId, uint128 amount) external payable;
 
     /// @notice Remove collateral from the loan
     /// @param loanId The id of the loan
     /// @param amount The amount of the collateral
     function removeCollateral(bytes12 loanId, uint128 amount) external;
 
-    /// @notice Repay the loan, only the loan owner can repay the loan
+    //! mainnet-audit
+    /// @notice Remove collateral from the loan with permit signature
+    /// @param loanId The id of the loan
+    /// @param amount The amount of the collateral
+    /// @param deadline The deadline of the signature
+    /// @param v The recovery id of the signature
+    /// @param r The r value of the signature
+    /// @param s The s value of the signature
+    function removeCollateralWithPermit(
+        bytes12 loanId,
+        uint128 amount,
+        uint256 deadline,
+        uint8 v,
+        bytes32 r,
+        bytes32 s
+    ) external;
+
+    /// @notice Repay the loan
     /// @param loanId The id of the loan
     /// @param collateralAmt The amount of collateral to be returned
     /// @param debtAmt The amount of debt to be repaid
     /// @param repayAndDeposit Whether to deposit the collateral after repay the loan
     function repay(bytes12 loanId, uint128 collateralAmt, uint128 debtAmt, bool repayAndDeposit) external payable;
 
+    //! mainnet-audit
+    /// @notice Repay the loan with permit signature
+    /// @param loanId The id of the loan
+    /// @param collateralAmt The amount of collateral to be returned
+    /// @param debtAmt The amount of debt to be repaid
+    /// @param repayAndDeposit Whether to deposit the collateral after repay the loan
+    /// @param deadline The deadline of the signature
+    /// @param v The recovery id of the signature
+    /// @param r The r value of the signature
+    /// @param s The s value of the signature
+    function repayWithPermit(
+        bytes12 loanId,
+        uint128 collateralAmt,
+        uint128 debtAmt,
+        bool repayAndDeposit,
+        uint256 deadline,
+        uint8 v,
+        bytes32 r,
+        bytes32 s
+    ) external payable;
+
     /// @notice Roll the loan to Aave
     /// @param loanId The id of the loan
     /// @param collateralAmt The amount of collateral to be returned
     /// @param debtAmt The amount of debt to be repaid
     function rollToAave(bytes12 loanId, uint128 collateralAmt, uint128 debtAmt) external;
 
+    //! mainnet-audit
+    /// @notice Roll the loan to Aave with permit signature
+    /// @param loanId The id of the loan
+    /// @param collateralAmt The amount of collateral to be returned
+    /// @param debtAmt The amount of debt to be repaid
+    /// @param deadline The deadline of the signature
+    /// @param v The recovery id of the signature
+    /// @param r The r value of the signature
+    /// @param s The s value of the signature
+    function rollToAaveWithPermit(
+        bytes12 loanId,
+        uint128 collateralAmt,
+        uint128 debtAmt,
+        uint256 deadline,
+        uint8 v,
+        bytes32 r,
+        bytes32 s
+    ) external;
+
+    /// @notice Place a roll borrow order
+    /// @notice User want to roll the original loan to a new loan without repay
+    /// @notice The roll borrow is an action to place a borrow order on L1,
+    ///         and the order is waiting to be matched on L2 and rollup will create a new loan on L1 once matched
+    /// @param rollBorrowOrder The roll borrow order
+    function rollBorrow(RollBorrowOrder memory rollBorrowOrder) external payable;
+
+    //! mainnet-audit
+    /// @notice Place a roll borrow order with permit signature
+    /// @notice User want to roll the original loan to a new loan without repay
+    /// @notice The roll borrow is an action to place a borrow order on L1,
+    ///         and the order is waiting to be matched on L2 and rollup will create a new loan on L1 once matched
+    /// @param rollBorrowOrder The roll borrow order
+    function rollBorrowWithPermit(
+        RollBorrowOrder memory rollBorrowOrder,
+        uint256 deadline,
+        uint8 v,
+        bytes32 r,
+        bytes32 s
+    ) external payable;
+
+    /// @notice Cancel the roll borrow order
+    /// @notice User can force cancel their roll borrow order on L1
+    ///         to avoid sequencer ignore his cancel request in L2
+    /// @param loanId The id of the loan to be cancelled
+    function forceCancelRollBorrow(bytes12 loanId) external;
+
+    //! mainnet-audit
+    /// @notice Cancel the roll borrow order with permit signature
+    /// @notice User can force cancel their roll borrow order on L1
+    ///         to avoid sequencer ignore his cancel request in L2
+    /// @param loanId The id of the loan to be cancelled
+    function forceCancelRollBorrowWithPermit(bytes12 loanId, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;
+
     /// @notice Liquidate the loan
     /// @param loanId The id of the loan to be liquidated
     /// @param repayAmt The amount of debt to be repaid
     /// @return liquidatorRewardAmt The amount of collateral to be returned to the liquidator
     /// @return protocolPenaltyAmt The amount of collateral to be returned to the protocol
     function liquidate(
         bytes12 loanId,
         uint128 repayAmt
     ) external payable returns (uint128 liquidatorRewardAmt, uint128 protocolPenaltyAmt);
 
     /// @notice Set the half liquidation threshold
     /// @dev The half liquidation threshold is the threshold of the liquidation price (USD),
     ///      the initial value 1e4 i.e. 10000 USD
     /// @param halfLiquidationThreshold The half liquidation threshold
     function setHalfLiquidationThreshold(uint16 halfLiquidationThreshold) external;
 
     /// @notice Set the liquidation factor
     /// @param liquidationFactor The liquidation factor
     /// @param isStableCoinPair Whether the liquidation factor is for stablecoin pair
     function setLiquidationFactor(LiquidationFactor memory liquidationFactor, bool isStableCoinPair) external;
 
     /// @notice Set the roll function activation
     /// @param isActivated The roll function activation
     function setActivatedRoller(bool isActivated) external;
 
+    /// @notice Set the borrow fee rate
+    /// @param borrowFeeRate The borrow fee rate
+    function setBorrowFeeRate(uint32 borrowFeeRate) external;
+
+    /// @notice Set the fee of the roll borrow service
+    /// @param rollOverFee The roll over fee
+    function setRollOverFee(uint256 rollOverFee) external;
+
     /// @notice Return the health factor of the loan
     /// @param loanId The id of the loan
     /// @return healthFactor The health factor of the loan
     function getHealthFactor(bytes12 loanId) external view returns (uint256 healthFactor);
 
     /// @notice Return the half liquidation threshold
     /// @dev The halfLiquidationThreshold is the threshold of the liquidation price (USD), i.e. 1e4 = 10000 USD
     /// @return halfLiquidationThreshold The half liquidation threshold
     function getHalfLiquidationThreshold() external view returns (uint16 halfLiquidationThreshold);
 
     /// @notice Return the liquidation factor
     /// @param isStableCoinPair Whether the liquidation factor is for stablecoin pair
     /// @return liquidationFactor The liquidation factor
     function getLiquidationFactor(
         bool isStableCoinPair
     ) external view returns (LiquidationFactor memory liquidationFactor);
 
     /// @notice Return the loan by the loan id
     /// @param loanId The id of the loan
     /// @return loan The loan
     function getLoan(bytes12 loanId) external view returns (Loan memory loan);
 
     /// @notice Return the liquidation info of the loan
     /// @param loanId The id of the loan
     /// @return _isLiquidable Whether the loan is liquidable
     /// @return debtToken The debt token of the loan
     /// @return maxRepayAmt The maximum amount of the debt to be repaid
     function getLiquidationInfo(
         bytes12 loanId
     ) external view returns (bool _isLiquidable, IERC20 debtToken, uint128 maxRepayAmt);
 
+    /// @notice Return the borrow fee rate
+    /// @return borrowFeeRate The borrow fee rate
+    function getBorrowFeeRate() external view returns (uint32);
+
+    /// @notice Return the fee of the roll borrow service
+    /// @return rollOverFee The roll over fee
+    function getRollOverFee() external view returns (uint256);
+
     /// @notice Check if the roll function is activated
     /// @return isActivate If the roll function is activated
     function isActivatedRoller() external view returns (bool isActivate);
 
     /// @notice Return the loan id by the loan info
     /// @param accountId The id of the account
     /// @param maturityTime The maturity time of the loan
     /// @param debtTokenId The id of the debt token
     /// @param collateralTokenId The id of the collateral token
     /// @return loanId The id of the loan
     function getLoanId(
         uint32 accountId,
         uint32 maturityTime,
         uint16 debtTokenId,
         uint16 collateralTokenId
     ) external pure returns (bytes12 loanId);
 
     /// @notice Resolve the loan id
     /// @param loanId The loan id
     /// @return accountId The account id
     /// @return maturityTime The maturity time
     /// @return debtTokenId The debt token id
     /// @return collateralTokenId The collateral token id
     function resolveLoanId(
         bytes12 loanId
     ) external pure returns (uint32 accountId, uint32 maturityTime, uint16 debtTokenId, uint16 collateralTokenId);
 }
diff --git a/contracts/zkTrueUp/loan/LoanFacet.sol b/contracts/zkTrueUp/loan/LoanFacet.sol
index 23d9a36..c02047c 100644
--- a/contracts/zkTrueUp/loan/LoanFacet.sol
+++ b/contracts/zkTrueUp/loan/LoanFacet.sol
@@ -1,473 +1,1062 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
 import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
 import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
 import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
 import {AccessControlInternal} from "@solidstate/contracts/access/access_control/AccessControlInternal.sol";
 import {ReentrancyGuard} from "@solidstate/contracts/security/reentrancy_guard/ReentrancyGuard.sol";
 import {AccountStorage} from "../account/AccountStorage.sol";
 import {AddressStorage} from "../address/AddressStorage.sol";
 import {ProtocolParamsStorage} from "../protocolParams/ProtocolParamsStorage.sol";
 import {RollupStorage} from "../rollup/RollupStorage.sol";
 import {TokenStorage} from "../token/TokenStorage.sol";
 import {IPool} from "../interfaces/aaveV3/IPool.sol";
+import {ITsbToken} from "../interfaces/ITsbToken.sol";
 import {ILoanFacet} from "./ILoanFacet.sol";
 import {ProtocolParamsLib} from "../protocolParams/ProtocolParamsLib.sol";
 import {AccountLib} from "../account/AccountLib.sol";
 import {AddressLib} from "../address/AddressLib.sol";
 import {TokenLib} from "../token/TokenLib.sol";
-import {RollupLib} from "../rollup/RollupLib.sol";
 import {LoanLib} from "./LoanLib.sol";
 import {AssetConfig} from "../token/TokenStorage.sol";
-import {LoanStorage, LiquidationFactor, Loan, LiquidationAmt, LoanInfo} from "./LoanStorage.sol";
+import {Operations} from "../libraries/Operations.sol";
 import {Config} from "../libraries/Config.sol";
 import {Utils} from "../libraries/Utils.sol";
+import {LoanStorage, LiquidationFactor, Loan, LiquidationAmt, LoanInfo, RollBorrowOrder, REMOVE_COLLATERAL_TYPEHASH, REPAY_TYPEHASH, ROLL_BORROW_TYPEHASH, FORCE_CANCEL_ROLL_BORROW_TYPEHASH, ROLL_TO_AAVE_TYPEHASH} from "./LoanStorage.sol";
+import {DELEGATE_REMOVE_COLLATERAL_MASK, DELEGATE_REPAY_MASK, DELEGATE_ROLL_TO_AAVE_MASK, DELEGATE_ROLL_BORROW_MASK, DELEGATE_FORCE_CANCEL_ROLL_BORROW_MASK} from "../libraries/Delegate.sol";
 
 /**
  * @title Term Structure Loan Facet Contract
  * @author Term Structure Labs
  * @notice The LoanFacet is a contract to manages loans in Term Structure Protocol
  */
 contract LoanFacet is ILoanFacet, AccessControlInternal, ReentrancyGuard {
     using SafeERC20 for IERC20;
     using AccountLib for AccountStorage.Layout;
     using AddressLib for AddressStorage.Layout;
     using ProtocolParamsLib for ProtocolParamsStorage.Layout;
     using TokenLib for TokenStorage.Layout;
+    using SafeCast for uint256;
     using Math for *;
     using LoanLib for *;
+    using Utils for *;
 
     /* ============ External Functions ============ */
 
     /**
      * @inheritdoc ILoanFacet
      * @dev Anyone can add collateral to the loan
      */
     function addCollateral(bytes12 loanId, uint128 amount) external payable {
         LoanStorage.Layout storage lsl = LoanStorage.layout();
         LoanInfo memory loanInfo = lsl.getLoanInfo(loanId);
+        address loanOwner = AccountStorage.layout().getAccountAddr(loanInfo.accountId);
+
         IERC20 collateralToken = loanInfo.collateralAsset.token;
         Utils.transferFrom(collateralToken, msg.sender, amount, msg.value);
 
         Loan memory loan = loanInfo.loan;
-        loan = loan.addCollateral(amount);
+        loan.addCollateral(amount);
         lsl.loans[loanId] = loan;
-        emit CollateralAdded(loanId, msg.sender, collateralToken, amount);
+        emit CollateralAdded(loanId, msg.sender, loanOwner, collateralToken, amount);
     }
 
     /**
      * @inheritdoc ILoanFacet
      */
     function removeCollateral(bytes12 loanId, uint128 amount) external nonReentrant {
         LoanStorage.Layout storage lsl = LoanStorage.layout();
         LoanInfo memory loanInfo = lsl.getLoanInfo(loanId);
-        msg.sender.requireLoanOwner(loanInfo);
-
-        Loan memory loan = loanInfo.loan;
-        loan = loan.removeCollateral(amount);
-        loan.requireHealthy(loanInfo);
+        AccountStorage.Layout storage asl = AccountStorage.layout();
+        address loanOwner = asl.getAccountAddr(loanInfo.accountId);
+        asl.requireValidCaller(msg.sender, loanOwner, DELEGATE_REMOVE_COLLATERAL_MASK);
 
-        lsl.loans[loanId] = loan;
-        IERC20 collateralToken = loanInfo.collateralAsset.token;
-        Utils.transfer(collateralToken, payable(msg.sender), amount);
-        emit CollateralRemoved(loanId, msg.sender, collateralToken, amount);
+        _removeCollateral(lsl, loanInfo, loanId, msg.sender, loanOwner, amount);
     }
 
+    //! mainnet-audit
     /**
      * @inheritdoc ILoanFacet
      */
-    function repay(bytes12 loanId, uint128 collateralAmt, uint128 debtAmt, bool repayAndDeposit) external payable {
-        (IERC20 collateralToken, uint32 accountId) = _repay(loanId, collateralAmt, debtAmt, repayAndDeposit);
+    function removeCollateralWithPermit(
+        bytes12 loanId,
+        uint128 amount,
+        uint256 deadline,
+        uint8 v,
+        bytes32 r,
+        bytes32 s
+    ) external nonReentrant {
+        LoanStorage.Layout storage lsl = LoanStorage.layout();
+        LoanInfo memory loanInfo = lsl.getLoanInfo(loanId);
+        address loanOwner;
 
-        if (repayAndDeposit) {
-            TokenStorage.Layout storage tsl = TokenStorage.layout();
-            (uint16 tokenId, AssetConfig memory assetConfig) = tsl.getValidToken(collateralToken);
-            TokenLib.validDepositAmt(collateralAmt, assetConfig.minDepositAmt);
-            AccountLib.addDepositReq(
-                RollupStorage.layout(),
-                msg.sender,
-                accountId,
-                assetConfig.token,
-                tokenId,
-                assetConfig.decimals,
-                collateralAmt
+        // {} scope to avoid stack too deep error
+        {
+            AccountStorage.Layout storage asl = AccountStorage.layout();
+            loanOwner = asl.getAccountAddr(loanInfo.accountId);
+            bytes32 structHash = _calcRemoveCollateralStructHash(
+                loanId,
+                amount,
+                asl.getPermitNonce(loanOwner),
+                deadline
             );
-        } else {
-            Utils.transfer(collateralToken, payable(msg.sender), collateralAmt);
+            asl.validatePermitAndIncreaseNonce(loanOwner, structHash, deadline, v, r, s);
         }
+
+        _removeCollateral(lsl, loanInfo, loanId, msg.sender, loanOwner, amount);
     }
 
     /**
      * @inheritdoc ILoanFacet
      */
-    function liquidate(bytes12 loanId, uint128 repayAmt) external payable returns (uint128, uint128) {
-        (LiquidationAmt memory liquidationAmt, IERC20 collateralToken) = _liquidate(loanId, repayAmt);
+    function repay(bytes12 loanId, uint128 collateralAmt, uint128 debtAmt, bool repayAndDeposit) external payable {
+        LoanStorage.Layout storage lsl = LoanStorage.layout();
+        LoanInfo memory loanInfo = lsl.getLoanInfo(loanId);
+        AccountStorage.Layout storage asl = AccountStorage.layout();
+        address loanOwner = asl.getAccountAddr(loanInfo.accountId);
+        asl.requireValidCaller(msg.sender, loanOwner, DELEGATE_REPAY_MASK);
 
-        uint128 liquidatorRewardAmt = liquidationAmt.liquidatorRewardAmt;
-        uint128 protocolPenaltyAmt = liquidationAmt.protocolPenaltyAmt;
-        Utils.transfer(collateralToken, payable(msg.sender), liquidatorRewardAmt);
+        _repay(lsl, loanInfo, msg.sender, loanOwner, loanId, collateralAmt, debtAmt, repayAndDeposit, msg.value);
+    }
 
-        address payable treasuryAddr = ProtocolParamsStorage.layout().getTreasuryAddr();
-        Utils.transfer(collateralToken, treasuryAddr, protocolPenaltyAmt);
+    //! mainnet-audit
+    /**
+     * @inheritdoc ILoanFacet
+     */
+    function repayWithPermit(
+        bytes12 loanId,
+        uint128 collateralAmt,
+        uint128 debtAmt,
+        bool repayAndDeposit,
+        uint256 deadline,
+        uint8 v,
+        bytes32 r,
+        bytes32 s
+    ) external payable {
+        LoanStorage.Layout storage lsl = LoanStorage.layout();
+        LoanInfo memory loanInfo = lsl.getLoanInfo(loanId);
+        address loanOwner;
 
-        emit Liquidation(loanId, msg.sender, collateralToken, liquidatorRewardAmt, protocolPenaltyAmt);
-        return (liquidatorRewardAmt, protocolPenaltyAmt);
+        // {} scope to avoid stack too deep error
+        {
+            AccountStorage.Layout storage asl = AccountStorage.layout();
+            loanOwner = asl.getAccountAddr(loanInfo.accountId);
+            bytes32 structHash = _calcRepayStructHash(
+                loanId,
+                collateralAmt,
+                debtAmt,
+                repayAndDeposit,
+                asl.getPermitNonce(loanOwner),
+                deadline
+            );
+            asl.validatePermitAndIncreaseNonce(loanOwner, structHash, deadline, v, r, s);
+        }
+
+        _repay(lsl, loanInfo, msg.sender, loanOwner, loanId, collateralAmt, debtAmt, repayAndDeposit, msg.value);
     }
 
     /**
      * @inheritdoc ILoanFacet
      * @notice Should be `approveDelegation` before `borrow from AAVE V3 pool`
      * @dev Roll the loan to AAVE V3 pool,
      *      the user can transfer the loan of fixed rate and date from term structure
      *      to the floating rate and perpetual position on Aave without repaying the debt
      */
     function rollToAave(bytes12 loanId, uint128 collateralAmt, uint128 debtAmt) external {
         LoanStorage.Layout storage lsl = LoanStorage.layout();
         if (!lsl.getRollerState()) revert RollIsNotActivated();
 
         LoanInfo memory loanInfo = lsl.getLoanInfo(loanId);
-        msg.sender.requireLoanOwner(loanInfo);
+        AccountStorage.Layout storage asl = AccountStorage.layout();
+        address loanOwner = asl.getAccountAddr(loanInfo.accountId);
+        asl.requireValidCaller(msg.sender, loanOwner, DELEGATE_ROLL_TO_AAVE_MASK);
 
-        Loan memory loan = loanInfo.loan;
-        loan = loan.repay(collateralAmt, debtAmt);
-        loan.requireHealthy(loanInfo);
+        _rollToAave(lsl, loanInfo, msg.sender, loanOwner, loanId, collateralAmt, debtAmt);
+    }
 
-        lsl.loans[loanId] = loan;
+    //! mainnet-audit
+    /**
+     * @inheritdoc ILoanFacet
+     * @notice Should be `approveDelegation` before `borrow from AAVE V3 pool`
+     * @dev Roll the loan to AAVE V3 pool with permit signature
+     *      the user can transfer the loan of fixed rate and date from term structure
+     *      to the floating rate and perpetual position on Aave without repaying the debt
+     */
+    function rollToAaveWithPermit(
+        bytes12 loanId,
+        uint128 collateralAmt,
+        uint128 debtAmt,
+        uint256 deadline,
+        uint8 v,
+        bytes32 r,
+        bytes32 s
+    ) external {
+        LoanStorage.Layout storage lsl = LoanStorage.layout();
+        if (!lsl.getRollerState()) revert RollIsNotActivated();
 
-        _supplyToBorrow(loanId, loanInfo.collateralAsset.token, loanInfo.debtAsset.token, collateralAmt, debtAmt);
+        LoanInfo memory loanInfo = lsl.getLoanInfo(loanId);
+        address loanOwner;
+
+        // {} scope to avoid stack too deep error
+        {
+            AccountStorage.Layout storage asl = AccountStorage.layout();
+            loanOwner = asl.getAccountAddr(loanInfo.accountId);
+            bytes32 structHash = _calcRollToAaveStructHash(
+                loanId,
+                collateralAmt,
+                debtAmt,
+                asl.getPermitNonce(loanOwner),
+                deadline
+            );
+            asl.validatePermitAndIncreaseNonce(loanOwner, structHash, deadline, v, r, s);
+        }
+
+        _rollToAave(lsl, loanInfo, msg.sender, loanOwner, loanId, collateralAmt, debtAmt);
+    }
+
+    /**
+     * @inheritdoc ILoanFacet
+     * @dev Cannot roll total collateral amount because the original loan will be not strict healthy if success
+     */
+    function rollBorrow(RollBorrowOrder memory rollBorrowOrder) external payable {
+        LoanStorage.Layout storage lsl = LoanStorage.layout();
+        if (!lsl.getRollerState()) revert RollIsNotActivated();
+        if (msg.value != lsl.getRollOverFee()) revert InvalidRollBorrowFee(msg.value);
+
+        Utils.transferNativeToken(ProtocolParamsStorage.layout().getVaultAddr(), msg.value);
+
+        LoanInfo memory loanInfo = lsl.getLoanInfo(rollBorrowOrder.loanId);
+        AccountStorage.Layout storage asl = AccountStorage.layout();
+        address loanOwner = asl.getAccountAddr(loanInfo.accountId);
+        asl.requireValidCaller(msg.sender, loanOwner, DELEGATE_ROLL_BORROW_MASK);
+
+        uint32 newMaturityTime = _requireValidOrder(rollBorrowOrder, loanInfo, rollBorrowOrder.loanId);
+
+        _rollBorrow(lsl, rollBorrowOrder, loanInfo, msg.sender, loanOwner, rollBorrowOrder.loanId, newMaturityTime);
+    }
+
+    //! mainnet-audit
+    /**
+     * @inheritdoc ILoanFacet
+     * @dev Cannot roll total collateral amount because the original loan will be not strict healthy if success
+     */
+    function rollBorrowWithPermit(
+        RollBorrowOrder memory rollBorrowOrder,
+        uint256 deadline,
+        uint8 v,
+        bytes32 r,
+        bytes32 s
+    ) external payable {
+        LoanStorage.Layout storage lsl = LoanStorage.layout();
+        if (!lsl.getRollerState()) revert RollIsNotActivated();
+        if (msg.value != lsl.getRollOverFee()) revert InvalidRollBorrowFee(msg.value);
+
+        Utils.transferNativeToken(ProtocolParamsStorage.layout().getVaultAddr(), msg.value);
+
+        LoanInfo memory loanInfo = lsl.getLoanInfo(rollBorrowOrder.loanId);
+        address loanOwner;
+
+        // {} scope to avoid stack too deep error
+        {
+            AccountStorage.Layout storage asl = AccountStorage.layout();
+            loanOwner = asl.getAccountAddr(loanInfo.accountId);
+            bytes32 structHash = _calcRollBorrowStructHash(rollBorrowOrder, asl.getPermitNonce(loanOwner), deadline);
+            asl.validatePermitAndIncreaseNonce(loanOwner, structHash, deadline, v, r, s);
+        }
+
+        uint32 newMaturityTime = _requireValidOrder(rollBorrowOrder, loanInfo, rollBorrowOrder.loanId);
+
+        _rollBorrow(lsl, rollBorrowOrder, loanInfo, msg.sender, loanOwner, rollBorrowOrder.loanId, newMaturityTime);
+    }
+
+    /**
+     * @inheritdoc ILoanFacet
+     * @dev The force cancel roll borrow action will add this request in L1 request queue,
+     *      to force this transaction must to be packaged in rollup block
+     *      to avoid the `UserCancelRollBorrow` operation be maliciously ignored in L2
+     */
+    function forceCancelRollBorrow(bytes12 loanId) external {
+        LoanStorage.Layout storage lsl = LoanStorage.layout();
+        if (!lsl.getRollerState()) revert RollIsNotActivated();
+
+        (uint32 accountId, uint32 maturityTime, uint16 debtTokenId, uint16 collateralTokenId) = LoanLib.resolveLoanId(
+            loanId
+        );
+        AccountStorage.Layout storage asl = AccountStorage.layout();
+        address loanOwner = asl.getAccountAddr(accountId);
+        asl.requireValidCaller(msg.sender, loanOwner, DELEGATE_FORCE_CANCEL_ROLL_BORROW_MASK);
+
+        _forceCancelRollBorrow(
+            lsl,
+            msg.sender,
+            loanOwner,
+            loanId,
+            accountId,
+            debtTokenId,
+            collateralTokenId,
+            maturityTime
+        );
+    }
+
+    //! mainnet-audit
+    /**
+     * @inheritdoc ILoanFacet
+     * @dev The force cancel roll borrow action will add this request in L1 request queue,
+     *      to force this transaction must to be packaged in rollup block
+     *      to avoid the `UserCancelRollBorrow` operation be maliciously ignored in L2
+     */
+    function forceCancelRollBorrowWithPermit(bytes12 loanId, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {
+        LoanStorage.Layout storage lsl = LoanStorage.layout();
+        if (!lsl.getRollerState()) revert RollIsNotActivated();
+
+        (uint32 accountId, uint32 maturityTime, uint16 debtTokenId, uint16 collateralTokenId) = LoanLib.resolveLoanId(
+            loanId
+        );
+        address loanOwner;
+
+        // {} scope to avoid stack too deep error
+        {
+            AccountStorage.Layout storage asl = AccountStorage.layout();
+            loanOwner = asl.getAccountAddr(accountId);
+            bytes32 structHash = _calcForceCancelRollBorrowStructHash(loanId, asl.getPermitNonce(loanOwner), deadline);
+            asl.validatePermitAndIncreaseNonce(loanOwner, structHash, deadline, v, r, s);
+        }
+
+        _forceCancelRollBorrow(
+            lsl,
+            msg.sender,
+            loanOwner,
+            loanId,
+            accountId,
+            debtTokenId,
+            collateralTokenId,
+            maturityTime
+        );
+    }
+
+    /**
+     * @inheritdoc ILoanFacet
+     */
+    function liquidate(bytes12 loanId, uint128 repayAmt) external payable returns (uint128, uint128) {
+        (LiquidationAmt memory liquidationAmt, IERC20 collateralToken) = _liquidate(msg.sender, loanId, repayAmt);
+
+        uint128 liquidatorRewardAmt = liquidationAmt.liquidatorRewardAmt;
+        uint128 protocolPenaltyAmt = liquidationAmt.protocolPenaltyAmt;
+        Utils.transfer(collateralToken, payable(msg.sender), liquidatorRewardAmt);
+
+        address payable treasuryAddr = ProtocolParamsStorage.layout().getTreasuryAddr();
+        Utils.transfer(collateralToken, treasuryAddr, protocolPenaltyAmt);
+
+        emit Liquidation(loanId, msg.sender, collateralToken, liquidatorRewardAmt, protocolPenaltyAmt);
+        return (liquidatorRewardAmt, protocolPenaltyAmt);
     }
 
     /* ============ Admin Functions ============ */
 
     /**
      * @inheritdoc ILoanFacet
      */
     function setHalfLiquidationThreshold(uint16 halfLiquidationThreshold) external onlyRole(Config.ADMIN_ROLE) {
         LoanStorage.layout().halfLiquidationThreshold = halfLiquidationThreshold;
         emit SetHalfLiquidationThreshold(halfLiquidationThreshold);
     }
 
     /**
      * @inheritdoc ILoanFacet
      */
     function setLiquidationFactor(
         LiquidationFactor memory liquidationFactor,
         bool isStableCoinPair
     ) external onlyRole(Config.ADMIN_ROLE) {
+        uint16 borrowOrderLtvThreshold = liquidationFactor.borrowOrderLtvThreshold;
+        uint16 liquidationLtvThreshold = liquidationFactor.liquidationLtvThreshold;
+        if (borrowOrderLtvThreshold == 0) revert InvalidLiquidationFactor(liquidationFactor);
+        if (liquidationLtvThreshold == 0) revert InvalidLiquidationFactor(liquidationFactor);
+        if (borrowOrderLtvThreshold > liquidationLtvThreshold) revert InvalidLiquidationFactor(liquidationFactor);
         if (
-            liquidationFactor.ltvThreshold == 0 ||
-            liquidationFactor.ltvThreshold + liquidationFactor.liquidatorIncentive + liquidationFactor.protocolPenalty >
+            liquidationLtvThreshold + liquidationFactor.liquidatorIncentive + liquidationFactor.protocolPenalty >
             Config.MAX_LTV_RATIO
         ) revert InvalidLiquidationFactor(liquidationFactor);
 
         LoanStorage.Layout storage lsl = LoanStorage.layout();
         isStableCoinPair
             ? lsl.stableCoinPairLiquidationFactor = liquidationFactor
             : lsl.liquidationFactor = liquidationFactor;
         emit SetLiquidationFactor(liquidationFactor, isStableCoinPair);
     }
 
     /**
      * @inheritdoc ILoanFacet
      */
     function setActivatedRoller(bool isActivated) external onlyRole(Config.ADMIN_ROLE) {
         LoanStorage.layout().isActivatedRoller = isActivated;
         emit SetActivatedRoller(isActivated);
     }
 
+    /**
+     * @inheritdoc ILoanFacet
+     */
+    function setBorrowFeeRate(uint32 borrowFeeRate) external onlyRole(Config.ADMIN_ROLE) {
+        LoanStorage.layout().borrowFeeRate = borrowFeeRate;
+        emit SetBorrowFeeRate(borrowFeeRate);
+    }
+
+    /**
+     * @inheritdoc ILoanFacet
+     */
+    function setRollOverFee(uint256 rollOverFee) external onlyRole(Config.ADMIN_ROLE) {
+        LoanStorage.layout().rollOverFee = rollOverFee;
+        emit SetRollOverFee(rollOverFee);
+    }
+
     /* ============ External View Functions ============ */
 
     /**
      * @inheritdoc ILoanFacet
      */
     function getHealthFactor(bytes12 loanId) external view returns (uint256) {
         LoanStorage.Layout storage lsl = LoanStorage.layout();
         LoanInfo memory loanInfo = lsl.getLoanInfo(loanId);
         Loan memory loan = loanInfo.loan;
         (uint256 healthFactor, , ) = loan.getHealthFactor(
-            loanInfo.liquidationFactor.ltvThreshold,
+            loanInfo.liquidationFactor.liquidationLtvThreshold,
             loanInfo.collateralAsset,
             loanInfo.debtAsset
         );
         return healthFactor;
     }
 
     /**
      * @inheritdoc ILoanFacet
      */
     function getHalfLiquidationThreshold() external view returns (uint16) {
         return LoanStorage.layout().getHalfLiquidationThreshold();
     }
 
     /**
      * @inheritdoc ILoanFacet
      */
     function getLiquidationFactor(bool isStableCoinPair) external view returns (LiquidationFactor memory) {
         LoanStorage.Layout storage lsl = LoanStorage.layout();
         return isStableCoinPair ? lsl.getStableCoinPairLiquidationFactor() : lsl.getLiquidationFactor();
     }
 
     /**
      * @inheritdoc ILoanFacet
      */
     function getLoan(bytes12 loanId) external view returns (Loan memory) {
         return LoanStorage.layout().getLoan(loanId);
     }
 
     /**
      * @inheritdoc ILoanFacet
      */
     function getLiquidationInfo(bytes12 loanId) external view returns (bool, IERC20, uint128) {
         LoanStorage.Layout storage lsl = LoanStorage.layout();
         LoanInfo memory loanInfo = lsl.getLoanInfo(loanId);
         Loan memory loan = loanInfo.loan;
         (uint256 healthFactor, uint256 normalizedCollateralPrice, ) = loan.getHealthFactor(
-            loanInfo.liquidationFactor.ltvThreshold,
+            loanInfo.liquidationFactor.liquidationLtvThreshold,
             loanInfo.collateralAsset,
             loanInfo.debtAsset
         );
         bool _isLiquidable = LoanLib.isLiquidable(healthFactor, loanInfo.maturityTime);
 
         uint16 halfLiquidationThreshold = lsl.getHalfLiquidationThreshold();
         uint128 maxRepayAmt = normalizedCollateralPrice
             .calcCollateralValue(loan.collateralAmt, loanInfo.collateralAsset.decimals)
             .calcMaxRepayAmt(loan.debtAmt, loanInfo.maturityTime, halfLiquidationThreshold);
 
         return (_isLiquidable, loanInfo.debtAsset.token, maxRepayAmt);
     }
 
+    /**
+     * @inheritdoc ILoanFacet
+     */
+    function getBorrowFeeRate() external view returns (uint32) {
+        return LoanStorage.layout().getBorrowFeeRate();
+    }
+
+    /**
+     * @inheritdoc ILoanFacet
+     */
+    function getRollOverFee() external view returns (uint256) {
+        return LoanStorage.layout().getRollOverFee();
+    }
+
     /**
      * @inheritdoc ILoanFacet
      */
     function isActivatedRoller() external view returns (bool) {
         return LoanStorage.layout().getRollerState();
     }
 
     /**
      * @inheritdoc ILoanFacet
      */
     function getLoanId(
         uint32 accountId,
         uint32 maturityTime,
         uint16 debtTokenId,
         uint16 collateralTokenId
     ) external pure returns (bytes12) {
         return LoanLib.calcLoanId(accountId, maturityTime, debtTokenId, collateralTokenId);
     }
 
     /**
      * @inheritdoc ILoanFacet
      */
     function resolveLoanId(bytes12 loanId) external pure returns (uint32, uint32, uint16, uint16) {
         return LoanLib.resolveLoanId(loanId);
     }
 
     /* ============ Internal Functions ============ */
 
+    /// @notice Internal remove collateral function
+    /// @param lsl The loan storage layout
+    /// @param loanInfo The loan info
+    /// @param loanId The id of the loan
+    /// @param caller The caller to remove the collateral
+    /// @param loanOwner The owner of the loan
+    /// @param amount The amount of the collateral to be removed
+    function _removeCollateral(
+        LoanStorage.Layout storage lsl,
+        LoanInfo memory loanInfo,
+        bytes12 loanId,
+        address caller,
+        address loanOwner,
+        uint128 amount
+    ) internal {
+        Loan memory loan = loanInfo.loan;
+        loan.removeCollateral(amount);
+        loan.requireHealthy(loanInfo.liquidationFactor, loanInfo.collateralAsset, loanInfo.debtAsset);
+
+        lsl.loans[loanId] = loan;
+        IERC20 collateralToken = loanInfo.collateralAsset.token;
+        Utils.transfer(collateralToken, payable(loanOwner), amount);
+        emit CollateralRemoved(loanId, caller, loanOwner, collateralToken, amount);
+    }
+
     /// @notice Internal repay function
+    /// @param lsl The loan storage layout
+    /// @param loanInfo The loan info
+    /// @param caller The caller to repay the loan
+    /// @param loanOwner The owner of the loan
     /// @param loanId The id of the loan
     /// @param collateralAmt The amount of the collateral to be repaid
     /// @param debtAmt The amount of the debt to be repaid
-    /// @param repayAndDeposit Whether to deposit the collateral after repaying
-    /// @return collateralToken The token of the collateral
-    /// @return accountId The account id of the loan
+    /// @param repayAndDeposit The flag to indicate whether to repay and deposit
+    /// @param msgValue The value of the message
     function _repay(
+        LoanStorage.Layout storage lsl,
+        LoanInfo memory loanInfo,
+        address caller,
+        address loanOwner,
         bytes12 loanId,
         uint128 collateralAmt,
         uint128 debtAmt,
-        bool repayAndDeposit
-    ) internal returns (IERC20, uint32) {
-        LoanStorage.Layout storage lsl = LoanStorage.layout();
-        LoanInfo memory loanInfo = lsl.getLoanInfo(loanId);
-        msg.sender.requireLoanOwner(loanInfo);
-
+        bool repayAndDeposit,
+        uint256 msgValue
+    ) internal {
         Loan memory loan = loanInfo.loan;
-        IERC20 collateralToken = loanInfo.collateralAsset.token;
-        IERC20 debtToken = loanInfo.debtAsset.token;
-        Utils.transferFrom(debtToken, msg.sender, debtAmt, msg.value);
+        Utils.transferFrom(loanInfo.debtAsset.token, caller, debtAmt, msgValue);
 
-        loan = loan.repay(collateralAmt, debtAmt);
-        loan.requireHealthy(loanInfo);
+        loan.repay(collateralAmt, debtAmt);
+        loan.requireHealthy(loanInfo.liquidationFactor, loanInfo.collateralAsset, loanInfo.debtAsset);
 
         lsl.loans[loanId] = loan;
-        emit Repayment(loanId, msg.sender, collateralToken, debtToken, collateralAmt, debtAmt, repayAndDeposit);
-        return (collateralToken, loanInfo.accountId);
+        emit Repayment(
+            loanId,
+            caller,
+            loanOwner,
+            loanInfo.collateralAsset.token,
+            loanInfo.debtAsset.token,
+            collateralAmt,
+            debtAmt,
+            repayAndDeposit
+        );
+
+        if (repayAndDeposit) {
+            TokenStorage.Layout storage tsl = TokenStorage.layout();
+            (uint16 tokenId, AssetConfig memory assetConfig) = tsl.getValidToken(loanInfo.collateralAsset.token);
+            TokenLib.validDepositAmt(collateralAmt, assetConfig.minDepositAmt);
+            AccountLib.addDepositReq(
+                RollupStorage.layout(),
+                caller,
+                loanOwner,
+                loanInfo.accountId,
+                assetConfig.token,
+                tokenId,
+                assetConfig.decimals,
+                collateralAmt
+            );
+        } else {
+            Utils.transfer(loanInfo.collateralAsset.token, payable(loanOwner), collateralAmt);
+        }
+    }
+
+    /// @notice Internal function to roll to AAVE V3
+    /// @param lsl The loan storage layout
+    /// @param loanInfo The loan info
+    /// @param caller The caller to roll to AAVE
+    /// @param loanOwner The loan owner
+    /// @param loanId The loan id to be rolled over
+    /// @param collateralAmt The amount of the collateral to be supplied to AAVE
+    /// @param debtAmt The amount of the debt to be borrowed from AAVE
+    function _rollToAave(
+        LoanStorage.Layout storage lsl,
+        LoanInfo memory loanInfo,
+        address caller,
+        address loanOwner,
+        bytes12 loanId,
+        uint128 collateralAmt,
+        uint128 debtAmt
+    ) internal {
+        Loan memory loan = loanInfo.loan;
+        AssetConfig memory collateralAsset = loanInfo.collateralAsset;
+        AssetConfig memory debtAsset = loanInfo.debtAsset;
+        loan.repay(collateralAmt, debtAmt);
+        loan.requireHealthy(loanInfo.liquidationFactor, collateralAsset, debtAsset);
+
+        lsl.loans[loanId] = loan;
+
+        _supplyToBorrow(caller, loanOwner, loanId, collateralAsset.token, debtAsset.token, collateralAmt, debtAmt);
+    }
+
+    /// @notice Internal function to supply collateral to AAVE V3 then borrow debt from AAVE V3
+    /// @dev    The collateral token is WETH if the collateral token is ETH
+    /// @param caller The caller to roll to AAVE
+    /// @param loanOwner The loan owner
+    /// @param loanId The loan id to be rolled over
+    /// @param collateralToken The collateral token to be supplied
+    /// @param debtToken The debt token to be borrowed
+    /// @param collateralAmt The amount of the collateral token to be supplied
+    /// @param debtAmt The amount of the debt token to be borrowed
+    function _supplyToBorrow(
+        address caller,
+        address loanOwner,
+        bytes12 loanId,
+        IERC20 collateralToken,
+        IERC20 debtToken,
+        uint128 collateralAmt,
+        uint128 debtAmt
+    ) internal {
+        AddressStorage.Layout storage asl = AddressStorage.layout();
+        // AAVE receive WETH as collateral
+        IERC20 supplyToken = address(collateralToken) == Config.ETH_ADDRESS ? asl.getWETH() : collateralToken;
+
+        IPool aaveV3Pool = asl.getAaveV3Pool();
+        supplyToken.safeApprove(address(aaveV3Pool), collateralAmt);
+        // referralCode: 0
+        // (see https://docs.aave.com/developers/core-contracts/pool#supply)
+        try aaveV3Pool.supply(address(supplyToken), collateralAmt, loanOwner, Config.AAVE_V3_REFERRAL_CODE) {
+            // variable rate mode: 2
+            // referralCode: 0
+            // (see https://docs.aave.com/developers/core-contracts/pool#borrow)
+            try
+                aaveV3Pool.borrow(
+                    address(debtToken),
+                    debtAmt,
+                    Config.AAVE_V3_INTEREST_RATE_MODE,
+                    Config.AAVE_V3_REFERRAL_CODE,
+                    loanOwner
+                )
+            {
+                emit Repayment(loanId, caller, loanOwner, collateralToken, debtToken, collateralAmt, debtAmt, false);
+                emit RollToAave(loanId, caller, loanOwner, supplyToken, debtToken, collateralAmt, debtAmt);
+            } catch Error(string memory err) {
+                revert BorrowFromAaveFailedLogString(supplyToken, collateralAmt, debtToken, debtAmt, err);
+            } catch (bytes memory err) {
+                revert BorrowFromAaveFailedLogBytes(supplyToken, collateralAmt, debtToken, debtAmt, err);
+            }
+        } catch Error(string memory err) {
+            revert SupplyToAaveFailedLogString(supplyToken, collateralAmt, err);
+        } catch (bytes memory err) {
+            revert SupplyToAaveFailedLogBytes(supplyToken, collateralAmt, err);
+        }
     }
 
     /// @notice Internal liquidate function
+    /// @param caller The caller to liquidate the loan
     /// @param loanId The loan id to be liquidated
     /// @param repayAmt The amount of the loan to be repaid
     /// @return liquidationAmt The amount of the loan to be liquidated
     /// @return collateralToken The collateral token of the loan
-    function _liquidate(bytes12 loanId, uint128 repayAmt) internal returns (LiquidationAmt memory, IERC20) {
+    function _liquidate(
+        address caller,
+        bytes12 loanId,
+        uint128 repayAmt
+    ) internal returns (LiquidationAmt memory, IERC20) {
         LoanStorage.Layout storage lsl = LoanStorage.layout();
         LoanInfo memory loanInfo = lsl.getLoanInfo(loanId);
         Loan memory loan = loanInfo.loan;
+        address loanOwner = AccountStorage.layout().getAccountAddr(loanInfo.accountId);
 
         LiquidationAmt memory liquidationAmt = _liquidationCalculator(
             repayAmt,
             loanInfo,
             lsl.getHalfLiquidationThreshold()
         );
 
         uint128 totalRemovedCollateralAmt = liquidationAmt.liquidatorRewardAmt + liquidationAmt.protocolPenaltyAmt;
-        IERC20 collateralToken = loanInfo.collateralAsset.token;
-        IERC20 debtToken = loanInfo.debtAsset.token;
-        Utils.transferFrom(debtToken, msg.sender, repayAmt, msg.value);
+        Utils.transferFrom(loanInfo.debtAsset.token, caller, repayAmt, msg.value);
+
+        /// remove all locked collateral (equivalent to cancelling any roll borrow order)
+        if (loan.lockedCollateralAmt > 0) loan.removeLockedCollateral(loan.lockedCollateralAmt);
 
         loan.repay(totalRemovedCollateralAmt, repayAmt);
         lsl.loans[loanId] = loan;
 
-        emit Repayment(loanId, msg.sender, collateralToken, debtToken, totalRemovedCollateralAmt, repayAmt, false);
+        emit Repayment(
+            loanId,
+            caller,
+            loanOwner,
+            loanInfo.collateralAsset.token,
+            loanInfo.debtAsset.token,
+            totalRemovedCollateralAmt,
+            repayAmt,
+            false
+        );
 
-        return (liquidationAmt, collateralToken);
+        return (liquidationAmt, loanInfo.collateralAsset.token);
     }
 
     /// @notice Liquidation calculator to calculate the liquidator reward and protocol penalty
     /// @dev The three cases are:
     /// @dev 1. The collateral value is not enough to cover the full liquidator reward,
     /// @dev    then the liquidator reward will be the all collateral
     /// @dev 2. The collateral value is enough to cover the liquidator reward but not enough to cover the protocol penalty,
     /// @dev    then the liquidator reward is calculated by the liquidation factor,
     /// @dev    and the remaining collateral value will be the protocol penalty
     /// @dev 3. The collateral value is enough to cover the liquidator reward and protocol penalty,
     /// @dev    then the liquidator reward and protocol penalty are calculated by the liquidation factor,
     /// @dev    and the remaining collateral value will be returned to the borrower
     /// @param repayAmt The amount of the debt to be repaid
     /// @param loanInfo The loan info
     /// @param halfLiquidationThreshold The half liquidation threshold
     /// @return liquidationAmt The liquidation amount struct that contains the
     ///         liquidator reward amount and protocol penalty amount
     function _liquidationCalculator(
         uint128 repayAmt,
         LoanInfo memory loanInfo,
         uint16 halfLiquidationThreshold
     ) internal view returns (LiquidationAmt memory) {
         LiquidationFactor memory liquidationFactor = loanInfo.liquidationFactor;
         Loan memory loan = loanInfo.loan;
         uint128 collateralAmt = loan.collateralAmt;
         uint256 repayValueEquivCollateralAmt;
 
         // {} scope to avoid stack too deep error
         {
             AssetConfig memory collateralAsset = loanInfo.collateralAsset;
             AssetConfig memory debtAsset = loanInfo.debtAsset;
             (uint256 healthFactor, uint256 normalizedCollateralPrice, uint256 normalizedDebtPrice) = loan
-                .getHealthFactor(liquidationFactor.ltvThreshold, collateralAsset, debtAsset);
+                .getHealthFactor(liquidationFactor.liquidationLtvThreshold, collateralAsset, debtAsset);
             if (!LoanLib.isLiquidable(healthFactor, loanInfo.maturityTime))
                 revert LoanIsSafe(healthFactor, loanInfo.maturityTime);
 
             uint128 maxRepayAmt = normalizedCollateralPrice
                 .calcCollateralValue(collateralAmt, collateralAsset.decimals)
                 .calcMaxRepayAmt(loan.debtAmt, loanInfo.maturityTime, halfLiquidationThreshold);
             if (repayAmt > maxRepayAmt) revert RepayAmtExceedsMaxRepayAmt(repayAmt, maxRepayAmt);
 
             // repayValueEquivCollateralAmt = repayValue / collateralPrice * 10**collateralDecimals
             // ==> repayValueEquivCollateralAmt = (normalizedDebtPrice / 10**18) * (repayAmt / 10**debtAssetDecimals) /
             //     (normalizedCollateralPrice / 10**18) * 10**collateralAssetDecimals
             // ==> repayValueEquivCollateralAmt = (normalizedDebtPrice * repayAmt / 10**debtAssetDecimals) /
             //     normalizedCollateralPrice * 10**collateralAssetDecimals
             // ==> repayValueEquivCollateralAmt = normalizedRepayValue * 10**collateralAssetDecimals / normalizedCollateralPrice
             uint256 normalizedRepayValue = normalizedDebtPrice.mulDiv(repayAmt, 10 ** debtAsset.decimals);
             repayValueEquivCollateralAmt = normalizedRepayValue.mulDiv(
                 10 ** collateralAsset.decimals,
                 normalizedCollateralPrice
             );
         }
 
         // LTV_BASE = 1000
         // value = (normalizedPrice / 10**18) * (amount / 10**decimals)
         // The repayToCollateralRatio is calculated by formula:
         // repayToCollateralRatio = LTV_BASE * repayValue / collateralValue
         // ==> repayToCollateralRatio = LTV_BASE * ((normalizedDebtPrice / 10**18) * (repayAmt / 10**debtAssetDecimals)) /
         //     ((normalizedCollateralPrice / 10**18) * (collateralAmt / 10**collateralAssetDecimals))
         // ==> repayToCollateralRatio = LTV_BASE * (normalizedDebtPrice * repayAmt / 10**debtAssetDecimals) /
         //     (normalizedCollateralPrice * collateralAmt / 10**collateralAssetDecimals)
         // ==> repayToCollateralRatio = LTV_BASE * (normalizedDebtPrice * repayAmt / 10**debtAssetDecimals) * 10**collateralAssetDecimals /
         //     normalizedCollateralPrice / collateralAmt
         // ==> repayToCollateralRatio = LTV_BASE * normalizedRepayValue * 10**collateralAssetDecimals /
         //     normalizedCollateralPrice / collateralAmt
         // ==> repayToCollateralRatio = LTV_BASE * repayValueEquivCollateralAmt / collateralAmt
         uint256 repayToCollateralRatio = Config.LTV_BASE.mulDiv(repayValueEquivCollateralAmt, collateralAmt);
         uint16 liquidatorIncentive = liquidationFactor.liquidatorIncentive;
         uint16 protocolPenalty = liquidationFactor.protocolPenalty;
 
         // case1: if collateral value cannot cover protocol penalty and full liquidator reward
         // in this case, liquidator reward = all collateral, and protocol penalty = 0
         // liquidatorRewardAmt = totalCollateralAmt, and protocolPenaltyAmt = 0
         if (repayToCollateralRatio + liquidatorIncentive > Config.MAX_LTV_RATIO)
             return LiquidationAmt({liquidatorRewardAmt: collateralAmt, protocolPenaltyAmt: 0});
 
         // To compute liquidator reward for case2 and case3: collateral value can cover full liquidator reward
         // The maxLtvRatio is a constant value = 1, and the decimals is 3
         // liquidatorReward = repayValueEquivCollateralAmt + repayValueEquivCollateralAmt * liquidatorIncentive / LTV_BASE
         // liquidatorReward = repayValueEquivCollateralAmt * (MAX_LTV_RATIO + liquidatorIncentive) / LTV_BASE
         uint128 liquidatorRewardAmt = SafeCast.toUint128(
             (repayValueEquivCollateralAmt).mulDiv(Config.MAX_LTV_RATIO + liquidatorIncentive, Config.LTV_BASE)
         );
 
         // To compute protocol penalty for case2: collateral value can not cover full protocol penalty
         // protocolPenaltyAmt = totalCollateralAmt - liquidatorRewardAmt
         //
         // To compute protocol penalty for case3: collateral value can cover full protocol penalty
         // protocolPenalty = repayValueEquivCollateralAmt * protocolPenalty / LTV_BASE
         uint128 protocolPenaltyAmt;
         (repayToCollateralRatio + liquidatorIncentive + protocolPenalty) > Config.MAX_LTV_RATIO
             ? protocolPenaltyAmt = collateralAmt - liquidatorRewardAmt
             : protocolPenaltyAmt = SafeCast.toUint128(
             repayValueEquivCollateralAmt.mulDiv(protocolPenalty, Config.LTV_BASE)
         );
         return LiquidationAmt({liquidatorRewardAmt: liquidatorRewardAmt, protocolPenaltyAmt: protocolPenaltyAmt});
     }
 
-    /// @notice Internal function to supply collateral to AAVE V3 then borrow debt from AAVE V3
-    /// @dev    The collateral token is WETH if the collateral token is ETH
-    /// @param loanId The loan id to be rolled over
-    /// @param collateralToken The collateral token to be supplied
-    /// @param debtToken The debt token to be borrowed
-    /// @param collateralAmt The amount of the collateral token to be supplied
-    /// @param debtAmt The amount of the debt token to be borrowed
-    function _supplyToBorrow(
+    /// @notice Internal function check the roll borrow order is valid
+    /// @param rollBorrowOrder The roll borrow order
+    /// @param loanInfo The loan info
+    /// @param loanId The id of the loan
+    function _requireValidOrder(
+        RollBorrowOrder memory rollBorrowOrder,
+        LoanInfo memory loanInfo,
+        bytes12 loanId
+    ) internal view returns (uint32) {
+        // check the tsb token of next maturity time is exist
+        TokenStorage.Layout storage tsl = TokenStorage.layout();
+        (, AssetConfig memory assetConfig) = tsl.getAssetConfig(IERC20(rollBorrowOrder.tsbTokenAddr));
+        if (!assetConfig.isTsbToken) revert InvalidTsbTokenAddr(rollBorrowOrder.tsbTokenAddr);
+
+        uint32 oldMaturityTime = loanInfo.maturityTime;
+        (, uint32 newMaturityTime) = ITsbToken(rollBorrowOrder.tsbTokenAddr).tokenInfo();
+
+        // assert: expireTime > block.timestamp && expireTime + 1 day <= old maturityTime
+        // solhint-disable-next-line not-rely-on-time
+        if (rollBorrowOrder.expiredTime <= block.timestamp) revert InvalidExpiredTime(rollBorrowOrder.expiredTime);
+        if (rollBorrowOrder.expiredTime + Config.LAST_ROLL_ORDER_TIME_TO_MATURITY > oldMaturityTime)
+            revert InvalidExpiredTime(rollBorrowOrder.expiredTime);
+
+        // check new maturity time is valid (new maturity time > old maturity time)
+        if (newMaturityTime <= oldMaturityTime) revert InvalidMaturityTime(newMaturityTime);
+
+        // check the loan is not locked
+        if (loanInfo.loan.lockedCollateralAmt > 0) revert LoanIsLocked(loanId);
+
+        return newMaturityTime;
+    }
+
+    //! mainnet-audit
+    /// @notice Internal function to roll borrow
+    /// @dev Should simulate this roll borrow order before being matched in L2,
+    ///      to make sure both the original and new loan are strictly healthy (buffering to liquidation threshold)
+    /// @param lsl The loan storage layout
+    /// @param rollBorrowOrder The roll borrow order
+    /// @param loanInfo The loan info
+    /// @param caller The caller to roll borrow the loan
+    /// @param loanOwner The loan owner
+    /// @param loanId The loan id
+    /// @param newMaturityTime The maturity time of the new loan after roll borrow
+    function _rollBorrow(
+        LoanStorage.Layout storage lsl,
+        RollBorrowOrder memory rollBorrowOrder,
+        LoanInfo memory loanInfo,
+        address caller,
+        address loanOwner,
         bytes12 loanId,
-        IERC20 collateralToken,
-        IERC20 debtToken,
-        uint128 collateralAmt,
-        uint128 debtAmt
+        uint32 newMaturityTime
     ) internal {
-        AddressStorage.Layout storage asl = AddressStorage.layout();
-        // AAVE receive WETH as collateral
-        IERC20 supplyToken = address(collateralToken) == Config.ETH_ADDRESS ? asl.getWETH() : collateralToken;
+        AssetConfig memory collateralAsset;
+        AssetConfig memory debtAsset;
+        uint32 borrowFeeRate = lsl.getBorrowFeeRate();
 
-        IPool aaveV3Pool = asl.getAaveV3Pool();
-        supplyToken.safeApprove(address(aaveV3Pool), collateralAmt);
-        // referralCode: 0
-        // (see https://docs.aave.com/developers/core-contracts/pool#supply)
-        try aaveV3Pool.supply(address(supplyToken), collateralAmt, msg.sender, Config.AAVE_V3_REFERRAL_CODE) {
-            // variable rate mode: 2
-            // referralCode: 0
-            // (see https://docs.aave.com/developers/core-contracts/pool#borrow)
-            try
-                aaveV3Pool.borrow(
-                    address(debtToken),
-                    debtAmt,
-                    Config.AAVE_V3_INTEREST_RATE_MODE,
-                    Config.AAVE_V3_REFERRAL_CODE,
-                    msg.sender
-                )
-            {
-                emit Repayment(loanId, msg.sender, collateralToken, debtToken, collateralAmt, debtAmt, false);
-                emit RollToAave(loanId, msg.sender, supplyToken, debtToken, collateralAmt, debtAmt);
-            } catch Error(string memory err) {
-                revert BorrowFromAaveFailedLogString(supplyToken, collateralAmt, debtToken, debtAmt, err);
-            } catch (bytes memory err) {
-                revert BorrowFromAaveFailedLogBytes(supplyToken, collateralAmt, debtToken, debtAmt, err);
-            }
-        } catch Error(string memory err) {
-            revert SupplyToAaveFailedLogString(supplyToken, collateralAmt, err);
-        } catch (bytes memory err) {
-            revert SupplyToAaveFailedLogBytes(supplyToken, collateralAmt, err);
+        // {} scope to avoid stack too deep error
+        {
+            // interestRate = APR * (maturityTime - block.timestamp) / SECONDS_OF_ONE_YEAR
+            uint32 maxInterestRate = rollBorrowOrder
+                .maxAnnualPercentageRate
+                // solhint-disable-next-line not-rely-on-time
+                .mulDiv(newMaturityTime - block.timestamp, Config.SECONDS_OF_ONE_YEAR)
+                .toUint32();
+
+            // borrowFee = borrowAmt * (interestRate / SYSTEM_UNIT_BASE) * (borrowFeeRate / SYSTEM_UNIT_BASE)
+            // ==> maxBorrowFee = maxBorrowAmt * (maxInterestRate / SYSTEM_UNIT_BASE) * (borrowFeeRate / SYSTEM_UNIT_BASE)
+            // ==> maxBorrowFee = maxBorrowAmt * maxInterestRate * borrowFeeRate / SYSTEM_UNIT_BASE / SYSTEM_UNIT_BASE
+            uint128 maxBorrowFee = rollBorrowOrder
+                .maxBorrowAmt
+                .mulDiv(uint256(maxInterestRate) * borrowFeeRate, Config.SYSTEM_UNIT_BASE * Config.SYSTEM_UNIT_BASE)
+                .toUint128();
+
+            // debtAmt = borrowAmt + interest
+            // ==> maxDebtAmt = maxBorrowAmt + maxBorrowAmt * maxInterestRate / SYSTEM_UNIT_BASE
+            uint128 maxDebtAmt = rollBorrowOrder.maxBorrowAmt +
+                rollBorrowOrder.maxBorrowAmt.mulDiv(maxInterestRate, Config.SYSTEM_UNIT_BASE).toUint128();
+
+            // check the original loan will be strictly healthy after roll over
+            Loan memory loan = loanInfo.loan;
+            collateralAsset = loanInfo.collateralAsset;
+            debtAsset = loanInfo.debtAsset;
+            loan.repay(rollBorrowOrder.maxCollateralAmt, (rollBorrowOrder.maxBorrowAmt - maxBorrowFee));
+            loan.requireStrictHealthy(loanInfo.liquidationFactor, collateralAsset, debtAsset);
+
+            // reuse the original memory of `loan` to simulate the new loan after roll borrow
+            loan = Loan({collateralAmt: rollBorrowOrder.maxCollateralAmt, lockedCollateralAmt: 0, debtAmt: maxDebtAmt});
+            // check the new loan will be also strictly healthy
+            // if the roll borrow order is executed in L2 then the position is be rollup to L1
+            loan.requireStrictHealthy(loanInfo.liquidationFactor, collateralAsset, debtAsset);
         }
+
+        // add the locked collateral to the original loan
+        // however we only allow one roll borrow order existing for each loan
+        lsl.loans[loanId].lockedCollateralAmt += rollBorrowOrder.maxCollateralAmt;
+
+        (, , uint16 debtTokenId, uint16 collateralTokenId) = LoanLib.resolveLoanId(loanId);
+        Operations.RollBorrow memory rollBorrowReq = Operations.RollBorrow({
+            accountId: loanInfo.accountId,
+            collateralTokenId: collateralTokenId,
+            maxCollateralAmt: rollBorrowOrder.maxCollateralAmt.toL2Amt(collateralAsset.decimals),
+            feeRate: borrowFeeRate,
+            borrowTokenId: debtTokenId,
+            maxBorrowAmt: rollBorrowOrder.maxBorrowAmt.toL2Amt(debtAsset.decimals),
+            oldMaturityTime: loanInfo.maturityTime,
+            newMaturityTime: newMaturityTime,
+            expiredTime: rollBorrowOrder.expiredTime,
+            maxPrincipalAndInterestRate: (rollBorrowOrder.maxAnnualPercentageRate + Config.SYSTEM_UNIT_BASE).toUint32() // convert APR to PIR (e.g. 5% APR => 105% PIR)
+        });
+
+        LoanLib.addRollBorrowReq(RollupStorage.layout(), loanOwner, rollBorrowReq);
+        emit RollBorrowOrderPlaced(loanId, caller, loanOwner, rollBorrowReq);
+    }
+
+    //! mainnet-audit
+    /// @notice Internal function to force cancel roll borrow
+    /// @param lsl The loan storage layout
+    /// @param caller The caller to force cancel roll borrow
+    /// @param loanOwner The loan owner
+    /// @param loanId The loan id to be forced cancel roll borrow
+    /// @param accountId The account id of the loan owner
+    /// @param debtTokenId The debt token id of the loan
+    /// @param collateralTokenId The collateral token id of the loan
+    /// @param maturityTime The maturity time of the original loan to be rolled over
+    function _forceCancelRollBorrow(
+        LoanStorage.Layout storage lsl,
+        address caller,
+        address loanOwner,
+        bytes12 loanId,
+        uint32 accountId,
+        uint16 debtTokenId,
+        uint16 collateralTokenId,
+        uint32 maturityTime
+    ) internal {
+        Loan memory loan = lsl.getLoan(loanId);
+        if (loan.lockedCollateralAmt == 0) revert LoanIsNotLocked(loanId);
+
+        Operations.CancelRollBorrow memory forceCancelRollBorrowReq = Operations.CancelRollBorrow({
+            accountId: accountId,
+            debtTokenId: debtTokenId,
+            collateralTokenId: collateralTokenId,
+            maturityTime: maturityTime // the maturity time of the original loan to be rolled over
+        });
+
+        LoanLib.addForceCancelRollBorrowReq(RollupStorage.layout(), loanOwner, forceCancelRollBorrowReq);
+        emit RollBorrowOrderForceCancelPlaced(loanId, caller, loanOwner);
+    }
+
+    /* ============ Internal Pure Functions to Calculate Struct Hash ============ */
+
+    //! mainnet-audit
+    /// @notice Calculate the hash of the struct for the remove collateral permit
+    /// @param loanId The id of the loan
+    /// @param amount The amount of the collateral to be added
+    /// @param nonce The nonce of the permit
+    /// @param deadline The deadline of the permit
+    function _calcRemoveCollateralStructHash(
+        bytes12 loanId,
+        uint128 amount,
+        uint256 nonce,
+        uint256 deadline
+    ) internal pure returns (bytes32) {
+        return keccak256(abi.encode(REMOVE_COLLATERAL_TYPEHASH, loanId, amount, nonce, deadline));
+    }
+
+    //! mainnet-audit
+    /// @notice Calculate the hash of the struct for the repay collateral permit
+    /// @param loanId The id of the loan
+    /// @param collateralAmt The amount of the collateral to be added
+    /// @param debtAmt The amount of the debt to be repaid
+    /// @param repayAndDeposit The flag to indicate whether to repay and deposit
+    /// @param nonce The nonce of the permit
+    /// @param deadline The deadline of the permit
+    function _calcRepayStructHash(
+        bytes12 loanId,
+        uint128 collateralAmt,
+        uint128 debtAmt,
+        bool repayAndDeposit,
+        uint256 nonce,
+        uint256 deadline
+    ) internal pure returns (bytes32) {
+        return keccak256(abi.encode(REPAY_TYPEHASH, loanId, collateralAmt, debtAmt, repayAndDeposit, nonce, deadline));
+    }
+
+    //! mainnet-audit
+    /// @notice Calculate the hash of the struct for the roll borrow permit
+    /// @param rollBorrowOrder The roll borrow order
+    /// @param nonce The nonce of the permit
+    /// @param deadline The deadline of the permit
+    function _calcRollBorrowStructHash(
+        RollBorrowOrder memory rollBorrowOrder,
+        uint256 nonce,
+        uint256 deadline
+    ) internal pure returns (bytes32) {
+        return
+            keccak256(
+                abi.encode(
+                    ROLL_BORROW_TYPEHASH,
+                    rollBorrowOrder.loanId,
+                    rollBorrowOrder.expiredTime,
+                    rollBorrowOrder.maxAnnualPercentageRate,
+                    rollBorrowOrder.maxCollateralAmt,
+                    rollBorrowOrder.maxBorrowAmt,
+                    rollBorrowOrder.tsbTokenAddr,
+                    nonce,
+                    deadline
+                )
+            );
+    }
+
+    //! mainnet-audit
+    /// @notice Calculate the hash of the struct for the force cancel roll borrow permit
+    /// @param loanId The id of the loan
+    /// @param nonce The nonce of the permit
+    /// @param deadline The deadline of the permit
+    function _calcForceCancelRollBorrowStructHash(
+        bytes12 loanId,
+        uint256 nonce,
+        uint256 deadline
+    ) internal pure returns (bytes32) {
+        return keccak256(abi.encode(FORCE_CANCEL_ROLL_BORROW_TYPEHASH, loanId, nonce, deadline));
+    }
+
+    //! mainnet-audit
+    /// @notice Calculate the hash of the struct for the roll to AAVE permit
+    /// @param loanId The id of the loan
+    /// @param collateralAmt The amount of the collateral to be supplied to AAVE
+    /// @param debtAmt The amount of the debt to be borrowed from AAVE
+    /// @param nonce The nonce of the permit
+    /// @param deadline The deadline of the permit
+    function _calcRollToAaveStructHash(
+        bytes12 loanId,
+        uint128 collateralAmt,
+        uint128 debtAmt,
+        uint256 nonce,
+        uint256 deadline
+    ) internal pure returns (bytes32) {
+        return keccak256(abi.encode(ROLL_TO_AAVE_TYPEHASH, loanId, collateralAmt, debtAmt, nonce, deadline));
     }
 }
diff --git a/contracts/zkTrueUp/loan/LoanLib.sol b/contracts/zkTrueUp/loan/LoanLib.sol
index 58be942..e031711 100644
--- a/contracts/zkTrueUp/loan/LoanLib.sol
+++ b/contracts/zkTrueUp/loan/LoanLib.sol
@@ -1,290 +1,390 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
 import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
 import {TokenLib} from "../token/TokenLib.sol";
 import {AccountLib} from "../account/AccountLib.sol";
 import {AssetConfig} from "../token/TokenStorage.sol";
 import {AccountStorage} from "../account/AccountStorage.sol";
 import {LoanStorage, Loan, LiquidationFactor, LoanInfo} from "./LoanStorage.sol";
+import {RollupStorage} from "../rollup/RollupStorage.sol";
+import {RollupLib} from "../rollup/RollupLib.sol";
 import {TokenStorage} from "../token/TokenStorage.sol";
+import {Operations} from "../libraries/Operations.sol";
 import {Utils} from "../libraries/Utils.sol";
 import {Config} from "../libraries/Config.sol";
 
 /**
  * @title Term Structure Loan Library
  * @author Term Structure Labs
  */
 library LoanLib {
     using Math for uint256;
     using AccountLib for AccountStorage.Layout;
     using TokenLib for TokenStorage.Layout;
+    using RollupLib for RollupStorage.Layout;
     using LoanLib for *;
 
     /// @notice Error for collateral amount is not enough when removing collateral
     error CollateralAmtIsNotEnough(uint128 collateralAmt, uint128 amount);
+    /// @notice Error for locked collateral amount is not enough when removing locked collateral
+    error LockedCollateralAmtIsNotEnough(uint128 lockedCollateralAmt, uint128 amount);
     /// @notice Error for debt amount less than repay amount when repaying
     error DebtAmtLtRepayAmt(uint128 debtAmt, uint128 repayAmt);
     /// @notice Error for addr is not the loan owner
     error isNotLoanOwner(address addr, address loanOwner);
-    /// @notice Error for health factor is under thresholds
-    error LoanIsUnhealthy(uint256 healthFactor);
+    /// @notice Error for loan is not healthy (loan is liquidable)
+    error LoanIsNotHealthy(uint256 healthFactor);
+    /// @notice Error for loan is not strict healthy
+    ///         (when place order, strict healthy is required to reserve some buffer to prevent users being liquidated immediately)
+    error LoanIsNotStrictHealthy(uint256 healthFactor);
     /// @notice Error for get loan which is not exist
     error LoanIsNotExist(bytes12 loanId);
+    /// @notice Error for collateral amount is less than locked collateral amount
+    error CollateralAmtLtLockedCollateralAmt(uint128 collateralAmt, uint128 lockedCollateralAmt);
+    /// @notice Error for invalid caller
+    error InvalidCaller(address caller, address loanOwner);
 
     /// @notice Internal function to add collateral to the loan
     /// @param loan The loan to be added collateral
     /// @param amount The amount of the collateral to be added
     /// @return newLoan The new loan with added collateral
     function addCollateral(Loan memory loan, uint128 amount) internal pure returns (Loan memory) {
         loan.collateralAmt += amount;
         return loan;
     }
 
     /// @notice Internal function to remove collateral from the loan
+    /// @dev The collateral amount must be greater than the locked collateral amount at any time
     /// @param loan The loan to be removed collateral
     /// @param amount The amount of the collateral to be removed
     /// @return newLoan The new loan with removed collateral
     function removeCollateral(Loan memory loan, uint128 amount) internal pure returns (Loan memory) {
         if (loan.collateralAmt < amount) revert CollateralAmtIsNotEnough(loan.collateralAmt, amount);
+
         unchecked {
             loan.collateralAmt -= amount;
         }
+
+        // The collateral amount must be greater than the locked collateral amount at any time
+        if (loan.collateralAmt < loan.lockedCollateralAmt)
+            revert CollateralAmtLtLockedCollateralAmt(loan.collateralAmt, loan.lockedCollateralAmt);
+
+        return loan;
+    }
+
+    /// @notice Internal function to remove locked collateral to the loan
+    /// @dev The locked collateral amount must be greater than or equal to the removed amount
+    /// @param loan The loan to be removed locked collateral
+    /// @param amount The amount of the locked collateral to be removed
+    function removeLockedCollateral(Loan memory loan, uint128 amount) internal pure returns (Loan memory) {
+        if (loan.lockedCollateralAmt < amount) revert LockedCollateralAmtIsNotEnough(loan.lockedCollateralAmt, amount);
+
+        unchecked {
+            loan.lockedCollateralAmt -= amount;
+        }
+
         return loan;
     }
 
+    /// @notice Internal function to add roll borrow request in reuqest queue
+    /// @param rsl The rollup storage
+    /// @param sender The sender of the roll borrow request
+    /// @param rollBorrowReq The roll borrow request to be added
+    function addRollBorrowReq(
+        RollupStorage.Layout storage rsl,
+        address sender,
+        Operations.RollBorrow memory rollBorrowReq
+    ) internal {
+        bytes memory pubData = Operations.encodeRollBorrowPubData(rollBorrowReq);
+        rsl.addL1Request(sender, Operations.OpType.ROLL_BORROW_ORDER, pubData);
+    }
+
+    /// @notice Internal function to add force cancel roll borrow request in reuqest queue
+    /// @param rsl The rollup storage
+    /// @param sender The sender of the force cancel roll borrow request
+    /// @param forceCancelRollBorrowReq The force cancel roll borrow request to be added
+    function addForceCancelRollBorrowReq(
+        RollupStorage.Layout storage rsl,
+        address sender,
+        Operations.CancelRollBorrow memory forceCancelRollBorrowReq
+    ) internal {
+        bytes memory pubData = Operations.encodeForceCancelRollBorrowPubData(forceCancelRollBorrowReq);
+        rsl.addL1Request(sender, Operations.OpType.FORCE_CANCEL_ROLL_BORROW, pubData);
+    }
+
     /// @notice Internal function to repay the debt of the loan and remove collateral from the loan
+    /// @dev The collateral amount must be greater than the locked collateral amount at any time
     /// @param loan The loan to be repaid
     /// @param collateralAmt The amount of the collateral to be removed
     /// @param repayAmt The amount of the debt to be repaid
     /// @return newLoan The new loan with repaid debt and removed collateral
     function repay(Loan memory loan, uint128 collateralAmt, uint128 repayAmt) internal pure returns (Loan memory) {
         if (loan.collateralAmt < collateralAmt) revert CollateralAmtIsNotEnough(loan.collateralAmt, collateralAmt);
         if (loan.debtAmt < repayAmt) revert DebtAmtLtRepayAmt(loan.debtAmt, repayAmt);
+
         unchecked {
             loan.collateralAmt -= collateralAmt;
             loan.debtAmt -= repayAmt;
         }
+
+        // The collateral amount must be greater than the locked collateral amount at any time
+        if (loan.collateralAmt < loan.lockedCollateralAmt)
+            revert CollateralAmtLtLockedCollateralAmt(loan.collateralAmt, loan.lockedCollateralAmt);
+
         return loan;
     }
 
     /// @notice Internal function to update the loan
     /// @param loan The loan to be updated
     /// @param collateralAmt The amount of the collateral to be added
     /// @param debtAmt The amount of the debt to be added
     /// @return newLoan The new loan with updated collateral and debt
     function updateLoan(Loan memory loan, uint128 collateralAmt, uint128 debtAmt) internal pure returns (Loan memory) {
         loan.collateralAmt += collateralAmt;
         loan.debtAmt += debtAmt;
         return loan;
     }
 
     /// @notice Internal function to get the health factor of the loan
     /// @dev The health factor formula: ltvThreshold * (collateralValue / collateralDecimals) / (debtValue / debtDecimals)
     /// @dev The health factor decimals is 3
     /// @param loan The loan to be calculated
     /// @param ltvThreshold The LTV threshold of the loan
     /// @param collateralAsset The collateral asset of the loan
     /// @param debtAsset The debt asset of the loan
     /// @return healthFactor The health factor of the loan
     /// @return normalizedCollateralPrice The normalized price of the collateral asset
     /// @return normalizedDebtPrice The normalized price of the debt asset
     function getHealthFactor(
         Loan memory loan,
         uint256 ltvThreshold,
         AssetConfig memory collateralAsset,
         AssetConfig memory debtAsset
     ) internal view returns (uint256, uint256, uint256) {
         uint256 normalizedCollateralPrice = Utils.getPrice(collateralAsset.priceFeed);
         uint256 normalizedDebtPrice = Utils.getPrice(debtAsset.priceFeed);
         if (loan.debtAmt == 0) return (type(uint256).max, normalizedCollateralPrice, normalizedDebtPrice);
 
         // The health factor formula: ltvThreshold * collateralValue / debtValue
         // ==> healthFactor =
         //      ltvThreshold * (normalizedCollateralPrice * collateralAmt / 10**collateralDecimals) /
         //      (normalizedDebtPrice * loan.debtAmt / 10**debtDecimals)
         // ==> healthFactor = ltvThreshold * normalizedCollateralValue / normalizedDebtValue
         uint256 normalizedCollateralValue = normalizedCollateralPrice.mulDiv(
             loan.collateralAmt,
             10 ** collateralAsset.decimals
         );
         uint256 normalizedDebtValue = normalizedDebtPrice.mulDiv(loan.debtAmt, 10 ** debtAsset.decimals);
         uint256 healthFactor = ltvThreshold.mulDiv(normalizedCollateralValue, normalizedDebtValue);
         return (healthFactor, normalizedCollateralPrice, normalizedDebtPrice);
     }
 
     /// @notice Internal function to get the loan info
     /// @param s The loan storage
     /// @param loanId The id of the loan
     /// @return LoanInfo The loan info
     function getLoanInfo(LoanStorage.Layout storage s, bytes12 loanId) internal view returns (LoanInfo memory) {
         Loan memory loan = s.getLoan(loanId);
         (uint32 accountId, uint32 maturityTime, uint16 debtTokenId, uint16 collateralTokenId) = resolveLoanId(loanId);
         if (accountId == 0) revert LoanIsNotExist(loanId);
 
         TokenStorage.Layout storage tsl = TokenStorage.layout();
         AssetConfig memory collateralAsset = tsl.getAssetConfig(collateralTokenId);
         AssetConfig memory debtAsset = tsl.getAssetConfig(debtTokenId);
 
         LiquidationFactor memory liquidationFactor = debtAsset.isStableCoin && collateralAsset.isStableCoin
             ? s.getStableCoinPairLiquidationFactor()
             : s.getLiquidationFactor();
 
         return (
             LoanInfo({
                 loan: loan,
                 accountId: accountId,
                 maturityTime: maturityTime,
                 liquidationFactor: liquidationFactor,
                 collateralAsset: collateralAsset,
                 debtAsset: debtAsset
             })
         );
     }
 
     /// @notice Internal function to get the loan
     /// @param s The loan storage
     /// @param loanId The id of the loan
     /// @return loan The loan info
     function getLoan(LoanStorage.Layout storage s, bytes12 loanId) internal view returns (Loan memory) {
         return s.loans[loanId];
     }
 
     /// @notice Internal function to get the half liquidation threshold
     /// @param s The loan storage
     /// @return halfLiquidationThreshold The half liquidation threshold
     function getHalfLiquidationThreshold(LoanStorage.Layout storage s) internal view returns (uint16) {
         return s.halfLiquidationThreshold;
     }
 
     /// @notice Internal function to get the liquidation factor
     /// @param s The loan storage
     /// @return liquidationFactor The liquidation factor
     function getLiquidationFactor(LoanStorage.Layout storage s) internal view returns (LiquidationFactor memory) {
         return s.liquidationFactor;
     }
 
     /// @notice Internal function to get the stable coin pair liquidation factor
     /// @param s The loan storage
     /// @return liquidationFactor The stable coin pair liquidation factor
     function getStableCoinPairLiquidationFactor(
         LoanStorage.Layout storage s
     ) internal view returns (LiquidationFactor memory) {
         return s.stableCoinPairLiquidationFactor;
     }
 
+    /// @notice Internal function to get the borrow fee rate
+    /// @param s The loan storage
+    /// @return borrowFeeRate The borrow fee rate, base 1e18
+    function getBorrowFeeRate(LoanStorage.Layout storage s) internal view returns (uint32) {
+        return s.borrowFeeRate;
+    }
+
+    /// @notice Internal function to get the roll over fee
+    /// @param s The loan storage
+    /// @return rollOverFee The roll over fee, unit is wei
+    function getRollOverFee(LoanStorage.Layout storage s) internal view returns (uint256) {
+        return s.rollOverFee;
+    }
+
     /// @notice Internal function to check if the roll function is activated
     /// @param s The loan storage
     /// @return isRollActivated True if the roll function is activated, otherwise false
     function getRollerState(LoanStorage.Layout storage s) internal view returns (bool) {
         return s.isActivatedRoller;
     }
 
     /// @notice Internal function to check if the loan is liquidable
     /// @param healthFactor The health factor of the loan
     /// @param maturityTime The maturity time of the loan
     /// @return isLiquidable True if the loan is liquidable, otherwise false
     function isLiquidable(uint256 healthFactor, uint32 maturityTime) internal view returns (bool) {
         return !isHealthy(healthFactor) || isMatured(maturityTime);
     }
 
     /// @notice Internal function to check if the loan is matured
     /// @param maturityTime The maturity time of the loan
     /// @return isMatured True if the loan is matured, otherwise false
     function isMatured(uint32 maturityTime) internal view returns (bool) {
         // solhint-disable-next-line not-rely-on-time
         return block.timestamp >= maturityTime;
     }
 
     /// @notice Internal function to check if the loan is healthy
     /// @param healthFactor The health factor to be checked
     /// @return isHealthy True if the loan is healthy, otherwise false
     function isHealthy(uint256 healthFactor) internal pure returns (bool) {
         return healthFactor >= Config.HEALTH_FACTOR_THRESHOLD;
     }
 
-    /// @notice Internal function to check if the address is the loan owner
-    /// @param addr The address to be checked
-    /// @param loanInfo The loan info
-    function requireLoanOwner(address addr, LoanInfo memory loanInfo) internal view {
-        address loanOwner = AccountStorage.layout().getAccountAddr(loanInfo.accountId);
-        if (addr != loanOwner) revert isNotLoanOwner(addr, loanOwner);
+    /// @notice Internal function to check if the loan is healthy (not liquidable)
+    /// @param loan The loan to be checked
+    /// @param liquidationFactor The liquidation factor of the loan
+    /// @param collateralAsset The collateral asset of the loan
+    /// @param debtAsset The debt asset of the loan
+    function requireHealthy(
+        Loan memory loan,
+        LiquidationFactor memory liquidationFactor,
+        AssetConfig memory collateralAsset,
+        AssetConfig memory debtAsset
+    ) internal view {
+        (uint256 healthFactor, , ) = loan.getHealthFactor(
+            liquidationFactor.liquidationLtvThreshold, // use liquidation LTV threshold
+            collateralAsset,
+            debtAsset
+        );
+        if (healthFactor < Config.HEALTH_FACTOR_THRESHOLD) revert LoanIsNotHealthy(healthFactor);
     }
 
-    /// @notice Internal function to check if the loan is healthy
+    /// @notice Internal function to check if the loan is strict healthy (buffering to liquidation threshold)
+    /// @dev Using strict healthy when place order to reserve some buffer to prevent users being liquidated immediately
     /// @param loan The loan to be checked
-    /// @param loanInfo The loan info
-    function requireHealthy(Loan memory loan, LoanInfo memory loanInfo) internal view {
+    /// @param liquidationFactor The liquidation factor of the loan
+    /// @param collateralAsset The collateral asset of the loan
+    /// @param debtAsset The debt asset of the loan
+    function requireStrictHealthy(
+        Loan memory loan,
+        LiquidationFactor memory liquidationFactor,
+        AssetConfig memory collateralAsset,
+        AssetConfig memory debtAsset
+    ) internal view {
         (uint256 healthFactor, , ) = loan.getHealthFactor(
-            loanInfo.liquidationFactor.ltvThreshold,
-            loanInfo.collateralAsset,
-            loanInfo.debtAsset
+            liquidationFactor.borrowOrderLtvThreshold, // use borrow order LTV threshold
+            collateralAsset,
+            debtAsset
         );
-        if (healthFactor < Config.HEALTH_FACTOR_THRESHOLD) revert LoanIsUnhealthy(healthFactor);
+        if (healthFactor < Config.HEALTH_FACTOR_THRESHOLD) revert LoanIsNotStrictHealthy(healthFactor);
     }
 
     /// @notice Return the max repayable amount of the loan
     /// @dev    If the collateral value is less than half liquidation threshold or the loan is expired,
     ///         then the liquidator can repay the all debt
     ///         otherwise, the liquidator can repay max to half of the debt
     /// @param collateralValue The collateral value without decimals
     /// @param debtAmt The amount of the debt
     /// @param halfLiquidationThreshold The value of half liquidation threshold
     /// @return maxRepayAmt The maximum amount of the debt to be repaid
     function calcMaxRepayAmt(
         uint256 collateralValue,
         uint128 debtAmt,
         uint32 maturityTime,
         uint16 halfLiquidationThreshold
     ) internal view returns (uint128) {
         uint128 maxRepayAmt = collateralValue < halfLiquidationThreshold || isMatured(maturityTime)
             ? debtAmt
             : debtAmt / 2;
         return maxRepayAmt;
     }
 
     /// @notice Internal function to calculate the collateral value
     /// @param normalizedCollateralPrice The normalized collateral price
     /// @param collateralAmt The collateral amount
     /// @param collateralDecimals The collateral decimals
     /// @return collateralValue The collateral value
     function calcCollateralValue(
         uint256 normalizedCollateralPrice,
         uint128 collateralAmt,
         uint8 collateralDecimals
     ) internal pure returns (uint256) {
         return normalizedCollateralPrice.mulDiv(collateralAmt, 10 ** collateralDecimals) / 10 ** 18;
     }
 
     /// @notice Internal function to get the loan id by the loan info
     /// @param accountId The account id
     /// @param maturityTime The maturity time
     /// @param debtTokenId The debt token id
     /// @param collateralTokenId The collateral token id
     /// @return loanId The loan id
     function calcLoanId(
         uint32 accountId,
         uint32 maturityTime,
         uint16 debtTokenId,
         uint16 collateralTokenId
     ) internal pure returns (bytes12) {
         return
             bytes12(
                 uint96(collateralTokenId) |
                     (uint96(debtTokenId) << 16) |
                     (uint96(maturityTime) << 32) |
                     (uint96(accountId) << 64)
             );
     }
 
     /// @notice Resolve the loan id
     /// @param loanId The loan id
     /// @return accountId The account id
     /// @return maturityTime The maturity time
     /// @return debtTokenId The debt token id
     /// @return collateralTokenId The collateral token id
     function resolveLoanId(bytes12 loanId) internal pure returns (uint32, uint32, uint16, uint16) {
         uint96 _loanId = uint96(loanId);
         return (uint32(_loanId >> 64), uint32(_loanId >> 32), uint16(_loanId >> 16), uint16(_loanId));
     }
 }
diff --git a/contracts/zkTrueUp/loan/LoanStorage.sol b/contracts/zkTrueUp/loan/LoanStorage.sol
index 025e2be..4ce4d7c 100644
--- a/contracts/zkTrueUp/loan/LoanStorage.sol
+++ b/contracts/zkTrueUp/loan/LoanStorage.sol
@@ -1,73 +1,131 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
 import {AssetConfig} from "../token/TokenStorage.sol";
 
 /// @notice Liquidation factor of the loan
-/// @dev ltvThreshold: the threshold of the loan-to-value ratio,
+/// @dev liquidationLtvThreshold: the liquidation threshold of the loan-to-value ratio,
 ///      if the ratio is higher than the threshold, the loan will be liquidated
 ///      the base is 1e3 (1000), i.e. 800 means 80%
+/// @dev borrowOrderLtvThreshold: the borrow order threshold of the loan-to-value ratio,
+///      the borrow order will be rejected if the ratio is higher than the threshold.
+///      the base is 1e3 (1000), i.e. 750 means 75%,
+///      buffer between liquidated LTV threshold and borrow order LTV threshold to avoid
+///      liquidation immediately if LTV fluctuates too much after the borrow order and before create loan in rollup
 /// @dev liquidatorIncentive: the incentive for liquidator if the loan is liquidated,
 ///      the liquidator will get the extra incentive equivalent to the collateral value
 ///      the base is 1e3 (1000), i.e. 50 means 5%
 /// @dev protocolPenalty: the penalty for the protocol if the loan is liquidated,
 ///      the protocol will get the penalty equivalent to the collateral value
 ///      the base is 1e3 (1000), i.e. 50 means 5%
 struct LiquidationFactor {
-    uint16 ltvThreshold;
+    uint16 liquidationLtvThreshold;
+    uint16 borrowOrderLtvThreshold;
     uint16 liquidatorIncentive;
     uint16 protocolPenalty;
 }
 
 /// @notice Data of loan
 struct Loan {
-    uint128 debtAmt;
     uint128 collateralAmt;
+    uint128 lockedCollateralAmt;
+    uint128 debtAmt;
 }
 
 /// @notice The information of the loan
 struct LoanInfo {
     Loan loan;
     uint32 maturityTime;
     uint32 accountId;
     LiquidationFactor liquidationFactor;
     AssetConfig collateralAsset;
     AssetConfig debtAsset;
 }
 
 /// @notice The amount of the liquidation
 struct LiquidationAmt {
     uint128 liquidatorRewardAmt;
     uint128 protocolPenaltyAmt;
 }
 
+/* ============ The type hash of sign typed data v4 for permit functions ============ */
+
+// Remove collateral function type hash
+bytes32 constant REMOVE_COLLATERAL_TYPEHASH = keccak256(
+    "RemoveCollateral(bytes12 loanId,uint128 amount,uint256 nonce,uint256 deadline)"
+);
+
+// Repay function type hash
+bytes32 constant REPAY_TYPEHASH = keccak256(
+    "Repay(bytes12 loanId,uint128 collateralAmt,uint128 debtAmt,bool repayAndDeposit,uint256 nonce,uint256 deadline)"
+);
+
+// Borrow function type hash
+bytes32 constant ROLL_BORROW_TYPEHASH = keccak256(
+    "RollBorrow(bytes12 loanId,uint32 expiredTime,uint32 maxAnnualPercentageRate,uint128 maxCollateralAmt,uint128 maxBorrowAmt,address tsbTokenAddr,uint256 nonce,uint256 deadline)"
+);
+
+// Force cancel roll borrow function type hash
+bytes32 constant FORCE_CANCEL_ROLL_BORROW_TYPEHASH = keccak256(
+    "ForceCancelRollBorrow(bytes12 loanId,uint256 nonce,uint256 deadline)"
+);
+
+// Roll to Aave function type hash
+bytes32 constant ROLL_TO_AAVE_TYPEHASH = keccak256(
+    "RollToAave(bytes12 loanId,uint128 collateralAmt,uint128 debtAmt,uint256 nonce,uint256 deadline)"
+);
+
+/// @notice The data of the roll borrow order
+/// @dev maxAnnualPercentageRate means the maximum annual percentage rate that borrower can accept,
+///      the actual annual percentage rate may be less than or equal to it when the order matched in L2
+/// @dev maxCollateralAmt and maxBorrowAmt means the maximum amount that user want to roll,
+///      but the actual amount of the roll borrow order may be less than or equal to the maximum amount
+///      because of the partial fill in L2
+struct RollBorrowOrder {
+    bytes12 loanId;
+    uint32 expiredTime;
+    uint32 maxAnnualPercentageRate; // base is 1e8 (APR)
+    uint128 maxCollateralAmt;
+    uint128 maxBorrowAmt;
+    address tsbTokenAddr; // the tsb token address of the new term of the loan
+}
+
 /**
  * @title Term Structure Loan Storage
  * @author Term Structure Labs
  */
 library LoanStorage {
     bytes32 internal constant STORAGE_SLOT = bytes32(uint256(keccak256("zkTrueUp.contracts.storage.Loan")) - 1);
 
     struct Layout {
         /// @notice The flag to indicate the roll function is activated or not
         bool isActivatedRoller;
         /// @notice The half liquidation threshold, unit is US dollar
         ///         i.e. 10000 means 10000 usd
         uint16 halfLiquidationThreshold;
+        /// @notice The fee rate for borrower, base is 1e8
+        ///         i.e. 0.1e8 means 10% of the interest
+        /// @dev    The fee rate is adjustable, it will be the same as borrow order fee rate in L2
+        uint32 borrowFeeRate;
+        /// @notice The fee for roll over service
+        ///         charged by the protocol for rollup gas cost of roll-borrow request
+        ///         and avoid user send many roll over request to spam the rollup
+        ///         unit is wei i.e. 0.01e18 means 0.01 ether
+        uint256 rollOverFee;
         /// @notice LTV threshold for loans
         LiquidationFactor liquidationFactor;
         /// @notice LTV threshold for stable coin pairs' loans
         LiquidationFactor stableCoinPairLiquidationFactor;
         /// @notice Mapping from loan id to loan data
         mapping(bytes12 => Loan) loans;
     }
 
     function layout() internal pure returns (Layout storage s) {
         bytes32 slot = STORAGE_SLOT;
 
         // solhint-disable-next-line no-inline-assembly
         assembly {
             s.slot := slot
         }
     }
 }
diff --git a/contracts/zkTrueUp/rollup/IRollupFacet.sol b/contracts/zkTrueUp/rollup/IRollupFacet.sol
index 3dc2e03..0b58f2e 100644
--- a/contracts/zkTrueUp/rollup/IRollupFacet.sol
+++ b/contracts/zkTrueUp/rollup/IRollupFacet.sol
@@ -1,259 +1,226 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
 import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 import {RollupStorage, Proof, CommitBlock, StoredBlock, VerifyBlock, ExecuteBlock, Request} from "./RollupStorage.sol";
 import {Operations} from "../libraries/Operations.sol";
 
 /**
  * @title Term Structure Rollup Facet Interface
  * @author Term Structure Labs
  */
 interface IRollupFacet {
     /// @notice Error for committed request number exceed total request number
     error CommittedRequestNumExceedTotalNum(uint64 committedL1RequestNum);
     /// @notice Error for verified block number exceed committed block number
     error VerifiedBlockNumExceedCommittedNum(uint256 verifyingBlockNum);
     /// @notice Error for executed block number exceed proved block number
     error ExecutedBlockNumExceedProvedNum(uint256 pendingBlockNum);
-    /// @notice Error for invalid evacuate public data length
-    error InvalidEvacuatePubDataLength(uint256 pubDataLength);
     /// @notice Error for offset is greater than public data length
     error OffsetGtPubDataLength(uint256 offset);
     /// @notice Error for offset is already set
     error OffsetIsSet(uint256 chunkId);
     /// @notice Error for maturity time is not matched
     error MaturityTimeIsNotMatched(uint32 tsbTokenMaturityTime, uint32 createTsbReqMaturityTime);
     /// @notice Error for invalid op type
     error InvalidOpType(Operations.OpType opType);
-    /// @notice Error for inconsistent commitment
-    error CommitmentInconsistant(uint256 proofCommitment, uint256 committedBlockcommitment);
-    /// @notice Error for invalid proof
-    error InvalidProof(Proof proof);
     /// @notice Error for invalid executed block number
     error InvalidExecutedBlockNum(uint32 executedBlockNum);
     /// @notice Error for redeem with invalid tsb token address
     error InvalidTsbTokenAddr(address invalidTokenAddr);
     /// @notice Error for pending rollup tx hash is not matched
     error PendingRollupTxHashIsNotMatched(bytes32 pendingRollupTxHash, bytes32 executeBlockPendingRollupTxHash);
-    /// @notice Error for the specified accountId and tokenId is already evacuated
-    error Evacuated(uint32 accountId, uint16 tokenId);
-    /// @notice Error for activate evacuation mode, but the timestamp is not expired
-    error TimeStampIsNotExpired(uint256 curTimestamp, uint256 expirationTime);
     /// @notice Error for underlyingAsset token and base token is not matched
     error TokenIsNotMatched(IERC20 underlyingAsset, IERC20 baseToken);
-    /// @notice Error for consumed request number exceed total request number
-    error ConsumedRequestNumExceedTotalNum(uint256 consumedRequestNum);
-    /// @notice Error for invalid consumed public data mismatch the data in the request queue
-    error InvalidConsumedPubData(uint64 l1RequestNum, bytes pubData);
-    /// @notice Error for invalid chunk id delta when commit evacublock in evacuation mode
-    error InvalidChunkIdDelta(uint16[] chunkIdDeltas);
-    /// @notice Error for evacuate but haven't consumed all L1 requests
-    error NotConsumedAllL1Requests(uint64 executedL1RequestNum, uint64 totalL1RequestNum);
-    /// @notice Error for consume L1 request but the request is evacuation (already consumed all L1 requests)
-    error LastL1RequestIsEvacuation(uint64 totalL1RequestNum);
     /// @notice Error for invalid public data when commit evacublock in evacuation mode
     error InvalidEvacuBlockPubData(uint256 evacuationRequestNum);
-    /// @notice Error for account address is not the msg.sender
-    error AccountAddrIsNotSender(address accountAddr, address sender);
-    /// @notice Error for refund deregistered address but the account is not deregistered
-    error NotDeregisteredAddr(address accountAddr, uint32 accountId);
+    /// @notice Error for invalid chunk id delta when commit evacublock in evacuation mode
+    error InvalidChunkIdDelta(uint16[] chunkIdDeltas);
+    /// @notice Error for removed collateral amount is greater than locked collateral amount
+    error RemovedCollateralAmtGtLockedCollateralAmt(uint128 removedCollateralAmt, uint128 lockedCollateralAmt);
+    /// @notice Error for invalid matched time when rollup a roll borrow operation
+    error InvalidMatchedTime(uint32 matchedTime, uint256 blockTimestamp);
+    /// @notice Error for invalid old maturity time, the old maturity time should be greater than the block timestamp
+    ///         i.e. cannot roll a matured loan
+    error InvalidOldMaturityTime(uint32 oldMaturityTime, uint256 blockTimestamp);
+    /// @notice Error for invalid new maturity time, the new maturity time should be greater than the old maturity time
+    error InvalidNewMaturityTime(uint32 newMaturityTime, uint32 oldMaturityTime);
 
     /// @notice Emit when there is a new block committed
     /// @param blockNumber The number of the committed block
     /// @param commitment The commitment of the block
     event BlockCommit(uint32 indexed blockNumber, bytes32 indexed commitment);
 
     /// @notice Emit when there is a new block verified
     /// @param blockNumber The number of the verified block
     event BlockVerification(uint32 indexed blockNumber);
 
     /// @notice Emit when there is a new block executed
     /// @param blockNumber The number of the executed block
     event BlockExecution(uint32 indexed blockNumber);
 
     /// @notice Emit when there is a new block reverted
     /// @param blockNumber The number of the reverted block
     event BlockRevert(uint32 indexed blockNumber);
 
     /// @notice Emit when there is an evacuation
     /// @param accountAddr The address of the account
     /// @param accountId The id of the account
     /// @param token The token to be evacuated
     /// @param tokenId The id of the token
     /// @param amount The amount of the token
     event Evacuation(
         address accountAddr,
         uint32 indexed accountId,
         IERC20 token,
         uint16 indexed tokenId,
         uint256 amount
     );
 
-    /// @notice Emitted when evacuation mode is activated
-    event EvacuModeActivation();
-
     /// @notice Emitted when evacuation mode is deactivated
     event EvacuModeDeactivation();
 
-    /// @notice Emit when there is a new L1 request consumed
-    /// @dev Consumed number is the number of the executed L1 request - 1
-    /// @param executedL1RequestNum The number of the executed L1 request
-    /// @param opType The type of the L1 request
-    /// @param pubData The public data of the L1 request
-    event L1RequestConsumed(uint64 executedL1RequestNum, Operations.OpType opType, bytes pubData);
-
     /// @notice Emit when there is a new loan created
     /// @param loanId The id of the loan
-    /// @param accountId The account id of the loan owner
     /// @param addedCollateralAmt  The added collateral amount of the loan
     /// @param addedDebtAmt The added debt amount of the loan
-    event UpdateLoan(
+    event UpdateLoan(bytes12 indexed loanId, uint128 addedCollateralAmt, uint128 addedDebtAmt);
+
+    /// @notice Emit when there is a loan is roll over
+    /// @param loanId The id of the original loan
+    /// @param newLoanId The id of the new loan
+    /// @param collateralAmt The collateral amount roll over from the original loan to the new loan
+    /// @param borrowAmt The borrow amount used to remove the debt amount of the original loan
+    /// @param debtAmt The debt amount to the new loan
+    event RollOver(
         bytes12 indexed loanId,
-        uint32 indexed accountId,
-        uint128 addedCollateralAmt,
-        uint128 addedDebtAmt
+        bytes12 indexed newLoanId,
+        uint128 collateralAmt,
+        uint128 borrowAmt,
+        uint128 debtAmt
     );
 
-    /// @notice Emit when an account is de-registered
-    /// @notice De-registered only remove the accountAddr -> accountId mapping,
-    ///         but not remove the accountId -> accountAddr mapping,
-    ///         this is for user can still refund their asset by `refundDeregisteredAddr`
-    /// @param accountAddr The address of the account
-    /// @param accountId The id of the account
-    event AccountDeregistered(address accountAddr, uint32 indexed accountId);
+    /// @notice Emit when there is a roll borrow order is cancelled
+    /// @param loanId The id of the loan
+    /// @param removedLockedCollateralAmt The removed locked collateral amount of the loan
+    event RollBorrowCancel(bytes12 indexed loanId, uint128 removedLockedCollateralAmt);
 
     /// @notice Commit blocks
     /// @param lastCommittedBlock The last committed block
     /// @param newBlocks The new blocks to be committed
     function commitBlocks(StoredBlock memory lastCommittedBlock, CommitBlock[] calldata newBlocks) external;
 
     /// @notice Verify blocks
     /// @param verifyingBlocks The committed blocks to be verified and proofs
     function verifyBlocks(VerifyBlock[] calldata verifyingBlocks) external;
 
     /// @notice Execute blocks
     /// @param pendingBlocks The pending blocks to be executed
     function executeBlocks(ExecuteBlock[] calldata pendingBlocks) external;
 
     /// @notice Revert blocks
     /// @dev This function is only used for revert the unexecuted blocks
     /// @param revertedBlocks The blocks to be reverted
     function revertBlocks(StoredBlock[] calldata revertedBlocks) external;
 
-    /// @notice When L2 system is down, anyone can call this function to activate the evacuation mode
-    function activateEvacuation() external;
-
-    /// @notice Consume the L1 non-executed requests in the evacuation mode
-    /// @param consumedTxPubData The public data of the non-executed L1 requests which in the request queue
-    function consumeL1RequestInEvacuMode(bytes[] calldata consumedTxPubData) external;
-
-    /// @notice Evacuate the funds of a specified user and token in the evacuMode
-    /// @param lastExecutedBlock The last executed block
-    /// @param newBlock A pseudo block to create block commitment for verification but not to be commited
-    /// @param proof The proof of the newBlock
-    function evacuate(
-        StoredBlock memory lastExecutedBlock,
-        CommitBlock calldata newBlock,
-        Proof calldata proof
-    ) external;
-
     /// @notice Commit evacuation blocks
     /// @param lastCommittedBlock The last committed block
     /// @param evacuBlocks The evacuation blocks to be committed
     function commitEvacuBlocks(StoredBlock memory lastCommittedBlock, CommitBlock[] calldata evacuBlocks) external;
 
     /// @notice Verify evacuation blocks
     /// @param evacuBlocks The evacuation blocks to be verified and proofs
     function verifyEvacuBlocks(VerifyBlock[] calldata evacuBlocks) external;
 
     /// @notice Execute evacuation blocks
     /// @param evacuBlocks The evacuation blocks to be executed
     function executeEvacuBlocks(ExecuteBlock[] calldata evacuBlocks) external;
 
-    /// @notice Refund the deregistered address
-    /// @param token The token to be refunded
-    /// @param amount The amount of the token to be refunded
-    /// @param accountId The account id to be refunded
-    function refundDeregisteredAddr(IERC20 token, uint256 amount, uint32 accountId) external;
-
-    /// @notice Return the evacuation mode is activated or not
-    /// @return evacuMode The evacuation mode status
-    function isEvacuMode() external view returns (bool evacuMode);
-
-    /// @notice Return the specified address and token is evacuated or not
-    /// @param addr The address to be checked
-    /// @param tokenId The id of the token
-    /// @return isEvacuted Return true is the token is evacuated, else return false
-    function isEvacuted(address addr, uint16 tokenId) external view returns (bool);
-
     /// @notice Check whether the register request is in the L1 request queue
     /// @param register The register request
     /// @param requestId The id of the request
     /// @return isExisted Return true is the request is existed in the L1 request queue, else return false
     function isRegisterInL1RequestQueue(
         Operations.Register memory register,
         uint64 requestId
     ) external view returns (bool isExisted);
 
     /// @notice Check whether the deposit request is in the L1 request queue
     /// @param deposit The deposit request
     /// @param requestId The id of the request
     /// @return isExisted Return true is the request is existed in the L1 request queue, else return false
     function isDepositInL1RequestQueue(
         Operations.Deposit memory deposit,
         uint64 requestId
     ) external view returns (bool isExisted);
 
     /// @notice Check whether the force withdraw request is in the L1 request queue
     /// @param forceWithdraw The force withdraw request
     /// @param requestId The id of the request
     /// @return isExisted Return true is the request is existed in the L1 request queue, else return false
     function isForceWithdrawInL1RequestQueue(
         Operations.ForceWithdraw memory forceWithdraw,
         uint64 requestId
     ) external view returns (bool isExisted);
 
     /// @notice Check whether the evacuation request is in the L1 request queue
     /// @param evacuation The evacuation request
     /// @param requestId The id of the request
     /// @return isExisted Return true is the request is existed in the L1 request queue, else return false
     function isEvacuationInL1RequestQueue(
         Operations.Evacuation memory evacuation,
         uint64 requestId
     ) external view returns (bool isExisted);
 
+    /// @notice Check whether the roll borrow request is in the L1 request queue
+    /// @param rollBorrow The roll borrow request
+    /// @param requestId The id of the request
+    /// @return isExisted Return true is the request is existed in the L1 request queue, else return false
+    function isRollBorrowInL1RequestQueue(
+        Operations.RollBorrow memory rollBorrow,
+        uint64 requestId
+    ) external view returns (bool);
+
+    /// @notice Check whether the force cancel roll borrow request is in the L1 request queue
+    /// @param forceCancelRollBorrow The force cancel roll borrow request
+    /// @param requestId The id of the request
+    /// @return isExisted Return true is the request is existed in the L1 request queue, else return false
+    function isForceCancelRollBorrowInL1RequestQueue(
+        Operations.CancelRollBorrow memory forceCancelRollBorrow,
+        uint64 requestId
+    ) external view returns (bool);
+
     /// @notice Return the L1 request of the specified id
     /// @param requestId The id of the specified request
     /// @return request The request of the specified id
     function getL1Request(uint64 requestId) external view returns (Request memory request);
 
     /// @notice Return the L1 request number
     /// @return committedL1RequestNum The number of committed L1 requests
     /// @return executedL1RequestNum The number of executed L1 requests
     /// @return totalL1RequestNum The total number of L1 requests
     function getL1RequestNum()
         external
         view
         returns (uint64 committedL1RequestNum, uint64 executedL1RequestNum, uint64 totalL1RequestNum);
 
     /// @notice Return the block number
     /// @return committedBlockNum The number of committed blocks
     /// @return verifiedBlockNum The number of verified blocks
     /// @return executedBlockNum The number of executed blocks
     function getBlockNum()
         external
         view
         returns (uint32 committedBlockNum, uint32 verifiedBlockNum, uint32 executedBlockNum);
 
     /// @notice Return the block hash of the specified block number
     /// @param blockNum The number of the specified block
     /// @return blockHash The block hash of the specified block number
     function getStoredBlockHash(uint32 blockNum) external view returns (bytes32 blockHash);
 
     /// @notice Return the pending balance of the specified account and token
     /// @param accountAddr The address of the account
     /// @param token The token to be checked
     /// @return pendingBalance The pending balance of the specified account and token
     function getPendingBalances(address accountAddr, IERC20 token) external view returns (uint256 pendingBalance);
 }
diff --git a/contracts/zkTrueUp/rollup/RollupFacet.sol b/contracts/zkTrueUp/rollup/RollupFacet.sol
index 544fac1..a003902 100644
--- a/contracts/zkTrueUp/rollup/RollupFacet.sol
+++ b/contracts/zkTrueUp/rollup/RollupFacet.sol
@@ -1,969 +1,844 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
 import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
-import {ReentrancyGuard} from "@solidstate/contracts/security/reentrancy_guard/ReentrancyGuard.sol";
 import {AccessControlInternal} from "@solidstate/contracts/access/access_control/AccessControlInternal.sol";
 import {SafeCast} from "@solidstate/contracts/utils/SafeCast.sol";
-import {RollupStorage, Proof, StoredBlock, CommitBlock, ExecuteBlock, VerifyBlock, Request} from "./RollupStorage.sol";
+import {RollupStorage, StoredBlock, CommitBlock, ExecuteBlock, VerifyBlock, Request} from "./RollupStorage.sol";
 import {AccountStorage} from "../account/AccountStorage.sol";
 import {AddressStorage} from "../address/AddressStorage.sol";
 import {LoanStorage, Loan} from "../loan/LoanStorage.sol";
 import {ProtocolParamsStorage, FundWeight} from "../protocolParams/ProtocolParamsStorage.sol";
-import {RollupStorage} from "./RollupStorage.sol";
-import {TokenStorage} from "../token/TokenStorage.sol";
-import {AssetConfig} from "../token/TokenStorage.sol";
+import {TokenStorage, AssetConfig} from "../token/TokenStorage.sol";
+import {EvacuationStorage} from "../evacuation/EvacuationStorage.sol";
 import {IRollupFacet} from "./IRollupFacet.sol";
 import {RollupLib} from "./RollupLib.sol";
 import {ProtocolParamsLib} from "../protocolParams/ProtocolParamsLib.sol";
 import {AccountLib} from "../account/AccountLib.sol";
 import {LoanLib} from "../loan/LoanLib.sol";
 import {AddressLib} from "../address/AddressLib.sol";
 import {TokenLib} from "../token/TokenLib.sol";
-import {IVerifier} from "../interfaces/IVerifier.sol";
+import {EvacuationLib} from "../evacuation/EvacuationLib.sol";
 import {ITsbToken} from "../interfaces/ITsbToken.sol";
 import {Operations} from "../libraries/Operations.sol";
 import {Bytes} from "../libraries/Bytes.sol";
 import {Config} from "../libraries/Config.sol";
 import {Utils} from "../libraries/Utils.sol";
 
 /**
  * @title Term Structure Rollup Facet Contract
  * @author Term Structure Labs
  * @notice The RollupFacet contract is used to manage the functions abount zk-rollup
  */
-contract RollupFacet is IRollupFacet, AccessControlInternal, ReentrancyGuard {
+contract RollupFacet is IRollupFacet, AccessControlInternal {
     using AccountLib for AccountStorage.Layout;
     using AddressLib for AddressStorage.Layout;
     using ProtocolParamsLib for ProtocolParamsStorage.Layout;
     using TokenLib for TokenStorage.Layout;
+    using EvacuationLib for EvacuationStorage.Layout;
     using Bytes for bytes;
     using Operations for bytes;
+    using SafeCast for uint256;
     using RollupLib for *;
     using LoanLib for *;
     using Utils for *;
     using Math for *;
 
     /* ============ External Functions ============ */
 
     /**
      * @inheritdoc IRollupFacet
      */
     function commitBlocks(
         StoredBlock memory lastCommittedBlock,
         CommitBlock[] calldata newBlocks
     ) external onlyRole(Config.COMMITTER_ROLE) {
-        RollupStorage.Layout storage rsl = RollupStorage.layout();
-        rsl.requireActive();
+        EvacuationStorage.Layout storage esl = EvacuationStorage.layout();
+        esl.requireActive();
 
+        RollupStorage.Layout storage rsl = RollupStorage.layout();
         _commitBlocks(rsl, lastCommittedBlock, newBlocks, _processOneRequest);
     }
 
     /**
      * @inheritdoc IRollupFacet
      */
     function verifyBlocks(VerifyBlock[] calldata verifyingBlocks) external onlyRole(Config.VERIFIER_ROLE) {
-        RollupStorage.Layout storage rsl = RollupStorage.layout();
-        rsl.requireActive();
+        EvacuationStorage.Layout storage esl = EvacuationStorage.layout();
+        esl.requireActive();
 
+        RollupStorage.Layout storage rsl = RollupStorage.layout();
         _verifyBlocks(rsl, verifyingBlocks);
     }
 
     /**
      * @inheritdoc IRollupFacet
      */
     function executeBlocks(ExecuteBlock[] calldata pendingBlocks) external onlyRole(Config.EXECUTER_ROLE) {
-        RollupStorage.Layout storage rsl = RollupStorage.layout();
-        rsl.requireActive();
+        EvacuationStorage.Layout storage esl = EvacuationStorage.layout();
+        esl.requireActive();
 
+        RollupStorage.Layout storage rsl = RollupStorage.layout();
         _executeBlocks(rsl, pendingBlocks);
     }
 
     /**
      * @inheritdoc IRollupFacet
      */
     function revertBlocks(StoredBlock[] calldata revertedBlocks) external onlyRole(Config.COMMITTER_ROLE) {
-        RollupStorage.Layout storage rsl = RollupStorage.layout();
-        rsl.requireActive();
+        EvacuationStorage.Layout storage esl = EvacuationStorage.layout();
+        esl.requireActive();
 
+        RollupStorage.Layout storage rsl = RollupStorage.layout();
         uint32 committedBlockNum = rsl.getCommittedBlockNum();
         uint32 executedBlockNum = rsl.getExecutedBlockNum();
         uint32 pendingBlockNum = committedBlockNum - executedBlockNum;
         uint32 revertBlockNum = uint32(revertedBlocks.length) < pendingBlockNum
             ? uint32(revertedBlocks.length)
             : pendingBlockNum;
         uint64 revertedL1RequestNum;
 
         for (uint32 i; i < revertBlockNum; ++i) {
             StoredBlock memory revertedBlock = revertedBlocks[i];
             rsl.requireBlockHashIsEq(committedBlockNum, revertedBlock);
 
             delete rsl.storedBlockHashes[committedBlockNum];
             --committedBlockNum;
             revertedL1RequestNum += revertedBlock.l1RequestNum;
         }
 
         rsl.committedBlockNum = committedBlockNum;
         rsl.committedL1RequestNum -= revertedL1RequestNum;
         if (committedBlockNum < rsl.getVerifiedBlockNum()) rsl.verifiedBlockNum = committedBlockNum;
         emit BlockRevert(committedBlockNum);
     }
 
-    /**
-     * @inheritdoc IRollupFacet
-     * @notice The evacuation mode will be activated when the current block timestamp
-     *      is greater than the expiration block timestamp of the last executed L1 request
-     * @notice When the evacuation mode is activated, the block state will be rolled back to the last executed block
-     *      and the request state will be rolled back to the last executed request
-     * @notice The remaining non-executed L1 requests will be consumed by the consumeL1RequestInEvacuMode function
-     *      with their public data, after consume all non-executed request, user can start to evacuate their funds
-     */
-    function activateEvacuation() external {
-        RollupStorage.Layout storage rsl = RollupStorage.layout();
-        rsl.requireActive();
-
-        uint64 executedL1RequestNum = rsl.getExecutedL1RequestNum();
-        uint64 lastExecutedL1RequestId = executedL1RequestNum - 1;
-        uint32 expirationTime = rsl.getL1Request(lastExecutedL1RequestId).expirationTime;
-        // solhint-disable-next-line not-rely-on-time
-        if (block.timestamp > expirationTime && expirationTime != 0) {
-            // Roll back state
-            uint32 executedBlockNum = rsl.getExecutedBlockNum();
-            rsl.committedBlockNum = executedBlockNum;
-            rsl.verifiedBlockNum = executedBlockNum;
-            rsl.committedL1RequestNum = executedL1RequestNum;
-            rsl.evacuMode = true;
-            emit EvacuModeActivation();
-        } else {
-            // solhint-disable-next-line not-rely-on-time
-            revert TimeStampIsNotExpired(block.timestamp, expirationTime);
-        }
-    }
-
-    /**
-     * @inheritdoc IRollupFacet
-     * @notice The function only can be called in evacuation mode
-     * @notice Consume the non-executed L1 requests with their public data
-     */
-    function consumeL1RequestInEvacuMode(bytes[] calldata consumedTxPubData) external {
-        RollupStorage.Layout storage rsl = RollupStorage.layout();
-        rsl.requireEvacuMode();
-
-        uint64 totalL1RequestNum = rsl.getTotalL1RequestNum();
-        uint64 lastL1RequestId = totalL1RequestNum - 1;
-        // The last L1 request cannot be evacuation
-        // because the evacuate action can only be called after consumed all L1 non-executed request
-        if (rsl.getL1Request(lastL1RequestId).opType == Operations.OpType.EVACUATION)
-            revert LastL1RequestIsEvacuation(totalL1RequestNum);
-
-        uint64 executedL1RequestNum = rsl.getExecutedL1RequestNum();
-        if (executedL1RequestNum + consumedTxPubData.length > totalL1RequestNum)
-            revert ConsumedRequestNumExceedTotalNum(consumedTxPubData.length);
-
-        bytes memory pubData;
-        for (uint32 i; i < consumedTxPubData.length; ++i) {
-            pubData = consumedTxPubData[i];
-            Request memory request = rsl.getL1Request(executedL1RequestNum);
-            bytes32 hashedPubData = keccak256(pubData);
-            if (request.hashedPubData != hashedPubData) revert InvalidConsumedPubData(executedL1RequestNum, pubData);
-
-            Operations.OpType opType = Operations.OpType(uint8(pubData[0]));
-            if (opType > type(Operations.OpType).max) revert InvalidOpType(opType);
-
-            if (opType == Operations.OpType.DEPOSIT) {
-                // refund the deposit amount to the pending balance for withdraw
-                Operations.Deposit memory depositReq = pubData.readDepositPubData();
-                _addPendingBalance(rsl, depositReq.accountId, depositReq.tokenId, depositReq.amount);
-            } else if (opType == Operations.OpType.REGISTER) {
-                // de-register only remove the accountAddr mapping to accountId,
-                // which use to check in AccountLib.getValidAccount and let user can register again
-                // and still can add pending balance to this register account
-                // when consume the deposit request in the next request
-                Operations.Register memory registerReq = pubData.readRegisterPubData();
-                AccountStorage.Layout storage asl = AccountStorage.layout();
-                address registerAddr = asl.accountAddresses[registerReq.accountId];
-                delete asl.accountIds[registerAddr];
-                emit AccountDeregistered(registerAddr, registerReq.accountId);
-            }
-
-            ++executedL1RequestNum;
-            emit L1RequestConsumed(executedL1RequestNum, opType, pubData);
-        }
-        rsl.committedL1RequestNum = executedL1RequestNum;
-        rsl.executedL1RequestNum = executedL1RequestNum;
-    }
-
-    /**
-     * @inheritdoc IRollupFacet
-     * @notice The function only can be called in evacuation mode and after consume all non-executed L1 requests
-     * @notice The newBlock is a pseudo block, it only for create the block commitment and not commit to the state
-     * @notice The evacuate fuction will not commit a new state root to make all the users evacuate their funds from the same state
-     */
-    function evacuate(
-        StoredBlock calldata lastExecutedBlock,
-        CommitBlock calldata newBlock,
-        Proof calldata proof
-    ) external nonReentrant {
-        RollupStorage.Layout storage rsl = RollupStorage.layout();
-        rsl.requireEvacuMode();
-
-        _requireConsumedAllNonExecutedReq(rsl);
-
-        rsl.requireBlockHashIsEq(rsl.getExecutedBlockNum(), lastExecutedBlock);
-        newBlock.blockNumber.requireValidBlockNum(lastExecutedBlock.blockNumber);
-        newBlock.timestamp.requireValidBlockTimestamp(lastExecutedBlock.timestamp);
-
-        bytes calldata publicData = newBlock.publicData;
-        // evacuation public data length is 2 chunks
-        if (publicData.length != Config.BYTES_OF_TWO_CHUNKS) revert InvalidEvacuatePubDataLength(publicData.length);
-
-        bytes32 commitment = _calcBlockCommitment(lastExecutedBlock, newBlock, Config.EVACUATION_COMMITMENT_OFFSET);
-
-        _verifyOneBlock(commitment, proof, AddressStorage.layout().getEvacuVerifier());
-
-        Operations.Evacuation memory evacuation = Operations.readEvacuationPubdata(publicData);
-        _evacuate(rsl, evacuation);
-    }
-
     /**
      * @inheritdoc IRollupFacet
      * @dev The function only can be called in evacuation mode and after consume all non-executed L1 requests
      * @dev The commitEvacuBlocks only can including evacuation requests in each block
      */
     function commitEvacuBlocks(
         StoredBlock memory lastCommittedBlock,
         CommitBlock[] calldata evacuBlocks
     ) external onlyRole(Config.COMMITTER_ROLE) {
-        RollupStorage.Layout storage rsl = RollupStorage.layout();
-        rsl.requireEvacuMode();
+        EvacuationStorage.Layout storage esl = EvacuationStorage.layout();
+        esl.requireEvacuMode();
 
-        _requireConsumedAllNonExecutedReq(rsl);
+        RollupStorage.Layout storage rsl = RollupStorage.layout();
+        rsl.requireConsumedAllNonExecutedReq();
         _commitBlocks(rsl, lastCommittedBlock, evacuBlocks, _processOneEvacuRequest);
     }
 
     /**
      * @inheritdoc IRollupFacet
      */
     function verifyEvacuBlocks(VerifyBlock[] calldata evacuBlocks) external onlyRole(Config.VERIFIER_ROLE) {
-        RollupStorage.Layout storage rsl = RollupStorage.layout();
-        rsl.requireEvacuMode();
+        EvacuationStorage.Layout storage esl = EvacuationStorage.layout();
+        esl.requireEvacuMode();
 
-        _requireConsumedAllNonExecutedReq(rsl);
+        RollupStorage.Layout storage rsl = RollupStorage.layout();
+        rsl.requireConsumedAllNonExecutedReq();
         _verifyBlocks(rsl, evacuBlocks);
     }
 
     /**
      * @inheritdoc IRollupFacet
      * @dev If executed all evacuation requests, the protocol will exit the evacuation mode and back to normal mode
      */
     function executeEvacuBlocks(ExecuteBlock[] calldata evacuBlocks) external onlyRole(Config.EXECUTER_ROLE) {
-        RollupStorage.Layout storage rsl = RollupStorage.layout();
-        rsl.requireEvacuMode();
+        EvacuationStorage.Layout storage esl = EvacuationStorage.layout();
+        esl.requireEvacuMode();
 
-        _requireConsumedAllNonExecutedReq(rsl);
+        RollupStorage.Layout storage rsl = RollupStorage.layout();
+        rsl.requireConsumedAllNonExecutedReq();
         _executeBlocks(rsl, evacuBlocks);
 
         // If executed L1 requests number == total L1 requests number
         // means all evacuation requests have been executed or the evacuation requests are empty
         // the protocol will exit the evacuation mode and back to normal mode
         if (rsl.getExecutedL1RequestNum() == rsl.getTotalL1RequestNum()) {
-            rsl.evacuMode = false;
+            esl.evacuMode = false;
             emit EvacuModeDeactivation();
         }
     }
 
-    /**
-     * @inheritdoc IRollupFacet
-     * @notice The function is to refund the pending balance for the account which is deregistered in `consumeL1RequestInEvacuMode`
-     * @notice The function is only refund for the deregistered account, the normal account should use the `withdraw` function to withdraw their funds
-     * @notice De-register only remove the accountAddr mapping to accountId, and keep the accountId mapping to accountAddr for refund
-               so if the `asl.getAccountId(asl.getAccountAddr(accountId)) == accountId` means the account is not the deregistered account
-     */
-    function refundDeregisteredAddr(IERC20 token, uint256 amount, uint32 accountId) external nonReentrant {
-        AccountStorage.Layout storage asl = AccountStorage.layout();
-        address accountAddr = asl.getAccountAddr(accountId);
-        // check the account is deregistered (accountAddr mapping to accountId is deleted)
-        if (asl.getAccountId(accountAddr) == accountId) revert NotDeregisteredAddr(accountAddr, accountId);
-        if (accountAddr != msg.sender) revert AccountAddrIsNotSender(accountAddr, msg.sender);
-
-        TokenStorage.Layout storage tsl = TokenStorage.layout();
-        (uint16 tokenId, AssetConfig memory assetConfig) = tsl.getValidToken(token);
-
-        RollupStorage.Layout storage rsl = RollupStorage.layout();
-        AccountLib.updateWithdrawalRecord(rsl, accountAddr, accountId, token, tokenId, amount);
-
-        Utils.tokenTransfer(token, payable(accountAddr), amount, assetConfig.isTsbToken);
-    }
-
     /* ============ External View Functions ============ */
 
-    /**
-     * @inheritdoc IRollupFacet
-     */
-    function isEvacuMode() external view returns (bool) {
-        return RollupStorage.layout().isEvacuMode();
-    }
-
-    /**
-     * @inheritdoc IRollupFacet
-     */
-    function isEvacuted(address addr, uint16 tokenId) external view returns (bool) {
-        uint32 accountId = AccountStorage.layout().getAccountId(addr);
-        return RollupStorage.layout().isEvacuated(accountId, tokenId);
-    }
-
     /**
      * @inheritdoc IRollupFacet
      */
     function isRegisterInL1RequestQueue(
         Operations.Register memory register,
         uint64 requestId
     ) external view returns (bool) {
         RollupStorage.Layout storage rsl = RollupStorage.layout();
         if (rsl.isRequestIdGtOrEqCurRequestNum(requestId)) return false;
         Request memory request = rsl.getL1Request(requestId);
         return request.isRegisterInL1RequestQueue(register);
     }
 
     /**
      * @inheritdoc IRollupFacet
      */
     function isDepositInL1RequestQueue(
         Operations.Deposit memory deposit,
         uint64 requestId
     ) external view returns (bool) {
         RollupStorage.Layout storage rsl = RollupStorage.layout();
         if (rsl.isRequestIdGtOrEqCurRequestNum(requestId)) return false;
         Request memory request = rsl.getL1Request(requestId);
         return request.isDepositInL1RequestQueue(deposit);
     }
 
     /**
      * @inheritdoc IRollupFacet
      */
     function isForceWithdrawInL1RequestQueue(
         Operations.ForceWithdraw memory forceWithdraw,
         uint64 requestId
     ) external view returns (bool) {
         RollupStorage.Layout storage rsl = RollupStorage.layout();
         if (rsl.isRequestIdGtOrEqCurRequestNum(requestId)) return false;
         Request memory request = rsl.getL1Request(requestId);
         return request.isForceWithdrawInL1RequestQueue(forceWithdraw);
     }
 
     /**
      * @inheritdoc IRollupFacet
      */
     function isEvacuationInL1RequestQueue(
         Operations.Evacuation memory evacuation,
         uint64 requestId
     ) external view returns (bool) {
         RollupStorage.Layout storage rsl = RollupStorage.layout();
         if (rsl.isRequestIdGtOrEqCurRequestNum(requestId)) return false;
         Request memory request = rsl.getL1Request(requestId);
         return request.isEvacuationInL1RequestQueue(evacuation);
     }
 
+    /**
+     * @inheritdoc IRollupFacet
+     */
+    function isRollBorrowInL1RequestQueue(
+        Operations.RollBorrow memory rollBorrow,
+        uint64 requestId
+    ) external view returns (bool) {
+        RollupStorage.Layout storage rsl = RollupStorage.layout();
+        if (rsl.isRequestIdGtOrEqCurRequestNum(requestId)) return false;
+        Request memory request = rsl.getL1Request(requestId);
+        return request.isRollBorrowInL1RequestQueue(rollBorrow);
+    }
+
+    /**
+     * @inheritdoc IRollupFacet
+     */
+    function isForceCancelRollBorrowInL1RequestQueue(
+        Operations.CancelRollBorrow memory forceCancelRollBorrow,
+        uint64 requestId
+    ) external view returns (bool) {
+        RollupStorage.Layout storage rsl = RollupStorage.layout();
+        if (rsl.isRequestIdGtOrEqCurRequestNum(requestId)) return false;
+        Request memory request = rsl.getL1Request(requestId);
+        return request.isForceCancelRollBorrowInL1RequestQueue(forceCancelRollBorrow);
+    }
+
     /**
      * @inheritdoc IRollupFacet
      */
     function getL1Request(uint64 requestId) external view returns (Request memory) {
         return RollupStorage.layout().getL1Request(requestId);
     }
 
     /**
      * @inheritdoc IRollupFacet
      */
     function getL1RequestNum() external view returns (uint64, uint64, uint64) {
         RollupStorage.Layout storage rsl = RollupStorage.layout();
         return (rsl.getCommittedL1RequestNum(), rsl.getExecutedL1RequestNum(), rsl.getTotalL1RequestNum());
     }
 
     /**
      * @inheritdoc IRollupFacet
      */
     function getBlockNum() external view returns (uint32, uint32, uint32) {
         RollupStorage.Layout storage rsl = RollupStorage.layout();
         return (rsl.getCommittedBlockNum(), rsl.getVerifiedBlockNum(), rsl.getExecutedBlockNum());
     }
 
     /**
      * @inheritdoc IRollupFacet
      */
     function getStoredBlockHash(uint32 blockNum) external view returns (bytes32) {
         return RollupStorage.layout().getStoredBlockHash(blockNum);
     }
 
     /**
      * @inheritdoc IRollupFacet
      */
     function getPendingBalances(address accountAddr, IERC20 token) external view returns (uint256) {
         uint16 tokenId = TokenStorage.layout().getTokenId(token);
         bytes22 key = RollupLib.calcPendingBalanceKey(accountAddr, tokenId);
         return RollupStorage.layout().getPendingBalances(key);
     }
 
     /* ============ Internal Functions ============ */
 
     /// @notice Internal function to commit blocks
-    /// @param rsl RollupStorage Layout
+    /// @param rsl The rollup storage layout
     /// @param lastCommittedBlock Last committed block
     /// @param newBlocks New blocks to commit
     /// @param processRequestFunc The process request function
     ///        if the block is normal block, the function is _processOneRequest
     ///        if the block is evacuation block, the function is _processOneEvacuRequest
     function _commitBlocks(
         RollupStorage.Layout storage rsl,
         StoredBlock memory lastCommittedBlock,
         CommitBlock[] calldata newBlocks,
         function(RollupStorage.Layout storage, bytes calldata, uint256, uint64, bytes32)
             internal
             view
             returns (uint64, bytes32) processRequestFunc
     ) internal {
         rsl.requireBlockHashIsEq(rsl.getCommittedBlockNum(), lastCommittedBlock);
 
         uint64 committedL1RequestNum = rsl.getCommittedL1RequestNum();
         for (uint32 i; i < newBlocks.length; ++i) {
             CommitBlock calldata newBlock = newBlocks[i];
 
             // if evacuation blocks, check the block only includes the evacuation request and noop
             if (processRequestFunc == _processOneEvacuRequest) {
                 _requireValidEvacuBlockChunkIdDelta(newBlock.chunkIdDeltas);
                 _requireValidEvacuBlockPubData(newBlock.chunkIdDeltas.length, newBlock.publicData);
             }
 
             lastCommittedBlock = _commitOneBlock(
                 rsl,
                 lastCommittedBlock,
                 newBlock,
                 committedL1RequestNum,
                 processRequestFunc
             );
 
             committedL1RequestNum += lastCommittedBlock.l1RequestNum;
             rsl.storedBlockHashes[lastCommittedBlock.blockNumber] = keccak256(abi.encode(lastCommittedBlock));
             emit BlockCommit(lastCommittedBlock.blockNumber, lastCommittedBlock.commitment);
         }
 
         if (committedL1RequestNum > rsl.getTotalL1RequestNum())
             revert CommittedRequestNumExceedTotalNum(committedL1RequestNum);
 
         rsl.committedL1RequestNum = committedL1RequestNum;
         rsl.committedBlockNum += uint32(newBlocks.length);
     }
 
     /// @notice Internal function to commit one block
     /// @param rsl Rollup storage layout
     /// @param previousBlock The previous block
     /// @param newBlock The new block to be committed
     /// @param committedL1RequestNum The committed L1 request number
     /// @param processRequestFunc The process request function
     ///        if the block is normal block, the function is _processOneRequest
     ///        if the block is evacuation block, the function is _processOneEvacuRequest
     /// @return storedBlock The committed block
     function _commitOneBlock(
         RollupStorage.Layout storage rsl,
         StoredBlock memory previousBlock,
         CommitBlock calldata newBlock,
         uint64 committedL1RequestNum,
         function(RollupStorage.Layout storage, bytes calldata, uint256, uint64, bytes32)
             internal
             view
             returns (uint64, bytes32) processRequestFunc
     ) internal view returns (StoredBlock memory) {
         newBlock.blockNumber.requireValidBlockNum(previousBlock.blockNumber);
         newBlock.timestamp.requireValidBlockTimestamp(previousBlock.timestamp);
         newBlock.publicData.length.requireValidPubDataLength();
 
         // The commitment offset array is used to store the commitment offset for each chunk
         bytes memory commitmentOffset = new bytes(newBlock.publicData.length / Config.BITS_OF_CHUNK);
         uint256 chunkId;
         uint64 requestId = committedL1RequestNum;
         bytes32 processableRollupTxHash = Config.EMPTY_STRING_KECCAK;
         uint256 chunkIdDeltaLength = newBlock.chunkIdDeltas.length;
         for (uint256 i; i < chunkIdDeltaLength; ++i) {
             chunkId += newBlock.chunkIdDeltas[i];
             uint256 offset = chunkId * Config.BYTES_OF_CHUNK;
             if (offset >= newBlock.publicData.length) revert OffsetGtPubDataLength(offset);
 
             (requestId, processableRollupTxHash) = processRequestFunc(
                 rsl,
                 newBlock.publicData,
                 offset,
                 requestId,
                 processableRollupTxHash
             );
 
             commitmentOffset = _updateCommitmentOffsetForChunk(commitmentOffset, chunkId);
         }
 
         uint64 processedL1RequestNum = requestId - committedL1RequestNum;
-        bytes32 commitment = _calcBlockCommitment(previousBlock, newBlock, commitmentOffset);
+        bytes32 commitment = RollupLib.calcBlockCommitment(previousBlock, newBlock, commitmentOffset);
         return
             StoredBlock({
                 blockNumber: newBlock.blockNumber,
                 l1RequestNum: processedL1RequestNum,
                 pendingRollupTxHash: processableRollupTxHash,
                 commitment: commitment,
                 stateRoot: newBlock.newStateRoot,
                 timestamp: newBlock.timestamp
             });
     }
 
     /// @notice Internal function to check whether the chunk id delta is valid when commit evacuation block
     /// @dev The evacuation block only includes the evacuation request or noop,
     ///      so the first chunk id delta should be 0 and the remaining chunk id delta should be evacuation chunk size
     /// @param chunkIdDeltas The chunk id delta array
     function _requireValidEvacuBlockChunkIdDelta(uint16[] calldata chunkIdDeltas) internal pure {
         uint256 chunkIdDeltaLength = chunkIdDeltas.length;
 
         // If there are chunk ID deltas and the first one is not 0, revert
         if (chunkIdDeltaLength != 0 && chunkIdDeltas[0] != 0) revert InvalidChunkIdDelta(chunkIdDeltas);
 
-        // check every chunk id delta is equal to evacuation chunk size
+        // check every chunk id delta (not include the first one) ) is equal to evacuation chunk size
         uint256 andDeltas = Config.EVACUATION_CHUNK_SIZE;
         uint256 orDeltas = Config.EVACUATION_CHUNK_SIZE;
         for (uint256 i = 1; i < chunkIdDeltaLength; ++i) {
-            andDeltas &= chunkIdDeltas[i];
-            orDeltas |= chunkIdDeltas[i];
+            uint16 chunkIdDelta = chunkIdDeltas[i];
+            andDeltas &= chunkIdDelta;
+            orDeltas |= chunkIdDelta;
         }
 
         // If there is inconsistency in delta values, revert
         // This will occur if at least one chunk ID delta is not equal to the size of an evacuation chunk
         if (andDeltas != orDeltas) revert InvalidChunkIdDelta(chunkIdDeltas);
     }
 
     /// @notice Internal function to check whether the evacuation block pubdata is valid
     /// @dev The evacuation block only includes the evacuation request,
     ///      so the pubdata length should be evacuation request number * evacuation chunk size
     ///      and remaining pubdata should be padded with 0 bytes and have no other values
     /// @param evacuationRequestNum The number of evacuation requests
     /// @param pubData The public data of the block
     function _requireValidEvacuBlockPubData(uint256 evacuationRequestNum, bytes calldata pubData) internal pure {
         uint256 validBytesNum = evacuationRequestNum * Config.BYTES_OF_TWO_CHUNKS; // evacuation request is 2 chunks
         if (pubData.length < validBytesNum) revert InvalidEvacuBlockPubData(evacuationRequestNum);
         bytes4 errorSelector = InvalidEvacuBlockPubData.selector;
 
         // solhint-disable-next-line no-inline-assembly
         assembly {
             let data
             // check each 32 bytes in zero length
             let zeroLen := sub(pubData.length, validBytesNum)
             let curr := add(pubData.offset, validBytesNum)
             let end := add(curr, mul(div(zeroLen, 0x20), 0x20))
             // solhint-disable-next-line no-empty-blocks
             for {
 
             } lt(curr, end) {
                 curr := add(curr, 0x20)
             } {
                 data := or(data, calldataload(curr))
             }
 
             // check remainders bytes in zero length
             let r := mod(zeroLen, 0x20)
             // shift right (0x20 - r) bytes to remove the garbage data
             let endData := shr(mul(sub(0x20, r), 0x8), calldataload(end))
             data := or(data, endData)
 
             // if data is not zero, revert
             if data {
                 mstore(0x00, errorSelector)
                 mstore(0x04, evacuationRequestNum)
                 revert(0x00, 0x24)
             }
         }
     }
 
-    /// @notice Internal function to check whether the all non-executed L1 requests are consumed
-    /// @param rsl Rollup storage layout
-    function _requireConsumedAllNonExecutedReq(RollupStorage.Layout storage rsl) internal view {
-        uint64 executedL1RequestNum = rsl.getExecutedL1RequestNum();
-        uint64 totalL1RequestNum = rsl.getTotalL1RequestNum();
-        uint64 lastL1RequestId = totalL1RequestNum - 1;
-        // the last executed L1 req == the total L1 req (end of consume)
-        if (executedL1RequestNum != totalL1RequestNum) {
-            // the last L1 req is evacuation (end of consume and someone already evacuated)
-            bool isLastL1RequestEvacuation = rsl.getL1Request(lastL1RequestId).opType == Operations.OpType.EVACUATION;
-            if (!isLastL1RequestEvacuation) revert NotConsumedAllL1Requests(executedL1RequestNum, totalL1RequestNum);
-        }
-    }
-
     /// @notice Internal function to update the commitment offset for the chunk
     /// @param commitmentOffset The commitment offset
     /// @param chunkId The chunk id
     /// @return newCommitmentOffset The updated commitment offset
     function _updateCommitmentOffsetForChunk(
         bytes memory commitmentOffset,
         uint256 chunkId
     ) internal pure returns (bytes memory) {
         // calc the chunk group index
         uint256 chunkGroupIdx = chunkId / Config.BITS_OF_BYTE;
 
         // get the processing commitment offset by chunk group index
         uint8 processingCommitmentOffset = uint8(commitmentOffset[chunkGroupIdx]);
 
         // calc the bitwise mask for target chunk id
         // (chunkId % Config.BITS_OF_BYTE): which bit in the group
         // LAST_INDEX_OF_BYTE - (chunkId % Config.BITS_OF_BYTE): big endian to little endian
         uint8 bitwiseMask = uint8(1 << (Config.LAST_INDEX_OF_BYTE - (chunkId % Config.BITS_OF_BYTE)));
         if (processingCommitmentOffset & bitwiseMask != 0) revert OffsetIsSet(chunkId);
 
         // set commitment offset to 1 for target chunk id
         commitmentOffset[chunkGroupIdx] = bytes1(processingCommitmentOffset | bitwiseMask);
         return commitmentOffset;
     }
 
     /// @notice Process one request
     /// @param rsl The rollup storage layout
     /// @param pubData The public data of the new block
     /// @param offset The offset of the public data
     /// @param requestId The request id of the new block
     /// @param processableRollupTxHash The processable rollup tx hash
     /// @return newRequestId The new L1 request id
     /// @dev newRequestId is used to increase the L1 request id if the processed request is L1 request
     /// @return newProcessableRollupTxHash The new processable rollup tx hash
     /// @dev newProcessableRollupTxHash will be updated if the processed request is to be executed
     function _processOneRequest(
         RollupStorage.Layout storage rsl,
         bytes calldata pubData,
         uint256 offset,
         uint64 requestId,
         bytes32 processableRollupTxHash
     ) internal view returns (uint64, bytes32) {
         bytes memory data;
         bool isL1Request;
         bool isToBeExecuted;
         Operations.OpType opType = Operations.OpType(uint8(pubData[offset]));
 
         // non L1 request
         if (opType == Operations.OpType.WITHDRAW) {
             data = pubData.sliceThreeChunksBytes(offset); // 3 chunks
             isToBeExecuted = true;
         } else if (opType == Operations.OpType.AUCTION_END) {
-            data = pubData.sliceFourChunksBytes(offset); // 4 chunks
+            data = pubData.sliceFiveChunksBytes(offset); // 5 chunks
+            isToBeExecuted = true;
+        } else if (opType == Operations.OpType.ROLL_OVER_END) {
+            data = pubData.sliceSixChunksBytes(offset); // 6 chunks
+            isToBeExecuted = true;
+        } else if (opType == Operations.OpType.USER_CANCEL_ROLL_BORROW) {
+            data = pubData.sliceTwoChunksBytes(offset); // 2 chunks
+            isToBeExecuted = true;
+        } else if (opType == Operations.OpType.ADMIN_CANCEL_ROLL_BORROW) {
+            data = pubData.sliceTwoChunksBytes(offset); // 2 chunks
             isToBeExecuted = true;
         } else if (opType == Operations.OpType.WITHDRAW_FEE) {
             data = pubData.sliceTwoChunksBytes(offset); // 2 chunks
             isToBeExecuted = true;
         } else if (opType == Operations.OpType.CREATE_TSB_TOKEN) {
             data = pubData.sliceOneChunkBytes(offset); // 1 chunk
             Operations.CreateTsbToken memory createTsbTokenReq = data.readCreateTsbTokenPubData();
             TokenStorage.Layout storage tsl = TokenStorage.layout();
             AssetConfig memory tokenConfig = tsl.getAssetConfig(createTsbTokenReq.tsbTokenId);
-            (IERC20 underlyingAsset, uint32 maturityTime) = ITsbToken(address(tokenConfig.token)).tokenInfo();
+            (IERC20 underlyingToken, uint32 maturityTime) = ITsbToken(address(tokenConfig.token)).tokenInfo();
             if (maturityTime != createTsbTokenReq.maturityTime)
                 revert MaturityTimeIsNotMatched(maturityTime, createTsbTokenReq.maturityTime);
 
             tokenConfig = tsl.getAssetConfig(createTsbTokenReq.baseTokenId);
-            if (underlyingAsset != tokenConfig.token) revert TokenIsNotMatched(underlyingAsset, tokenConfig.token);
+            if (underlyingToken != tokenConfig.token) revert TokenIsNotMatched(underlyingToken, tokenConfig.token);
         } else {
             // L1 request
             isL1Request = true;
             Request memory request = rsl.getL1Request(requestId);
             if (opType == Operations.OpType.REGISTER) {
                 data = pubData.sliceThreeChunksBytes(offset); // 3 chunks
                 Operations.Register memory register = data.readRegisterPubData();
                 request.isRegisterInL1RequestQueue(register);
             } else if (opType == Operations.OpType.DEPOSIT) {
                 data = pubData.sliceTwoChunksBytes(offset); // 2 chunks
                 Operations.Deposit memory deposit = data.readDepositPubData();
                 request.isDepositInL1RequestQueue(deposit);
+            } else if (opType == Operations.OpType.ROLL_BORROW_ORDER) {
+                data = pubData.sliceSixChunksBytes(offset); // 6 chunks
+                Operations.RollBorrow memory rollBorrowReq = data.readRollBorrowPubdata();
+                request.isRollBorrowInL1RequestQueue(rollBorrowReq);
+            } else if (opType == Operations.OpType.FORCE_CANCEL_ROLL_BORROW) {
+                data = pubData.sliceTwoChunksBytes(offset); // 2 chunks
+                isToBeExecuted = true;
             } else if (opType == Operations.OpType.FORCE_WITHDRAW) {
                 data = pubData.sliceTwoChunksBytes(offset); // 2 chunks
                 Operations.ForceWithdraw memory forceWithdrawReq = data.readForceWithdrawPubData();
                 request.isForceWithdrawInL1RequestQueue(forceWithdrawReq);
                 isToBeExecuted = true;
             } else {
                 revert InvalidOpType(opType);
             }
         }
         // If processed request is L1 request, increase the L1 request id
         if (isL1Request) ++requestId;
         // If processed request is to be executed, update the processable rollup tx hash for executing the request when executeBlock
         if (isToBeExecuted) processableRollupTxHash = keccak256(abi.encode(processableRollupTxHash, data));
 
         return (requestId, processableRollupTxHash);
     }
 
     /// @notice Process one evacuation request
     /// @param rsl The rollup storage layout
     /// @param pubData The public data of the new block
     /// @param offset The offset of the public data
     /// @param requestId The request id of the new block
     /// @param processableRollupTxHash The processable rollup tx hash
     /// @return newRequestId The new L1 request id
     /// @return newProcessableRollupTxHash The new processable rollup tx hash
     function _processOneEvacuRequest(
         RollupStorage.Layout storage rsl,
         bytes calldata pubData,
         uint256 offset,
         uint64 requestId,
         bytes32 processableRollupTxHash
     ) internal view returns (uint64, bytes32) {
         Operations.OpType opType = Operations.OpType(uint8(pubData[offset]));
         if (opType != Operations.OpType.EVACUATION) revert InvalidOpType(opType);
 
         bytes memory data = pubData.sliceTwoChunksBytes(offset); // 2 chunks
         Operations.Evacuation memory evacuation = data.readEvacuationPubdata();
         rsl.getL1Request(requestId).isEvacuationInL1RequestQueue(evacuation);
         processableRollupTxHash = keccak256(abi.encode(processableRollupTxHash, data));
 
         return (++requestId, processableRollupTxHash);
     }
 
     /// @notice Internal function to verify blocks
     /// @param rsl The rollup storage layout
     /// @param verifyingBlocks The verifying blocks
     function _verifyBlocks(RollupStorage.Layout storage rsl, VerifyBlock[] calldata verifyingBlocks) internal {
         uint32 verifiedBlockNum = rsl.getVerifiedBlockNum();
         uint256 verifyingBlocksLength = verifyingBlocks.length;
         if (verifiedBlockNum + verifyingBlocksLength > rsl.getCommittedBlockNum())
             revert VerifiedBlockNumExceedCommittedNum(verifyingBlocksLength);
 
         for (uint256 i; i < verifyingBlocksLength; ++i) {
             ++verifiedBlockNum;
             VerifyBlock calldata verifyingBlock = verifyingBlocks[i];
             rsl.requireBlockHashIsEq(verifiedBlockNum, verifyingBlock.storedBlock);
 
-            _verifyOneBlock(
+            RollupLib.verifyOneBlock(
                 verifyingBlock.storedBlock.commitment,
                 verifyingBlock.proof,
                 AddressStorage.layout().getVerifier()
             );
             emit BlockVerification(verifyingBlock.storedBlock.blockNumber);
         }
         rsl.verifiedBlockNum = verifiedBlockNum;
     }
 
-    /// @notice Internal function to verify one block
-    /// @param commitment The commitment of the block
-    /// @param proof The proof of the block
-    /// @param verifier The verifier contract
-    ///        if the block is normal block, use the AddressStorage.verifier (for normal circuit)
-    ///        if the block is evacuation block, use the AddressStorage.evacuVerifier (for evacuation circuit)
-    function _verifyOneBlock(bytes32 commitment, Proof calldata proof, IVerifier verifier) internal view {
-        if (proof.commitment[0] != uint256(commitment) % Config.SCALAR_FIELD_SIZE)
-            revert CommitmentInconsistant(proof.commitment[0], uint256(commitment));
-
-        if (!verifier.verifyProof(proof.a, proof.b, proof.c, proof.commitment)) revert InvalidProof(proof);
-    }
-
     /// @notice Internal function to execute blocks
     /// @param rsl The rollup storage layout
     /// @param pendingBlocks The pending blocks
     function _executeBlocks(RollupStorage.Layout storage rsl, ExecuteBlock[] calldata pendingBlocks) internal {
         uint32 executedBlockNum = rsl.getExecutedBlockNum();
         uint256 pendingBlocksLength = pendingBlocks.length;
         if (executedBlockNum + pendingBlocksLength > rsl.getVerifiedBlockNum())
             revert ExecutedBlockNumExceedProvedNum(pendingBlocksLength);
 
         uint64 executedL1RequestNum = rsl.getExecutedL1RequestNum();
         for (uint32 i; i < pendingBlocksLength; ++i) {
             ExecuteBlock calldata pendingBlock = pendingBlocks[i];
             rsl.requireBlockHashIsEq(pendingBlock.storedBlock.blockNumber, pendingBlock.storedBlock);
 
             ++executedBlockNum;
             if (pendingBlock.storedBlock.blockNumber != executedBlockNum)
                 revert InvalidExecutedBlockNum(pendingBlock.storedBlock.blockNumber);
 
             _executeOneBlock(rsl, pendingBlock);
 
             executedL1RequestNum += pendingBlock.storedBlock.l1RequestNum;
             emit BlockExecution(pendingBlock.storedBlock.blockNumber);
         }
         rsl.executedBlockNum = executedBlockNum;
         rsl.executedL1RequestNum = executedL1RequestNum;
     }
 
     /// @notice Internal function to execute one block
     /// @param rsl The rollup storage layout
     /// @param executeBlock The block to be executed
     function _executeOneBlock(RollupStorage.Layout storage rsl, ExecuteBlock calldata executeBlock) internal {
         bytes32 pendingRollupTxHash = Config.EMPTY_STRING_KECCAK;
         bytes memory pubData;
         for (uint32 i; i < executeBlock.pendingRollupTxPubData.length; ++i) {
             pubData = executeBlock.pendingRollupTxPubData[i];
             Operations.OpType opType = Operations.OpType(uint8(pubData[0]));
             if (opType == Operations.OpType.WITHDRAW) {
                 Operations.Withdraw memory withdrawReq = pubData.readWithdrawPubData();
-                _addPendingBalance(rsl, withdrawReq.accountId, withdrawReq.tokenId, withdrawReq.amount);
+                rsl.addPendingBalance(withdrawReq.accountId, withdrawReq.tokenId, withdrawReq.amount);
             } else if (opType == Operations.OpType.FORCE_WITHDRAW) {
                 Operations.ForceWithdraw memory forceWithdrawReq = pubData.readForceWithdrawPubData();
-                _addPendingBalance(rsl, forceWithdrawReq.accountId, forceWithdrawReq.tokenId, forceWithdrawReq.amount);
+                rsl.addPendingBalance(forceWithdrawReq.accountId, forceWithdrawReq.tokenId, forceWithdrawReq.amount);
             } else if (opType == Operations.OpType.AUCTION_END) {
                 Operations.AuctionEnd memory auctionEnd = pubData.readAuctionEndPubData();
                 _updateLoan(auctionEnd);
+            } else if (opType == Operations.OpType.ROLL_OVER_END) {
+                Operations.RollOverEnd memory rollOver = pubData.readRollOverEndPubdata();
+                _rollOver(rollOver);
+            } else if (
+                opType == Operations.OpType.USER_CANCEL_ROLL_BORROW ||
+                opType == Operations.OpType.ADMIN_CANCEL_ROLL_BORROW ||
+                opType == Operations.OpType.FORCE_CANCEL_ROLL_BORROW
+            ) {
+                Operations.CancelRollBorrow memory cancelRollBorrow = pubData.readCancelRollBorrowPubdata();
+                _cancelRollBorrow(cancelRollBorrow);
             } else if (opType == Operations.OpType.WITHDRAW_FEE) {
                 Operations.WithdrawFee memory withdrawFee = pubData.readWithdrawFeePubdata();
                 _withdrawFee(rsl, withdrawFee);
             } else if (opType == Operations.OpType.EVACUATION) {
                 Operations.Evacuation memory evacuation = pubData.readEvacuationPubdata();
-                rsl.evacuated[evacuation.accountId][evacuation.tokenId] = false;
+                EvacuationStorage.layout().evacuated[evacuation.accountId][evacuation.tokenId] = false;
             } else {
                 revert InvalidOpType(opType);
             }
             pendingRollupTxHash = keccak256(abi.encode(pendingRollupTxHash, pubData));
         }
 
         if (pendingRollupTxHash != executeBlock.storedBlock.pendingRollupTxHash)
             revert PendingRollupTxHashIsNotMatched(pendingRollupTxHash, executeBlock.storedBlock.pendingRollupTxHash);
     }
 
-    /// @notice Internal function to add the pending balance of an account
-    /// @param rsl The rollup storage
-    /// @param accountId The id of the account
-    /// @param tokenId The id of the token
-    /// @param l2Amt The amount of the token in L2
-    function _addPendingBalance(
-        RollupStorage.Layout storage rsl,
-        uint32 accountId,
-        uint16 tokenId,
-        uint128 l2Amt
-    ) internal {
-        address accountAddr = AccountStorage.layout().getAccountAddr(accountId);
-        Utils.notZeroAddr(accountAddr);
+    /// @notice Internal function to cancel roll borrow
+    /// @dev The function will remove all locked collateral
+    /// @dev The function will be triggered by these 3 request types:
+    ///      1. `USER_CANCEL_ROLL_BORROW`
+    ///      2. `ADMIN_CANCEL_ROLL_BORROW`
+    ///      3. `FORCE_CANCEL_ROLL_BORROW`
+    /// @param cancelRollBorrow The cancel roll borrow request
+    function _cancelRollBorrow(Operations.CancelRollBorrow memory cancelRollBorrow) internal {
+        LoanStorage.Layout storage lsl = LoanStorage.layout();
+        bytes12 loanId = LoanLib.calcLoanId(
+            cancelRollBorrow.accountId,
+            cancelRollBorrow.maturityTime,
+            cancelRollBorrow.debtTokenId,
+            cancelRollBorrow.collateralTokenId
+        );
+        Loan memory loan = lsl.getLoan(loanId);
+
+        // remove all locked collateral
+        uint128 removedCollateralAmt = loan.lockedCollateralAmt;
+        loan.removeLockedCollateral(removedCollateralAmt);
+        lsl.loans[loanId] = loan;
+
+        emit RollBorrowCancel(loanId, removedCollateralAmt);
+    }
+
+    /// @notice Internal function to roll over (successfully roll a loan to the next maturity time)
+    /// @dev The function will move the original loan position to the new loan position
+    /// @param rollOver The roll over request
+    function _rollOver(Operations.RollOverEnd memory rollOver) internal {
+        // solhint-disable-next-line not-rely-on-time
+        if (rollOver.matchedTime >= block.timestamp) revert InvalidMatchedTime(rollOver.matchedTime, block.timestamp);
+        // solhint-disable-next-line not-rely-on-time
+        if (rollOver.oldMaturityTime <= block.timestamp)
+            // solhint-disable-next-line not-rely-on-time
+            revert InvalidOldMaturityTime(rollOver.oldMaturityTime, block.timestamp);
+        if (rollOver.newMaturityTime <= rollOver.oldMaturityTime)
+            revert InvalidNewMaturityTime(rollOver.newMaturityTime, rollOver.oldMaturityTime);
 
         TokenStorage.Layout storage tsl = TokenStorage.layout();
-        AssetConfig memory assetConfig = tsl.getAssetConfig(tokenId);
-        Utils.notZeroAddr(address(assetConfig.token));
+        AssetConfig memory asset = tsl.getAssetConfig(rollOver.collateralTokenId);
+        Utils.notZeroAddr(address(asset.token));
+
+        // repay old loan position
+        bytes12 loanId = LoanLib.calcLoanId(
+            rollOver.accountId,
+            rollOver.oldMaturityTime,
+            rollOver.debtTokenId,
+            rollOver.collateralTokenId
+        );
+        LoanStorage.Layout storage lsl = LoanStorage.layout();
+        Loan memory loan = lsl.getLoan(loanId);
+        uint8 decimals = asset.decimals;
+        uint128 collateralAmt = rollOver.collateralAmt.toL1Amt(decimals).toUint128();
+        if (collateralAmt > loan.lockedCollateralAmt)
+            revert RemovedCollateralAmtGtLockedCollateralAmt(collateralAmt, loan.lockedCollateralAmt);
+
+        asset = tsl.getAssetConfig(rollOver.debtTokenId); // re-assign asset to debt token
+        Utils.notZeroAddr(address(asset.token));
+
+        decimals = asset.decimals; // re-assign decimals to debt token decimals
+        uint128 borrowAmt = rollOver.borrowAmt.toL1Amt(decimals).toUint128();
+        loan.repay(collateralAmt, borrowAmt);
+        loan.removeLockedCollateral(collateralAmt);
+        lsl.loans[loanId] = loan;
 
-        uint256 l1Amt = l2Amt.toL1Amt(assetConfig.decimals);
-        rsl.addPendingBalance(accountAddr, tokenId, l1Amt);
+        // update new loan position
+        bytes12 newLoanId = LoanLib.calcLoanId(
+            rollOver.accountId,
+            rollOver.newMaturityTime,
+            rollOver.debtTokenId,
+            rollOver.collateralTokenId
+        );
+        loan = lsl.getLoan(newLoanId);
+        uint128 newDebtAmt = rollOver.debtAmt.toL1Amt(decimals).toUint128();
+        loan.updateLoan(collateralAmt, newDebtAmt);
+        lsl.loans[newLoanId] = loan;
+
+        emit RollOver(loanId, newLoanId, collateralAmt, borrowAmt, newDebtAmt);
     }
 
-    /// @notice Internal function to update the onchain loan info
+    /// @notice Internal function to update the on-chain loan info
     /// @param auctionEnd The auction end request
     function _updateLoan(Operations.AuctionEnd memory auctionEnd) internal {
-        uint32 accountId = auctionEnd.accountId;
-        address accountAddr = AccountStorage.layout().getAccountAddr(accountId);
+        address accountAddr = AccountStorage.layout().getAccountAddr(auctionEnd.accountId);
         Utils.notZeroAddr(accountAddr);
 
         TokenStorage.Layout storage tsl = TokenStorage.layout();
-        // tsbToken config
-        AssetConfig memory assetConfig = tsl.getAssetConfig(auctionEnd.tsbTokenId);
-        address tokenAddr = address(assetConfig.token);
-        Utils.notZeroAddr(tokenAddr);
-        ITsbToken tsbToken = ITsbToken(tokenAddr);
-        if (!assetConfig.isTsbToken) revert InvalidTsbTokenAddr(tokenAddr);
-
-        (bytes12 loanId, Loan memory newLoan) = _getAuctionInfo(tsl, auctionEnd, tsbToken);
+        (bytes12 loanId, uint128 collateralAmt, uint128 debtAmt) = _getAuctionInfo(tsl, auctionEnd);
 
         // update loan
         LoanStorage.Layout storage lsl = LoanStorage.layout();
         Loan memory loan = lsl.getLoan(loanId);
-        loan = loan.updateLoan(newLoan.collateralAmt, newLoan.debtAmt);
+        loan.updateLoan(collateralAmt, debtAmt);
         lsl.loans[loanId] = loan;
 
-        emit UpdateLoan(loanId, accountId, newLoan.collateralAmt, newLoan.debtAmt);
+        emit UpdateLoan(loanId, collateralAmt, debtAmt);
     }
 
     /// @notice Internal function to get the auction info
     /// @param tsl The token storage
     /// @param auctionEnd The auction end request
-    /// @param tsbToken The tsbToken
     function _getAuctionInfo(
         TokenStorage.Layout storage tsl,
-        Operations.AuctionEnd memory auctionEnd,
-        ITsbToken tsbToken
-    ) internal view virtual returns (bytes12, Loan memory) {
+        Operations.AuctionEnd memory auctionEnd
+    ) internal view virtual returns (bytes12, uint128, uint128) {
+        bytes12 loanId = LoanLib.calcLoanId(
+            auctionEnd.accountId,
+            auctionEnd.maturityTime,
+            auctionEnd.debtTokenId,
+            auctionEnd.collateralTokenId
+        );
+        AssetConfig memory assetConfig = tsl.getAssetConfig(auctionEnd.debtTokenId);
+        uint128 debtAmt = auctionEnd.debtAmt.toL1Amt(assetConfig.decimals).toUint128();
+
         // collateral token config
-        uint16 collateralTokenId = auctionEnd.collateralTokenId;
-        AssetConfig memory assetConfig = tsl.getAssetConfig(collateralTokenId);
+        assetConfig = tsl.getAssetConfig(auctionEnd.collateralTokenId);
         Utils.notZeroAddr(address(assetConfig.token));
+        uint128 collateralAmt = auctionEnd.collateralAmt.toL1Amt(assetConfig.decimals).toUint128();
 
-        Loan memory loan;
-        uint8 decimals = assetConfig.decimals;
-        loan.collateralAmt = SafeCast.toUint128(auctionEnd.collateralAmt.toL1Amt(decimals));
-
-        // debt token config
-        (IERC20 underlyingAsset, uint32 maturityTime) = tsbToken.tokenInfo();
-        (uint16 debtTokenId, AssetConfig memory underlyingAssetConfig) = tsl.getAssetConfig(underlyingAsset);
-        decimals = underlyingAssetConfig.decimals;
-        loan.debtAmt = SafeCast.toUint128(auctionEnd.debtAmt.toL1Amt(decimals));
-        bytes12 loanId = LoanLib.calcLoanId(auctionEnd.accountId, maturityTime, debtTokenId, collateralTokenId);
-
-        return (loanId, loan);
+        return (loanId, collateralAmt, debtAmt);
     }
 
     /// @notice Internal function to withdraw fee to treasury, vault, and insurance
     /// @param rsl The rollup storage
     /// @param withdrawFee The withdraw fee request
     function _withdrawFee(RollupStorage.Layout storage rsl, Operations.WithdrawFee memory withdrawFee) internal {
         uint16 tokenId = withdrawFee.tokenId;
         AssetConfig memory assetConfig = TokenStorage.layout().getAssetConfig(tokenId);
         uint256 l1Amt = withdrawFee.amount.toL1Amt(assetConfig.decimals);
         ProtocolParamsStorage.Layout storage ppsl = ProtocolParamsStorage.layout();
         FundWeight memory fundWeight = ppsl.getFundWeight();
 
         // insurance
         address toAddr = ppsl.getInsuranceAddr();
         Utils.notZeroAddr(toAddr);
         uint256 insuranceAmt = l1Amt.mulDiv(fundWeight.insurance, Config.FUND_WEIGHT_BASE);
         rsl.addPendingBalance(toAddr, tokenId, insuranceAmt);
 
         // vault
         toAddr = ppsl.getVaultAddr();
         Utils.notZeroAddr(toAddr);
         uint256 vaultAmt = l1Amt.mulDiv(fundWeight.vault, Config.FUND_WEIGHT_BASE);
         rsl.addPendingBalance(toAddr, tokenId, vaultAmt);
 
         // treasury
         toAddr = ppsl.getTreasuryAddr();
         Utils.notZeroAddr(toAddr);
         uint256 treasuryAmt = l1Amt - insuranceAmt - vaultAmt;
         rsl.addPendingBalance(toAddr, tokenId, treasuryAmt);
     }
-
-    /// @notice Internal function to evacuate token to L1
-    /// @param rsl The rollup storage layout
-    /// @param evacuation The evacuation request
-    function _evacuate(RollupStorage.Layout storage rsl, Operations.Evacuation memory evacuation) internal {
-        uint32 accountId = evacuation.accountId;
-        uint16 tokenId = evacuation.tokenId;
-        if (rsl.isEvacuated(accountId, tokenId)) revert Evacuated(accountId, tokenId);
-
-        address receiver = AccountStorage.layout().getAccountAddr(accountId);
-        Utils.notZeroAddr(receiver);
-
-        AssetConfig memory assetConfig = TokenStorage.layout().getAssetConfig(tokenId);
-        IERC20 token = assetConfig.token;
-        Utils.notZeroAddr(address(token));
-
-        rsl.evacuated[accountId][tokenId] = true;
-
-        bytes memory pubData = Operations.encodeEvacuationPubData(evacuation);
-        rsl.addL1Request(receiver, Operations.OpType.EVACUATION, pubData);
-
-        uint256 l1Amt = evacuation.amount.toL1Amt(assetConfig.decimals);
-        Utils.tokenTransfer(token, payable(receiver), l1Amt, assetConfig.isTsbToken);
-
-        emit Evacuation(receiver, accountId, token, tokenId, l1Amt);
-    }
-
-    /// @notice Internal function calculate the commitment of the new block
-    /// @dev    newTsRoot is packed in commitment for data availablity and will be proved in the circuit
-    /// @param previousBlock The previous block
-    /// @param newBlock The new block to be committed
-    /// @param commitmentOffset The offset of the commitment
-    /// @return commitment The commitment of the new block
-    function _calcBlockCommitment(
-        StoredBlock memory previousBlock,
-        CommitBlock calldata newBlock,
-        bytes memory commitmentOffset
-    ) internal pure returns (bytes32) {
-        return
-            sha256(
-                abi.encodePacked(
-                    previousBlock.stateRoot,
-                    newBlock.newStateRoot,
-                    newBlock.newTsRoot,
-                    newBlock.timestamp,
-                    commitmentOffset,
-                    newBlock.publicData
-                )
-            );
-    }
 }
diff --git a/contracts/zkTrueUp/rollup/RollupLib.sol b/contracts/zkTrueUp/rollup/RollupLib.sol
index 170def7..a9cc544 100644
--- a/contracts/zkTrueUp/rollup/RollupLib.sol
+++ b/contracts/zkTrueUp/rollup/RollupLib.sol
@@ -1,327 +1,406 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
-import {RollupStorage, Request, StoredBlock} from "./RollupStorage.sol";
+import {IVerifier} from "../interfaces/IVerifier.sol";
+import {AccountStorage} from "../account/AccountStorage.sol";
+import {TokenStorage, AssetConfig} from "../token/TokenStorage.sol";
+import {RollupStorage, Request, StoredBlock, CommitBlock, Proof} from "./RollupStorage.sol";
+import {AccountLib} from "../account/AccountLib.sol";
+import {TokenLib} from "../token/TokenLib.sol";
 import {Config} from "../libraries/Config.sol";
 import {Operations} from "../libraries/Operations.sol";
+import {Utils} from "../libraries/Utils.sol";
 
 /**
  * @title Term Structure Rollup Library
  * @author Term Structure Labs
  */
 library RollupLib {
+    using TokenLib for TokenStorage.Layout;
+    using AccountLib for AccountStorage.Layout;
     using RollupLib for RollupStorage.Layout;
+    using Utils for *;
 
     /// @notice Error for withdraw amount exceed pending balance
     error InsufficientPendingBalances(uint256 pendingBalance, uint256 withdrawAmt);
-    /// @notice Error for trying to do transactions when evacuation mode is activated
-    error EvacuModeActivated();
-    /// @notice Error for the system is not in evacuation mode
-    error NotEvacuMode();
     /// @notice Error for operation type is not matched
     error OpTypeIsNotMatched(Operations.OpType requestOpType, Operations.OpType expectedOpType);
     /// @notice Error for block hash is not equal
     error BlockHashIsNotEq(uint32 blockNum, StoredBlock storedBlock);
     /// @notice Error for invalid block number
     error InvalidBlockNum(uint32 newBlockNum, uint32 lastBlockNum);
     /// @notice Error for new block timestamp is less than last block timestamp
     error TimestampLtPreviousBlock(uint256 newBlockTimestamp, uint256 lastBlockTimestamp);
     /// @notice Error for block timestamp is not in the valid range
     error InvalidBlockTimestamp(uint256 l2BlockTimestamp, uint256 l1BlockTimestamp);
     /// @notice Error for invalid invalid public data length
     error InvalidPubDataLength(uint256 pubDataLength);
+    /// @notice Error for evacuate but haven't consumed all L1 requests
+    error NotConsumedAllL1Requests(uint64 executedL1RequestNum, uint64 totalL1RequestNum);
+    /// @notice Error for inconsistent commitment
+    error CommitmentInconsistant(uint256 proofCommitment, uint256 committedBlockcommitment);
+    /// @notice Error for invalid proof
+    error InvalidProof(Proof proof);
 
     /// @notice Emit when there is a new priority request added
     /// @dev The L1 request needs to be executed before the expiration block or the system will enter the evacuation mode
     /// @param sender The address of the request sender
     /// @param requestId The id of the request
     /// @param opType The operation type of the request
     /// @param pubData The public data of the request
     /// @param expirationTime The expiration time of the request
     event L1Request(
         address indexed sender,
         uint64 requestId,
         Operations.OpType opType,
         bytes pubData,
         uint32 expirationTime
     );
 
+    /// @notice Internal function to verify one block
+    /// @param commitment The commitment of the block
+    /// @param proof The proof of the block
+    /// @param verifier The verifier contract
+    ///        if the block is normal block, use the AddressStorage.verifier (for normal circuit)
+    ///        if the block is evacuation block, use the AddressStorage.evacuVerifier (for evacuation circuit)
+    function verifyOneBlock(bytes32 commitment, Proof calldata proof, IVerifier verifier) internal view {
+        if (proof.commitment[0] != uint256(commitment) % Config.SCALAR_FIELD_SIZE)
+            revert CommitmentInconsistant(proof.commitment[0], uint256(commitment));
+
+        if (!verifier.verifyProof(proof.a, proof.b, proof.c, proof.commitment)) revert InvalidProof(proof);
+    }
+
     /// @notice Add the L1 request into L1 request queue
     /// @dev The pubData will be hashed with keccak256 and store in the priority queue with its expiration block and operation type
     /// @param s The rollup storage
-    /// @param sender The address of sender
+    /// @param accountAddr The L1 address
     /// @param opType The operation type of the priority request
     /// @param pubData The public data of the priority request
     function addL1Request(
         RollupStorage.Layout storage s,
-        address sender,
+        address accountAddr,
         Operations.OpType opType,
         bytes memory pubData
     ) internal {
         // solhint-disable-next-line not-rely-on-time
         uint32 expirationTime = uint32(block.timestamp + Config.EXPIRATION_PERIOD);
         uint64 requestId = s.getTotalL1RequestNum();
         bytes32 hashedPubData = keccak256(pubData);
         s.l1RequestQueue[requestId] = Request({
             hashedPubData: hashedPubData,
             expirationTime: expirationTime,
             opType: opType
         });
         s.totalL1RequestNum++;
-        emit L1Request(sender, requestId, opType, pubData, expirationTime);
+        emit L1Request(accountAddr, requestId, opType, pubData, expirationTime);
+    }
+
+    /// @notice Add the pending balance of the specified account id and token id
+    /// @param s The rollup storage
+    /// @param accountId The id of the account
+    /// @param tokenId The id of the token
+    /// @param l2Amt The amount of the token in L2
+    function addPendingBalance(
+        RollupStorage.Layout storage s,
+        uint32 accountId,
+        uint16 tokenId,
+        uint128 l2Amt
+    ) internal {
+        address accountAddr = AccountStorage.layout().getAccountAddr(accountId);
+        Utils.notZeroAddr(accountAddr);
+
+        TokenStorage.Layout storage tsl = TokenStorage.layout();
+        AssetConfig memory assetConfig = tsl.getAssetConfig(tokenId);
+        Utils.notZeroAddr(address(assetConfig.token));
+
+        uint256 l1Amt = l2Amt.toL1Amt(assetConfig.decimals);
+        s.addPendingBalance(accountAddr, tokenId, l1Amt);
     }
 
     /// @notice Add the pending balance of the specified address and token id
     /// @param s The rollup storage
     /// @param addr The address to be added
     /// @param tokenId The token id
     /// @param l1Amt The amount of the token
     function addPendingBalance(RollupStorage.Layout storage s, address addr, uint16 tokenId, uint256 l1Amt) internal {
         bytes22 key = calcPendingBalanceKey(addr, tokenId);
         s.pendingBalances[key] += l1Amt;
     }
 
     /// @notice Remove the pending balance of the specified address and token id
     /// @param s The rollup storage
     /// @param addr The address to be removed
     /// @param tokenId The token id on layer2
     /// @param amount The amount of the token
     function removePendingBalance(
         RollupStorage.Layout storage s,
         address addr,
         uint16 tokenId,
         uint256 amount
     ) internal {
         bytes22 key = calcPendingBalanceKey(addr, tokenId);
         uint256 pendingBalance = s.getPendingBalances(key);
         if (pendingBalance < amount) revert InsufficientPendingBalances(pendingBalance, amount);
         unchecked {
             s.pendingBalances[key] = pendingBalance - amount;
         }
     }
 
-    /// @notice Internal function to check if the contract is not in the evacuMode
-    /// @param s The rollup storage
-    function requireActive(RollupStorage.Layout storage s) internal view {
-        if (s.isEvacuMode()) revert EvacuModeActivated();
-    }
-
-    /// @notice Internal function to check if the contract is in the evacuMode
-    /// @param s The rollup storage
-    function requireEvacuMode(RollupStorage.Layout storage s) internal view {
-        if (!s.isEvacuMode()) revert NotEvacuMode();
-    }
-
-    /// @notice Internal function to get evacuation mode status
-    /// @param s The rollup storage
-    /// @return evacuMode The evacuation mode status
-    function isEvacuMode(RollupStorage.Layout storage s) internal view returns (bool) {
-        return s.evacuMode;
-    }
-
-    /// @notice Internal function to get whether the specified accountId and tokenId is evacuated
+    /// @notice Internal function to check whether the all non-executed L1 requests are consumed
     /// @param s The rollup storage
-    /// @param accountId The account id
-    /// @param tokenId The token id
-    /// @return isEvacuated Whether the specified accountId and tokenId is evacuated
-    function isEvacuated(
-        RollupStorage.Layout storage s,
-        uint32 accountId,
-        uint16 tokenId
-    ) internal view returns (bool) {
-        return s.evacuated[accountId][tokenId];
+    function requireConsumedAllNonExecutedReq(RollupStorage.Layout storage s) internal view {
+        uint64 executedL1RequestNum = s.getExecutedL1RequestNum();
+        uint64 totalL1RequestNum = s.getTotalL1RequestNum();
+        uint64 lastL1RequestId = totalL1RequestNum - 1;
+        // the last executed L1 req == the total L1 req (end of consume)
+        if (executedL1RequestNum != totalL1RequestNum) {
+            // the last L1 req is evacuation (end of consume and someone already evacuated)
+            bool isLastL1RequestEvacuation = s.getL1Request(lastL1RequestId).opType == Operations.OpType.EVACUATION;
+            if (!isLastL1RequestEvacuation) revert NotConsumedAllL1Requests(executedL1RequestNum, totalL1RequestNum);
+        }
     }
 
     /// @notice Internal function to get the L1 request of the specified id
     /// @param s The rollup storage
     /// @param requestId The id of the specified request
     /// @return request The request of the specified id
     function getL1Request(RollupStorage.Layout storage s, uint64 requestId) internal view returns (Request memory) {
         return s.l1RequestQueue[requestId];
     }
 
     /// @notice Internal function to get the number of committed L1 request
     /// @param s The rollup storage
     /// @return committedL1RequestNum The number of committed L1 requests
     function getCommittedL1RequestNum(RollupStorage.Layout storage s) internal view returns (uint64) {
         return s.committedL1RequestNum;
     }
 
     /// @notice Internal function to get the number of executed L1 request
     /// @param s The rollup storage
     /// @return executedL1RequestNum The number of executed L1 requests
     function getExecutedL1RequestNum(RollupStorage.Layout storage s) internal view returns (uint64) {
         return s.executedL1RequestNum;
     }
 
     /// @notice Internal function to get the total number of L1 request
     /// @param s The rollup storage
     /// @return totalL1RequestNum The total number of L1 requests
     function getTotalL1RequestNum(RollupStorage.Layout storage s) internal view returns (uint64) {
         return s.totalL1RequestNum;
     }
 
     /// @notice Internal function to get the number of committed block
     /// @param s The rollup storage
     /// @return committedBlockNum The number of committed block
     function getCommittedBlockNum(RollupStorage.Layout storage s) internal view returns (uint32) {
         return s.committedBlockNum;
     }
 
     /// @notice Internal function to get the number of verified block
     /// @param s The rollup storage
     /// @return verifiedBlockNum The number of verified block
     function getVerifiedBlockNum(RollupStorage.Layout storage s) internal view returns (uint32) {
         return s.verifiedBlockNum;
     }
 
     /// @notice Internal function to get the number of executed block
     /// @param s The rollup storage
     /// @return executedBlockNum The number of executed block
     function getExecutedBlockNum(RollupStorage.Layout storage s) internal view returns (uint32) {
         return s.executedBlockNum;
     }
 
     /// @notice Internal function to get the stored block hash
     /// @param s The rollup storage
     /// @param blockNum The block number
     /// @return storedBlockHash The stored block hash
     function getStoredBlockHash(RollupStorage.Layout storage s, uint32 blockNum) internal view returns (bytes32) {
         return s.storedBlockHashes[blockNum];
     }
 
     /// @notice Internal function to get the pending balance of the specified key
     /// @param s The rollup storage
     /// @param key The key of the pending balance
     /// @return pendingBalances The pending balance of the specified key
     function getPendingBalances(RollupStorage.Layout storage s, bytes22 key) internal view returns (uint256) {
         return s.pendingBalances[key];
     }
 
     /// @notice Internal function to check whether the request id is greater than or equal to the current request number
     /// @param s The rollup storage
     /// @param requestId The id of the request
     /// @return bool Return true is the request id is greater than the current request number, else return false
     function isRequestIdGtOrEqCurRequestNum(
         RollupStorage.Layout storage s,
         uint64 requestId
     ) internal view returns (bool) {
         uint64 curRequestNum = s.getTotalL1RequestNum();
         return requestId >= curRequestNum;
     }
 
     /// @notice Internal function to check whether the block hash is equal to the stored block hash
     /// @param s The rollup storage
     /// @param blockNum The block number
     /// @param storedBlock The stored block will be checked
     function requireBlockHashIsEq(
         RollupStorage.Layout storage s,
         uint32 blockNum,
         StoredBlock memory storedBlock
     ) internal view {
         if (s.getStoredBlockHash(blockNum) != keccak256(abi.encode(storedBlock)))
             revert BlockHashIsNotEq(blockNum, storedBlock);
     }
 
     /// @notice Internal function to check whether the new block timestamp is valid
     /// @param newBlockTimestamp The new block timestamp
     /// @param lastBlockTimestamp The last block timestamp
     function requireValidBlockTimestamp(uint256 newBlockTimestamp, uint256 lastBlockTimestamp) internal view {
         if (newBlockTimestamp < lastBlockTimestamp)
             revert TimestampLtPreviousBlock(newBlockTimestamp, lastBlockTimestamp);
         if (
             // solhint-disable-next-line not-rely-on-time
             newBlockTimestamp < block.timestamp - Config.COMMIT_BLOCK_TIMESTAMP_MAX_TOLERANCE ||
             // solhint-disable-next-line not-rely-on-time
             newBlockTimestamp > block.timestamp + Config.COMMIT_BLOCK_TIMESTAMP_MAX_DEVIATION
             // solhint-disable-next-line not-rely-on-time
         ) revert InvalidBlockTimestamp(newBlockTimestamp, block.timestamp);
     }
 
     /// @notice Internal function to check whether the register request is in the L1 request queue
     /// @param request The L1 request
     /// @param register The register request
     /// @return bool if the register request is in the L1 request queue
     function isRegisterInL1RequestQueue(
         Request memory request,
         Operations.Register memory register
     ) internal pure returns (bool) {
         requireMatchedOpType(request.opType, Operations.OpType.REGISTER);
         if (Operations.isRegisterHashedPubDataMatched(register, request.hashedPubData)) return true;
         return false;
     }
 
     /// @notice Internal function to check whether the deposit request is in the L1 request queue
     /// @param request The L1 request
     /// @param deposit The deposit request
     /// @return bool if the deposit request is in the L1 request queue
     function isDepositInL1RequestQueue(
         Request memory request,
         Operations.Deposit memory deposit
     ) internal pure returns (bool) {
         requireMatchedOpType(request.opType, Operations.OpType.DEPOSIT);
         if (Operations.isDepositHashedPubDataMatched(deposit, request.hashedPubData)) return true;
         return false;
     }
 
     /// @notice Internal function to check whether the force withdraw request is in the L1 request queue
     /// @param request The L1 request
     /// @param forceWithdraw The force withdraw request
     /// @return bool if the force withdraw request is in the L1 request queue
     function isForceWithdrawInL1RequestQueue(
         Request memory request,
         Operations.ForceWithdraw memory forceWithdraw
     ) internal pure returns (bool) {
         requireMatchedOpType(request.opType, Operations.OpType.FORCE_WITHDRAW);
         if (Operations.isForceWithdrawHashedPubDataMatched(forceWithdraw, request.hashedPubData)) return true;
         return false;
     }
 
     /// @notice Internal function to check whether the evacuation is in the L1 request queue
     /// @param request The L1 request
     /// @param evacuation The evacuation request
     /// @return bool if the evacuation request is in the L1 request queue
     function isEvacuationInL1RequestQueue(
         Request memory request,
         Operations.Evacuation memory evacuation
     ) internal pure returns (bool) {
         requireMatchedOpType(request.opType, Operations.OpType.EVACUATION);
         if (Operations.isEvacuationHashedPubDataMatched(evacuation, request.hashedPubData)) return true;
         return false;
     }
 
+    /// @notice Internal function to check whether the roll borrow request is in the L1 request queue
+    /// @param request The L1 request
+    /// @param rollBorrow The roll borrow request
+    /// @return bool if the roll borrow request is in the L1 request queue
+    function isRollBorrowInL1RequestQueue(
+        Request memory request,
+        Operations.RollBorrow memory rollBorrow
+    ) internal pure returns (bool) {
+        requireMatchedOpType(request.opType, Operations.OpType.ROLL_BORROW_ORDER);
+        if (Operations.isRollBorrowHashedPubDataMatched(rollBorrow, request.hashedPubData)) return true;
+        return false;
+    }
+
+    /// @notice Internal function to check whether the force cancel roll borrow request is in the L1 request queue
+    /// @param request The L1 request
+    /// @param forceCancelRollBorrow The force cancel roll borrow request
+    /// @return bool if the force cancel roll borrow request is in the L1 request queue
+    function isForceCancelRollBorrowInL1RequestQueue(
+        Request memory request,
+        Operations.CancelRollBorrow memory forceCancelRollBorrow
+    ) internal pure returns (bool) {
+        requireMatchedOpType(request.opType, Operations.OpType.FORCE_CANCEL_ROLL_BORROW);
+        if (Operations.isForceCancelRollBorrowHashedPubDataMatched(forceCancelRollBorrow, request.hashedPubData))
+            return true;
+        return false;
+    }
+
     /// @notice Internal function check if the operation type is matched
     /// @param opType The operation type of the request
     /// @param expectedOpType The expected operation type
     function requireMatchedOpType(Operations.OpType opType, Operations.OpType expectedOpType) internal pure {
         if (opType != expectedOpType) revert OpTypeIsNotMatched(opType, expectedOpType);
     }
 
     /// @notice Internal function to check whether the new block number is valid
     /// @param newBlockNum The new block number
     /// @param lastBlockNum The last block number
     function requireValidBlockNum(uint32 newBlockNum, uint32 lastBlockNum) internal pure {
         if (newBlockNum != lastBlockNum + 1) revert InvalidBlockNum(newBlockNum, lastBlockNum);
     }
 
     /// @notice Internal function to check whether the public data length is valid
     /// @dev The public data length should be multiple of chunk size
     /// @dev The numbers of chunk should be multiple of 8
     /// @param pubDataLength The public data length
     function requireValidPubDataLength(uint256 pubDataLength) internal pure {
         // Two assertions below are equivalent to the assertion below
         // assert(publicDataLength % Config.BYTES_OF_CHUNK == 0) &&
         // assert((publicDataLength / Config.BYTES_OF_CHUNK) % BITS_OF_BYTES == 0)
         // ==> assert(publicDataLength % (Config.BYTES_OF_CHUNK * BITS_OF_BYTES) == 0)
         // ==> assert(publicDataLength % Config.BITS_OF_CHUNK == 0)
         if (pubDataLength % Config.BITS_OF_CHUNK != 0) revert InvalidPubDataLength(pubDataLength);
     }
 
     /// @notice Internal function to calculate the pending balance key
     /// @param addr The user address
     /// @param tokenId The token id
     /// @return pendingBalanceKey The key of pending balance
     function calcPendingBalanceKey(address addr, uint16 tokenId) internal pure returns (bytes22) {
         return bytes22((uint176(uint160(addr)) | (uint176(tokenId) << 160)));
     }
+
+    /// @notice Internal function calculate the commitment of the new block
+    /// @dev    newTsRoot is packed in commitment for data availablity and will be proved in the circuit
+    /// @param previousBlock The previous block
+    /// @param newBlock The new block to be committed
+    /// @param commitmentOffset The offset of the commitment
+    /// @return commitment The commitment of the new block
+    function calcBlockCommitment(
+        StoredBlock memory previousBlock,
+        CommitBlock calldata newBlock,
+        bytes memory commitmentOffset
+    ) internal pure returns (bytes32) {
+        return
+            sha256(
+                abi.encodePacked(
+                    previousBlock.stateRoot,
+                    newBlock.newStateRoot,
+                    newBlock.newTsRoot,
+                    newBlock.timestamp,
+                    commitmentOffset,
+                    newBlock.publicData
+                )
+            );
+    }
 }
diff --git a/contracts/zkTrueUp/rollup/RollupStorage.sol b/contracts/zkTrueUp/rollup/RollupStorage.sol
index b56ea38..c2c513e 100644
--- a/contracts/zkTrueUp/rollup/RollupStorage.sol
+++ b/contracts/zkTrueUp/rollup/RollupStorage.sol
@@ -1,93 +1,89 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
 import {Operations} from "../libraries/Operations.sol";
 
 /// @notice Data for verifying block
 struct Proof {
     uint256[2] a;
     uint256[2][2] b;
     uint256[2] c;
     uint256[1] commitment;
 }
 
 /// @notice Stored block data (stored after block is committed)
 struct StoredBlock {
     uint32 blockNumber;
     uint64 l1RequestNum;
     bytes32 pendingRollupTxHash;
     bytes32 commitment;
     bytes32 stateRoot;
     uint256 timestamp;
 }
 
 /// @notice Data needed to be committed (passed in by sequencer)
 struct CommitBlock {
     uint32 blockNumber;
     bytes32 newStateRoot;
     bytes32 newTsRoot;
     uint256 timestamp;
     uint16[] chunkIdDeltas;
     bytes publicData;
 }
 
 /// @notice Data needed to be verified (passed in by sequencer)
 struct VerifyBlock {
     StoredBlock storedBlock;
     Proof proof;
 }
 
 /// @notice Data needed to be executed (passed in by sequencer)
 struct ExecuteBlock {
     StoredBlock storedBlock;
     bytes[] pendingRollupTxPubData;
 }
 
 /// @dev The priority request needs to be executed before the expirationBlock, or the system will enter the evacuation mode
 struct Request {
     Operations.OpType opType;
     uint32 expirationTime;
     bytes32 hashedPubData;
 }
 
 /**
  * @title Term Structure Rollup Storage
  * @author Term Structure Labs
  */
 library RollupStorage {
     bytes32 internal constant STORAGE_SLOT = bytes32(uint256(keccak256("zkTrueUp.contracts.storage.Rollup")) - 1);
 
     struct Layout {
-        /// @notice Mode of evacuation (true: evacuation mode, false: normal mode)
-        bool evacuMode;
         /// @notice Total number of committed blocks
         uint32 committedBlockNum;
         /// @notice Total number of verified blocks
         uint32 verifiedBlockNum;
         /// @notice Total number of executed blocks
         uint32 executedBlockNum;
         /// @notice The total number of committed L1 requests
         uint64 committedL1RequestNum;
         /// @notice The total number of executed L1 requests
         uint64 executedL1RequestNum;
         /// @notice The total number of L1 requests including pending ones
         uint64 totalL1RequestNum;
         /// @notice L1 request queue
         mapping(uint64 => Request) l1RequestQueue;
         /// @notice pending balances for withdrawal
         mapping(bytes22 => uint256) pendingBalances;
         /// @notice Stored hashed StoredBlock for some block number
         mapping(uint32 => bytes32) storedBlockHashes;
-        /// @notice Mapping of L2 Account Id => L2 Token Id => isEvacuated
-        mapping(uint32 => mapping(uint16 => bool)) evacuated;
     }
 
     function layout() internal pure returns (Layout storage s) {
         bytes32 slot = STORAGE_SLOT;
 
         // solhint-disable-next-line no-inline-assembly
         assembly {
             s.slot := slot
         }
     }
 }
diff --git a/contracts/zkTrueUp/tsb/ITsbFacet.sol b/contracts/zkTrueUp/tsb/ITsbFacet.sol
index 5863600..dec7653 100644
--- a/contracts/zkTrueUp/tsb/ITsbFacet.sol
+++ b/contracts/zkTrueUp/tsb/ITsbFacet.sol
@@ -1,95 +1,119 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
 import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 import {ITsbToken} from "../interfaces/ITsbToken.sol";
 
 /**
  * @title Term Structure Bond Facet Interface
  * @author Term Structure Labs
  */
 interface ITsbFacet {
     /// @notice Error for create TsbToken with invalid maturity time
     error InvalidMaturityTime(uint32 maturityTime);
     /// @notice Error for create TsbToken with invalid base token address
     error UnderlyingAssetIsNotExist(uint16 underlyingTokenId);
     /// @notice Error for create TsbToken which is already exist
     error TsbTokenIsExist(ITsbToken existTsbToken);
     /// @notice Error for redeem with invalid tsb token
     error InvalidTsbToken(IERC20 invalidToken);
     /// @notice Error for create TsbToken
     error TsbTokenCreateFailed(string name, string symbol, IERC20 underlyingAsset, uint32 maturity);
 
     /// @notice Emitted when a new TSB token is created
     /// @param tsbToken The created TSB token
     /// @param underlyingAsset The underlying asset of the created TSB token
     /// @param maturity The maturity of the created TSB token
     event TsbTokenCreated(ITsbToken indexed tsbToken, IERC20 underlyingAsset, uint32 maturity);
 
     /// @notice Emitted when the lender redeem the tsbToken
-    /// @param sender The address of the sender
+    /// @param caller The address of the `msg.sender`
+    /// @param accountAddr The address of the account
     /// @param tsbToken The tsbToken to redeem
     /// @param underlyingAsset The underlying asset of the tsbToken
     /// @param amount The amount of the underlying asset
     /// @param redeemAndDeposit Whether to deposit the underlying asset after redeem the tsbToken
     event Redemption(
-        address indexed sender,
+        address indexed caller,
+        address indexed accountAddr,
         ITsbToken indexed tsbToken,
         IERC20 underlyingAsset,
         uint256 amount,
         bool redeemAndDeposit
     );
 
     /// @notice Create a new tsbToken
     /// @param underlyingTokenId The token id of the underlying asset
     /// @param maturityTime The maturity time of the tsbToken
     /// @param name The name of the tsbToken
     /// @param symbol The symbol of the tsbToken
     function createTsbToken(
         uint16 underlyingTokenId,
         uint32 maturityTime,
         string memory name,
         string memory symbol
     ) external;
 
     /// @notice Redeem tsbToken
     /// @dev TSB token can be redeemed only after maturity
+    /// @param accountAddr The address of the account
     /// @param tsbToken The tsbToken to redeem
     /// @param amount The amount of the tsbToken
     /// @param redeemAndDeposit Whether to deposit the underlying asset after redeem the tsbToken
-    function redeem(ITsbToken tsbToken, uint128 amount, bool redeemAndDeposit) external;
+    function redeem(address accountAddr, ITsbToken tsbToken, uint128 amount, bool redeemAndDeposit) external;
+
+    /// @notice Redeem tsbToken with permit
+    /// @dev TSB token can be redeemed only after maturity
+    /// @param accountAddr The address of the account
+    /// @param tsbToken The tsbToken to redeem
+    /// @param amount The amount of the tsbToken
+    /// @param redeemAndDeposit Whether to deposit the underlying asset after redeem the tsbToken
+    /// @param deadline The deadline of the permit
+    /// @param v The recovery id of the signature
+    /// @param r The r of the permit signature
+    /// @param s The s of the permit signature
+    function redeemWithPermit(
+        address accountAddr,
+        ITsbToken tsbToken,
+        uint128 amount,
+        bool redeemAndDeposit,
+        uint256 deadline,
+        uint8 v,
+        bytes32 r,
+        bytes32 s
+    ) external;
 
     /// @notice Get the tsbToken
     /// @param underlyingTokenId The token id of the underlying asset
     /// @param maturity The maturity of the tsbToken
     /// @return tsbToken The tsbToken of the underlying asset and maturity
     function getTsbToken(uint16 underlyingTokenId, uint32 maturity) external view returns (ITsbToken tsbToken);
 
     /// @notice Check the balance of the tsbToken
     /// @param account The address of the account
     /// @param tsbToken The tsbToken to check
     /// @return balance The balance of the tsbToken
     function balanceOf(address account, ITsbToken tsbToken) external view returns (uint256);
 
     /// @notice Check the allowance of the tsbToken
     /// @param owner The address of the owner
     /// @param spender The address of the spender
     /// @param tsbToken The tsbToken to check
     /// @return allowance_ The allowance of the tsbToken
     function allowance(address owner, address spender, ITsbToken tsbToken) external view returns (uint256 allowance_);
 
     /// @notice Check the total supply of the tsbToken
     /// @param tsbToken The tsbToken to check
     /// @return totalSupply The total supply of the tsbToken
     function activeSupply(ITsbToken tsbToken) external view returns (uint256 totalSupply);
 
     /// @notice Return the underlying asset of the tsbToken
     /// @param tsbToken The tsbToken to check
     /// @return underlyingAsset The underlying asset of the tsbToken
     function getUnderlyingAsset(ITsbToken tsbToken) external view returns (IERC20 underlyingAsset);
 
     /// @notice Return the maturity time of the tsbToken
     /// @param tsbToken The tsbToken to check
     /// @return maturityTime The maturity time of the tsbToken
     function getMaturityTime(ITsbToken tsbToken) external view returns (uint32 maturityTime);
 }
diff --git a/contracts/zkTrueUp/tsb/TsbFacet.sol b/contracts/zkTrueUp/tsb/TsbFacet.sol
index 492b4a7..5dadd89 100644
--- a/contracts/zkTrueUp/tsb/TsbFacet.sol
+++ b/contracts/zkTrueUp/tsb/TsbFacet.sol
@@ -1,151 +1,229 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
 import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
 import {AccessControlInternal} from "@solidstate/contracts/access/access_control/AccessControlInternal.sol";
 import {ReentrancyGuard} from "@solidstate/contracts/security/reentrancy_guard/ReentrancyGuard.sol";
 import {AccountStorage} from "../account/AccountStorage.sol";
 import {RollupStorage} from "../rollup/RollupStorage.sol";
 import {TokenStorage} from "../token/TokenStorage.sol";
-import {TsbStorage} from "./TsbStorage.sol";
+import {TsbStorage, REDEEM_TYPEHASH} from "./TsbStorage.sol";
 import {TsbLib} from "./TsbLib.sol";
 import {ITsbFacet} from "./ITsbFacet.sol";
 import {TsbToken} from "../tsb/TsbToken.sol";
 import {TokenLib} from "../token/TokenLib.sol";
 import {AssetConfig} from "../token/TokenStorage.sol";
 import {AccountLib} from "../account/AccountLib.sol";
-import {RollupLib} from "../rollup/RollupLib.sol";
 import {ITsbToken} from "../interfaces/ITsbToken.sol";
 import {Config} from "../libraries/Config.sol";
 import {Utils} from "../libraries/Utils.sol";
+import {DELEGATE_REDEEM_MASK} from "../libraries/Delegate.sol";
 
 /**
  * @title Term Structure Bond Facet Contract
  * @author Term Structure Labs
  * @notice The Term Structure Bond Facet (TsbFacet) is a contract to manages TsbTokens
  */
 contract TsbFacet is ITsbFacet, AccessControlInternal, ReentrancyGuard {
     using AccountLib for AccountStorage.Layout;
     using TokenLib for TokenStorage.Layout;
     using TsbLib for TsbStorage.Layout;
     using Utils for *;
 
     /* ============ External Admin Functions ============ */
 
     /**
      * @inheritdoc ITsbFacet
      * @dev This function is only called by the operator
      */
     function createTsbToken(
         uint16 underlyingTokenId,
         uint32 maturityTime,
         string memory name,
         string memory symbol
     ) external virtual onlyRole(Config.OPERATOR_ROLE) {
         // solhint-disable-next-line not-rely-on-time
         if (maturityTime <= block.timestamp) revert InvalidMaturityTime(maturityTime);
         TokenStorage.Layout storage tsl = TokenStorage.layout();
         IERC20 underlyingAsset = tsl.getAssetConfig(underlyingTokenId).token;
         if (address(underlyingAsset) == address(0)) revert UnderlyingAssetIsNotExist(underlyingTokenId);
 
         TsbStorage.Layout storage tsbsl = TsbStorage.layout();
         uint48 tsbTokenKey = TsbLib.calcTsbTokenKey(underlyingTokenId, maturityTime);
         ITsbToken tsbToken = tsbsl.getTsbToken(tsbTokenKey);
         if (address(tsbToken) != address(0)) revert TsbTokenIsExist(tsbToken);
 
         try new TsbToken(name, symbol, underlyingAsset, maturityTime) returns (TsbToken newTsbToken) {
             tsbToken = ITsbToken(address(newTsbToken));
             tsbsl.tsbTokens[tsbTokenKey] = tsbToken;
             emit TsbTokenCreated(tsbToken, underlyingAsset, maturityTime);
         } catch {
             revert TsbTokenCreateFailed(name, symbol, underlyingAsset, maturityTime);
         }
     }
 
     /* ============ External Functions ============ */
 
     /**
      * @inheritdoc ITsbFacet
      * @dev TSB token can be redeemed only after maturity
      * @dev TSB token decimals is 8 and should be converted to underlying asset decimals when 1:1 redeem
      */
-    function redeem(ITsbToken tsbToken, uint128 amount, bool redeemAndDeposit) external nonReentrant {
-        TokenStorage.Layout storage tsl = TokenStorage.layout();
-        (, AssetConfig memory assetConfig) = tsl.getAssetConfig(tsbToken);
-        if (!assetConfig.isTsbToken) revert InvalidTsbToken(tsbToken);
-
-        (IERC20 underlyingAsset, uint32 maturityTime) = tsbToken.tokenInfo();
-        TsbLib.requireMatured(tsbToken, maturityTime);
-
-        TsbLib.burnTsbToken(tsbToken, msg.sender, amount);
-        emit Redemption(msg.sender, tsbToken, underlyingAsset, amount, redeemAndDeposit);
-
-        (uint16 tokenId, AssetConfig memory underlyingAssetConfig) = tsl.getValidToken(underlyingAsset);
-        // convert amount by decimals to 1:1 redeem underlying asset
-        uint128 underlyingAssetAmt = SafeCast.toUint128(amount.toL1Amt(underlyingAssetConfig.decimals));
+    function redeem(
+        address accountAddr,
+        ITsbToken tsbToken,
+        uint128 amount,
+        bool redeemAndDeposit
+    ) external nonReentrant {
+        AccountStorage.Layout storage asl = AccountStorage.layout();
+        asl.requireValidCaller(msg.sender, accountAddr, DELEGATE_REDEEM_MASK);
+
+        uint32 accountId = asl.getValidAccount(accountAddr);
+        _redeem(msg.sender, accountAddr, accountId, tsbToken, amount, redeemAndDeposit);
+    }
 
-        if (redeemAndDeposit) {
-            uint32 accountId = AccountStorage.layout().getValidAccount(msg.sender);
-            TokenLib.validDepositAmt(underlyingAssetAmt, underlyingAssetConfig.minDepositAmt);
-            AccountLib.addDepositReq(
-                RollupStorage.layout(),
-                msg.sender,
-                accountId,
-                underlyingAssetConfig.token,
-                tokenId,
-                underlyingAssetConfig.decimals,
-                underlyingAssetAmt
-            );
-        } else {
-            Utils.transfer(underlyingAsset, payable(msg.sender), underlyingAssetAmt);
-        }
+    //! mainnet-audit
+    /**
+     * @inheritdoc ITsbFacet
+     * @dev TSB token can be redeemed only after maturity
+     * @dev TSB token decimals is 8 and should be converted to underlying asset decimals when 1:1 redeem
+     */
+    function redeemWithPermit(
+        address accountAddr,
+        ITsbToken tsbToken,
+        uint128 amount,
+        bool redeemAndDeposit,
+        uint256 deadline,
+        uint8 v,
+        bytes32 r,
+        bytes32 s
+    ) external nonReentrant {
+        AccountStorage.Layout storage asl = AccountStorage.layout();
+        bytes32 structHash = _calcRedeemStructHash(
+            tsbToken,
+            amount,
+            redeemAndDeposit,
+            asl.getPermitNonce(accountAddr),
+            deadline
+        );
+        asl.validatePermitAndIncreaseNonce(accountAddr, structHash, deadline, v, r, s);
+
+        uint32 accountId = asl.getValidAccount(accountAddr);
+
+        _redeem(msg.sender, accountAddr, accountId, tsbToken, amount, redeemAndDeposit);
     }
 
     /* ============ External View Functions ============ */
 
     /**
      * @inheritdoc ITsbFacet
      */
     function getTsbToken(uint16 underlyingTokenId, uint32 maturity) external view returns (ITsbToken) {
         uint48 tsbTokenKey = TsbLib.calcTsbTokenKey(underlyingTokenId, maturity);
         return TsbStorage.layout().getTsbToken(tsbTokenKey);
     }
 
     /**
      * @inheritdoc ITsbFacet
      */
     function balanceOf(address account, ITsbToken tsbToken) external view returns (uint256) {
         return tsbToken.balanceOf(account);
     }
 
     /**
      * @inheritdoc ITsbFacet
      */
     function allowance(address owner, address spender, ITsbToken tsbToken) external view returns (uint256) {
         return tsbToken.allowance(owner, spender);
     }
 
     /**
      * @inheritdoc ITsbFacet
      */
     function activeSupply(ITsbToken tsbToken) external view returns (uint256) {
         return tsbToken.totalSupply();
     }
 
     /**
      * @inheritdoc ITsbFacet
      */
     function getUnderlyingAsset(ITsbToken tsbToken) external view returns (IERC20) {
         (IERC20 underlyingAsset, ) = tsbToken.tokenInfo();
         return underlyingAsset;
     }
 
     /**
      * @inheritdoc ITsbFacet
      */
     function getMaturityTime(ITsbToken tsbToken) external view returns (uint32) {
         (, uint32 maturityTime) = tsbToken.tokenInfo();
         return maturityTime;
     }
+
+    /* ============ Internal Functions ============ */
+
+    /// @notice Internal redeem collateral function
+    /// @param caller The caller of the function
+    /// @param accountAddr The address of the account in L1
+    /// @param accountId The id of the account in L2
+    /// @param tsbToken The TsbToken to be redeemed
+    /// @param amount The amount of the TsbToken to be redeemed
+    /// @param redeemAndDeposit The flag of redeem and deposit
+    function _redeem(
+        address caller,
+        address accountAddr,
+        uint32 accountId,
+        ITsbToken tsbToken,
+        uint128 amount,
+        bool redeemAndDeposit
+    ) internal {
+        TokenStorage.Layout storage tsl = TokenStorage.layout();
+        (, AssetConfig memory assetConfig) = tsl.getAssetConfig(tsbToken);
+        if (!assetConfig.isTsbToken) revert InvalidTsbToken(tsbToken);
+
+        (IERC20 underlyingAsset, uint32 maturityTime) = tsbToken.tokenInfo();
+        TsbLib.requireMatured(tsbToken, maturityTime);
+
+        TsbLib.burnTsbToken(tsbToken, accountAddr, amount);
+        emit Redemption(caller, accountAddr, tsbToken, underlyingAsset, amount, redeemAndDeposit);
+
+        (uint16 tokenId, AssetConfig memory underlyingAssetConfig) = tsl.getValidToken(underlyingAsset);
+        // convert amount by decimals to 1:1 redeem underlying asset
+        uint128 underlyingAssetAmt = SafeCast.toUint128(amount.toL1Amt(underlyingAssetConfig.decimals));
+
+        if (redeemAndDeposit) {
+            TokenLib.validDepositAmt(underlyingAssetAmt, underlyingAssetConfig.minDepositAmt);
+            AccountLib.addDepositReq(
+                RollupStorage.layout(),
+                caller,
+                accountAddr,
+                accountId,
+                underlyingAssetConfig.token,
+                tokenId,
+                underlyingAssetConfig.decimals,
+                underlyingAssetAmt
+            );
+        } else {
+            Utils.transfer(underlyingAsset, payable(accountAddr), underlyingAssetAmt);
+        }
+    }
+
+    /* ============ Internal Pure Functions to Calculate Struct Hash ============ */
+
+    /// @notice Calculate the hash of the struct for the redeem permit
+    /// @param tsbToken The TsbToken to be redeemed
+    /// @param amount The amount of the TsbToken to be redeemed
+    /// @param redeemAndDeposit The flag of redeem and deposit
+    /// @param nonce The nonce of the permit
+    /// @param deadline The deadline of the permit
+    function _calcRedeemStructHash(
+        ITsbToken tsbToken,
+        uint128 amount,
+        bool redeemAndDeposit,
+        uint256 nonce,
+        uint256 deadline
+    ) internal pure returns (bytes32) {
+        return keccak256(abi.encode(REDEEM_TYPEHASH, tsbToken, amount, redeemAndDeposit, nonce, deadline));
+    }
 }
diff --git a/contracts/zkTrueUp/tsb/TsbStorage.sol b/contracts/zkTrueUp/tsb/TsbStorage.sol
index 2a90ed7..f3f48d6 100644
--- a/contracts/zkTrueUp/tsb/TsbStorage.sol
+++ b/contracts/zkTrueUp/tsb/TsbStorage.sol
@@ -1,27 +1,34 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.17;
 
 import {ITsbToken} from "../interfaces/ITsbToken.sol";
 
+/* ============ The type hash of sign typed data v4 for permit functions ============ */
+
+// redeem function type hash
+bytes32 constant REDEEM_TYPEHASH = keccak256(
+    "Redeem(address tsbToken,uint128 amount,bool redeemAndDeposit,uint256 nonce,uint256 deadline)"
+);
+
 /**
  * @title Term Structure Bond Storage
  * @author Term Structure Labs
  */
 library TsbStorage {
     bytes32 internal constant STORAGE_SLOT = bytes32(uint256(keccak256("zkTrueUp.contracts.storage.Tsb")) - 1);
 
     struct Layout {
         /// @notice Mapping of tsbTokenKey => tsbTokens
         /// tsbTokenKey = (uint48(underlyingTokenId) << 32) | uint32 maturity
         mapping(uint48 => ITsbToken) tsbTokens;
     }
 
     function layout() internal pure returns (Layout storage s) {
         bytes32 slot = STORAGE_SLOT;
 
         // solhint-disable-next-line no-inline-assembly
         assembly {
             s.slot := slot
         }
     }
 }
